
% Change file for TeX 3.14159 in C, derived from various other change files
% by Tim Morgan, UC Irvine ICS Department, and many others
%
% NOTE: the module numbers in this change file refer to the published
%       text in TeX, the Program, Volume B. 1986
%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hints:
% To add a new command do:
%    1) determine its command or modifier code
%    2) add a primitive call for it
%    3) add a case to prnt_cmd_chr for it
%    4) add a case to big switch of main control
%    5) add a case to Assignment switch of prefixed_command if approperiate
%    6) change version in banner and add a Version line below
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Version 3.10 move shift_amount negation to hlist_out routine (1383/6/15)
% Version 3.11 extend buf_size (3000->16384), fixed left right skips (1383/8/9)
% Version 3.12 extend adding LR to halign columns  (1383/8/25)
% Version 3.13 adding param_size from 60 to 120    (1383/10/5)
% Version 3.014 fixing \eqnotname anomalies    (1383/10/10)
% Version 3.015 adding ignrautoLR    (1383/12/8)
% Version 3.016 adding \ifsplited    (1384/1/31)
% Version 3.017 fixing space in printing در اندازه  (1384/7/14)
% Version 3.018 adding some comments  (1384/12/16)
% Version 3.019 reorganizing \pTeX changes  (1384/12/26)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [0] WEAVE: only print changes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x Tell WEAVE to print only the changes:
  \def\?##1]{\hbox to 1in{\hfil##1.\ }}
  }
@y
  \def\?##1]{\hbox{Changes to \hbox to 1em{\hfil##1}.\ }}
  }
\let\maybe=\iffalse
\inputR RtoLmac
\def\pTeXaltstr{\pTeXchg{Print alternate strings.}}
\def\pTeXnewprt{\pTeXchg{Use newly defined printing macros.}}
\def\pTeXusechr{\pTeXchg{Use semitic characters same as latin's.}}
\def\pTeXeqnm{\pTeXchg{Deal with equated commands.}}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.2] banner line
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    2
@d banner=='This is TeX, Version 3.141592' {printed when \TeX\ starts}
@y    2==============
\beginRt{\تک:}
در این متن بخشهایی که حاوی تغییرات \تک{} است را با همین نام نشان می‌دهیم.
 بنابراین تغییرات بخشهایی که بدون این نام اعمال شده مربوط به گونهٔ\سی{} است.

برای سهولت در پیگیری تغییرات ویژهٔ \تک{}، این تغییرات  در چند بخش نسبتاً مستقل 
تشریح می‌شود. بنابراین برای اعمال 
تغییراتی که به‌ناچار باید در لابلای برنامهٔ جاگذاری شود 
 عناوینی مشخص می‌شود که شرح آنها در بخش مربوط خواهد آمد.

فهرست بخشهایی که تغییرات ویژهٔ \تک{} در آنها تعریف می‌شوند عبارتست از:

ساختار دوجهته

پردازش دوجهته

فرمانهای مشابه

قابلیتهای جدید

سایر تغییرات
\endRt
\pTeXchg{Change \TeX{} to \TeX-e-Parsi.}
@d banner=="This is TeX-e-Parsi (Parsi-TeX) 3.019, Version 3.141592 "
    {printed when \TeX\ starts}
@d initex==" (INITEX)"
@d noformat==" (no format preloaded)"
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.4] program header
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
program TEX; {all file names are defined dynamically}
label @<Labels in the outer block@>@/
@y
program TEX; {all file names are defined dynamically}
@z
@x
@<Labels in the out...@>=
start_of_TEX@t\hskip-2pt@>, end_of_TEX@t\hskip-2pt@>,@,final_end;
@y
@<Labels in the outer block@>=
start_of_TEX@t\hskip-2pt@>, end_of_TEX@t\hskip-2pt@>,@,final_end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.7] debug..gubed, stat..tats
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Here we change these WEB symbols, which are used much as #ifdef's
% in C, into something which will get translated into actual #ifdef's.
@x
@d debug==@{ {change this to `$\\{debug}\equiv\null$' when debugging}
@d gubed==@t@>@} {change this to `$\\{gubed}\equiv\null$' when debugging}
@y
@d debug==ifdef('DEBUG')
@d gubed==endif('DEBUG')
@z
@x
@d stat==@{ {change this to `$\\{stat}\equiv\null$' when gathering
  usage statistics}
@d tats==@t@>@} {change this to `$\\{tats}\equiv\null$' when gathering
  usage statistics}
@y
@d stat==ifdef('STAT')
@d tats==endif('STAT')
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.8] init..tini
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d init== {change this to `$\\{init}\equiv\.{@@\{}$' in the production version}
@d tini== {change this to `$\\{tini}\equiv\.{@@\}}$' in the production version}
@y
@d init==ifdef('INITEX')
@d tini==endif('INITEX')
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.9] compiler directives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@{@&$C-,A+,D-@} {no range check, catch arithmetic overflow, no debug overhead}
@!debug @{@&$C+,D+@}@+ gubed {but turn everything on when debugging}
@y
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.11] compile-time constants, use logical names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% doubled mem_max for C since UCI people are memory hogs
% made dvi_buf_size=2*8192 for better BSD Unix I/O performance
% enlarged various other datastructures
@x
@!mem_max=30000; {greatest index in \TeX's internal |mem| array;
  must be strictly less than |max_halfword|;
  must be equal to |mem_top| in \.{INITEX}, otherwise |>=mem_top|}
@!mem_min=0; {smallest index in \TeX's internal |mem| array;
  must be |min_halfword| or more;
  must be equal to |mem_bot| in \.{INITEX}, otherwise |<=mem_bot|}
@!buf_size=500; {maximum number of characters simultaneously present in
  current lines of open files and in control sequences between
  \.{\\csname} and \.{\\endcsname}; must not exceed |max_halfword|}
@!error_line=72; {width of context lines on terminal error messages}
@!half_error_line=42; {width of first lines of contexts in terminal
  error messages; should be between 30 and |error_line-15|}
@!max_print_line=79; {width of longest text lines output; should be at least 60}
@!stack_size=200; {maximum number of simultaneous input sources}
@!max_in_open=6; {maximum number of input files and error insertions that
  can be going on simultaneously}
@!font_max=75; {maximum internal font number; must not exceed |max_quarterword|
  and must be at most |font_base+256|}
@!font_mem_size=20000; {number of words of |font_info| for all fonts}
@!param_size=60; {maximum number of simultaneous macro parameters}
@!nest_size=40; {maximum number of semantic levels simultaneously active}
@!max_strings=3000; {maximum number of strings; must not exceed |max_halfword|}
@!string_vacancies=8000; {the minimum number of characters that should be
  available for the user's control sequences and font names,
  after \TeX's own error messages are stored}
@!pool_size=32000; {maximum number of characters in strings, including all
  error messages and help texts, and the names of all fonts and
  control sequences; must exceed |string_vacancies| by the total
  length of \TeX's own strings, which is currently about 23000}
@!save_size=600; {space for saving values outside of current group; must be
  at most |max_halfword|}
@!trie_size=8000; {space for hyphenation patterns; should be larger for
  \.{INITEX} than it is in production versions of \TeX}
@!trie_op_size=500; {space for ``opcodes'' in the hyphenation patterns}
@!dvi_buf_size=800; {size of the output buffer; must be a multiple of 8}
@!file_name_size=40; {file names shouldn't be longer than this}
@!pool_name='TeXformats:TEX.POOL                     ';
  {string of length |file_name_size|; tells where the string pool appears}
@y
@!mem_max=524800; {greatest index in \TeX's internal |mem| array;
  must be strictly less than |max_halfword|;
  must be equal to |mem_top| in \.{INITEX}, otherwise |>=mem_top|}
@!mem_min=0; {smallest index in \TeX's internal |mem| array;
  must be |min_halfword| or more;
  must be equal to |mem_bot| in \.{INITEX}, otherwise |<=mem_bot|}
@!buf_size=16384; {maximum number of characters simultaneously present in
  current lines of open files and in control sequences between
  \.{\\csname} and \.{\\endcsname}; must not exceed |max_halfword|}
@!error_line=79; {width of context lines on terminal error messages}
@!half_error_line=50; {width of first lines of contexts in terminal
  error messages; should be between 30 and |error_line-15|}
@!max_print_line=79; {width of longest text lines output; should be at least 60}
@!stack_size=300; {maximum number of simultaneous input sources}
@!max_in_open=15; {maximum number of input files and error insertions that
  can be going on simultaneously}
@!font_max=255; {maximum internal font number; must not exceed|max_quarterword|
  and must be at most |font_base+256|}
@!font_mem_size=72000; {number of words of |font_info| for all fonts}
@!param_size=120; {maximum number of simultaneous macro parameters}
@!nest_size=40; {maximum number of semantic levels simultaneously active}
@!max_strings=17000; {maximum number of strings;
            must not exceed |max_halfword|}
@!string_vacancies=150000; {the minimum number of characters that should be
  available for the user's control sequences and font names,
  after \TeX's own error messages are stored}
@!pool_size=250000; {maximum number of characters in strings, including all
  error messages and help texts, and the names of all fonts and
  control sequences; must exceed |string_vacancies| by the total
  length of \TeX's own strings, which is currently about 23000}
@!save_size=4000; {space for saving values outside of current group; must be
  at most |max_halfword|}
@!trie_size=8000; {space for hyphenation patterns; should be larger for
  \.{INITEX} than it is in production versions of \TeX}
@!trie_op_size=751; {space for ``opcodes'' in the hyphenation patterns;
  best if relatively prime to 313, 361, and 1009, according to {\tt
  rocky@@watson.ibm.com}.}
@!dvi_buf_size=16384; {size of the output buffer; must be a multiple of 8}
@!file_name_size=1024; {file names shouldn't be longer than this}
@!pool_name='tex.pool';
  {string of length |file_name_size|; tells where the string pool appears}
@!mem_top=524800; {largest index in the |mem| array dumped by \.{INITEX};
  must be substantially larger than |mem_bot|
  and not greater than |mem_max|}
@!max_buf_line=1000; {width of longest text lines output; should be at least60}
@!neg_trie_op_size=-751; {for lower |trie_op_hash| array bound;
  must be equal to |-trie_op_size|.}
@!neg_max_strings=-11000; {|-max_strings|}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.12] sensitive compile-time constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For C we change mem_base and hi_mem_base to reflect our use of
% 0-origin vs pc's use of negative-origin.  Despite the fact that
% these are "sensitive" constants, we're going to make mem_top a
% #define in the C code for readability and ease of modification
% (it's up above).  Beware!
@x
@d mem_bot=0 {smallest index in the |mem| array dumped by \.{INITEX};
  must not be less than |mem_min|}
@d mem_top==30000 {largest index in the |mem| array dumped by \.{INITEX};
  must be substantially larger than |mem_bot|
  and not greater than |mem_max|}
@d font_base=0 {smallest internal font number; must not be less
  than |min_quarterword|}
@d hash_size=2100 {maximum number of control sequences; it should be at most
  about |(mem_max-mem_min)/10|}
@d hash_prime=1777 {a prime number equal to about 85\pct! of |hash_size|}
@d hyph_size=307 {another prime; the number of \.{\\hyphenation} exceptions}
@y
@d mem_bot=0 {smallest index in the |mem| array dumped by \.{INITEX};
  must not be less than |mem_min|}
@d font_base=0 {smallest internal font number; must not be less
  than |min_quarterword|}
@d hash_size=11000 {maximum number of control sequences; it should be at most
  about |(mem_max-mem_min)/10|, so we can be really generous}
@d hash_prime=9349 {The thousandth in a list of 1000 primes.  Run the primes
  program in LiterateProgramming to find out.  It is reasonably close to
  85\% of a |hash_size| of 9500}
@d hyph_size=607 {another prime; the number of \.{\\hyphenation} exceptions}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.16] Use C macros for incr()/decr()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% By not defining these, they slip through into the C code, where we
% use macros, which we hope generate more efficient code
@x
@d incr(#) == #:=#+1 {increase a variable by unity}
@d decr(#) == #:=#-1 {decrease a variable by unity}
@y
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.19] increasing character set
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    19
@d text_char == char {the data type of characters in text files}
@y    19===================
@d text_char == ASCII_code {the data type of characters in text files}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.21] using setup_xchrs 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    21
@<Set init...@>=
xchr[@'40]:=' ';
xchr[@'41]:='!';
xchr[@'42]:='"';
xchr[@'43]:='#';
xchr[@'44]:='$';
xchr[@'45]:='%';
xchr[@'46]:='&';
xchr[@'47]:='''';@/
xchr[@'50]:='(';
xchr[@'51]:=')';
xchr[@'52]:='*';
xchr[@'53]:='+';
xchr[@'54]:=',';
xchr[@'55]:='-';
xchr[@'56]:='.';
xchr[@'57]:='/';@/
xchr[@'60]:='0';
xchr[@'61]:='1';
xchr[@'62]:='2';
xchr[@'63]:='3';
xchr[@'64]:='4';
xchr[@'65]:='5';
xchr[@'66]:='6';
xchr[@'67]:='7';@/
xchr[@'70]:='8';
xchr[@'71]:='9';
xchr[@'72]:=':';
xchr[@'73]:=';';
xchr[@'74]:='<';
xchr[@'75]:='=';
xchr[@'76]:='>';
xchr[@'77]:='?';@/
xchr[@'100]:='@@';
xchr[@'101]:='A';
xchr[@'102]:='B';
xchr[@'103]:='C';
xchr[@'104]:='D';
xchr[@'105]:='E';
xchr[@'106]:='F';
xchr[@'107]:='G';@/
xchr[@'110]:='H';
xchr[@'111]:='I';
xchr[@'112]:='J';
xchr[@'113]:='K';
xchr[@'114]:='L';
xchr[@'115]:='M';
xchr[@'116]:='N';
xchr[@'117]:='O';@/
xchr[@'120]:='P';
xchr[@'121]:='Q';
xchr[@'122]:='R';
xchr[@'123]:='S';
xchr[@'124]:='T';
xchr[@'125]:='U';
xchr[@'126]:='V';
xchr[@'127]:='W';@/
xchr[@'130]:='X';
xchr[@'131]:='Y';
xchr[@'132]:='Z';
xchr[@'133]:='[';
xchr[@'134]:='\';
xchr[@'135]:=']';
xchr[@'136]:='^';
xchr[@'137]:='_';@/
xchr[@'140]:='`';
xchr[@'141]:='a';
xchr[@'142]:='b';
xchr[@'143]:='c';
xchr[@'144]:='d';
xchr[@'145]:='e';
xchr[@'146]:='f';
xchr[@'147]:='g';@/
xchr[@'150]:='h';
xchr[@'151]:='i';
xchr[@'152]:='j';
xchr[@'153]:='k';
xchr[@'154]:='l';
xchr[@'155]:='m';
xchr[@'156]:='n';
xchr[@'157]:='o';@/
xchr[@'160]:='p';
xchr[@'161]:='q';
xchr[@'162]:='r';
xchr[@'163]:='s';
xchr[@'164]:='t';
xchr[@'165]:='u';
xchr[@'166]:='v';
xchr[@'167]:='w';@/
xchr[@'170]:='x';
xchr[@'171]:='y';
xchr[@'172]:='z';
xchr[@'173]:='{';
xchr[@'174]:='|';
xchr[@'175]:='}';
xchr[@'176]:='~';@/
@y    21===================
\pTeXchg{We use an external function to deal with diversity of Farsi character
sets.}
@<Set init...@>=
@<Use |setup_xchrs|@>;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.23] all characters are legal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unlike the standard Unix TeX distribution, we allow all characters
% as legal input, to support SAIL and MIT input files on occasion.
@x
@<Set init...@>=
for i:=0 to @'37 do xchr[i]:=' ';
for i:=@'177 to @'377 do xchr[i]:=' ';
@y
\pTeXchg{Here we don't initialize anything, because |xchr| is supposed to be 
 read from external file |filter|. (see Setup |xchr| above)}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.25] file types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
The program actually makes use also of a third kind of file, called a
|word_file|, when dumping and reloading base information for its own
initialization.  We shall define a word file later; but it will be possible
for us to specify simple operations on word files before they are defined.

@y
I/O in C is done using standard I/O.  We will define the path numbers
in an include file for C which are used in searching for files to be
read.  We'll define all the file types in C also.
@z
@x
@!alpha_file=packed file of text_char; {files that contain textual data}
@!byte_file=packed file of eight_bits; {files that contain binary data}
@y
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.26] add real_name_of_file array
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
|name_of_file|.
@^system dependencies@>

@<Glob...@>=
@!name_of_file:packed array[1..file_name_size] of char;@;@/
  {on some systems this may be a \&{record} variable}
@y
|name_of_file|.

The C version uses search paths to look for files to open.
We use |real_name_of_file| to hold the |name_of_file| with a directory
name from the path in front of it.
@^system dependencies@>

@<Glob...@>=
@!name_of_file,@!real_name_of_file:packed array[1..file_name_size] of char;
@;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.27] file opening
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The \ph\ compiler with which the present version of \TeX\ was prepared has
extended the rules of \PASCAL\ in a very convenient way. To open file~|f|,
we can write
$$\vbox{\halign{#\hfil\qquad&#\hfil\cr
|reset(f,@t\\{name}@>,'/O')|&for input;\cr
|rewrite(f,@t\\{name}@>,'/O')|&for output.\cr}}$$
The `\\{name}' parameter, which is of type `{\bf packed array
$[\langle\\{any}\rangle]$ of \\{char}}', stands for the name of
the external file that is being opened for input or output.
Blank spaces that might appear in \\{name} are ignored.

The `\.{/O}' parameter tells the operating system not to issue its own
error messages if something goes wrong. If a file of the specified name
cannot be found, or if such a file cannot be opened for some other reason
(e.g., someone may already be trying to write the same file), we will have
|@!erstat(f)<>0| after an unsuccessful |reset| or |rewrite|.  This allows
\TeX\ to undertake appropriate corrective action.
@:PASCAL H}{\ph@>
@^system dependencies@>

\TeX's file-opening procedures return |false| if no file identified by
|name_of_file| could be opened.

@d reset_OK(#)==erstat(#)=0
@d rewrite_OK(#)==erstat(#)=0

@p function a_open_in(var f:alpha_file):boolean;
  {open a text file for input}
begin reset(f,name_of_file,'/O'); a_open_in:=reset_OK(f);
end;
@#
function a_open_out(var f:alpha_file):boolean;
  {open a text file for output}
begin rewrite(f,name_of_file,'/O'); a_open_out:=rewrite_OK(f);
end;
@#
function b_open_in(var f:byte_file):boolean;
  {open a binary file for input}
begin reset(f,name_of_file,'/O'); b_open_in:=reset_OK(f);
end;
@#
function b_open_out(var f:byte_file):boolean;
  {open a binary file for output}
begin rewrite(f,name_of_file,'/O'); b_open_out:=rewrite_OK(f);
end;
@#
function w_open_in(var f:word_file):boolean;
  {open a word file for input}
begin reset(f,name_of_file,'/O'); w_open_in:=reset_OK(f);
end;
@#
function w_open_out(var f:word_file):boolean;
  {open a word file for output}
begin rewrite(f,name_of_file,'/O'); w_open_out:=rewrite_OK(f);
end;
@y
@ All of the file opening functions will be defined as macros in C.
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.28] reserve file closure for C routines
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ Files can be closed with the \ph\ routine `|close(f)|', which
@^system dependencies@>
should be used when all input or output with respect to |f| has been completed.
This makes |f| available to be opened again, if desired; and if |f| was used for
output, the |close| operation makes the corresponding external file appear
on the user's area, ready to be read.

These procedures should not generate error messages if a file is
being closed before it has been successfully opened.

@p procedure a_close(var f:alpha_file); {close a text file}
begin close(f);
end;
@#
procedure b_close(var f:byte_file); {close a binary file}
begin close(f);
end;
@#
procedure w_close(var f:word_file); {close a word file}
begin close(f);
end;
@y
@ And all file closing as well.
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.31] Make input_ln an external C routine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function input_ln(var f:alpha_file;@!bypass_eoln:boolean):boolean;
  {inputs the next line or returns |false|}
var last_nonblank:0..buf_size; {|last| with trailing blanks removed}
begin if bypass_eoln then if not eof(f) then get(f);
  {input the first character of the line into |f^|}
last:=first; {cf.\ Matthew 19\thinspace:\thinspace30}
if eof(f) then input_ln:=false
else  begin last_nonblank:=first;
  while not eoln(f) do
    begin if last>=max_buf_stack then
      begin max_buf_stack:=last+1;
      if max_buf_stack=buf_size then
        @<Report overflow of the input buffer, and abort@>;
      end;
    buffer[last]:=xord[f^]; get(f); incr(last);
    if buffer[last-1]<>" " then last_nonblank:=last;
    end;
  last:=last_nonblank; input_ln:=true;
  end;
end;
@y
We'll get |input_ln| from an external C module, coded for efficiency
directly in C. 
%%\pTeXchg{We define directional types here.}
@<Types...@>=
@<\pTeX{} Types@>@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.32] term_in/out are input,output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
is considered an output file the file variable is |term_out|.
@^system dependencies@>

@<Glob...@>=
@!term_in:alpha_file; {the terminal as an input file}
@!term_out:alpha_file; {the terminal as an output file}
@y
is considered an output file the file is |term_out|.  In C, these
files will be defined as ``stdin'' and ``stdout,'' respectively.
@^system dependencies@>

@d term_in==stdin {the terminal as an input file}
@d term_out==stdout {the terminal as an output file}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.33] don't need to open terminal files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ Here is how to open the terminal files
in \ph. The `\.{/I}' switch suppresses the first |get|.
@^system dependencies@>

@d t_open_in==reset(term_in,'TTY:','/O/I') {open the terminal for text input}
@d t_open_out==rewrite(term_out,'TTY:','/O') {open the terminal for text output}
@y
@ Here is how to open the terminal files.  |t_open_out| does nothing.
|t_open_in|, on the other hand, does the work of "rescanning", or getting
any command line arguments the user has provided.
It's coded in C externally.
@^system dependencies@>

@d t_open_out == {output already open for text output}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.34] flushing output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
these operations can be specified in \ph:
@^system dependencies@>

@d update_terminal == break(term_out) {empty the terminal output buffer}
@d clear_terminal == break_in(term_in,true) {clear the terminal input buffer}
@d wake_up_terminal == do_nothing {cancel the user's cancellation of output}
@y
these operations can be specified with {\mc UNIX}.  |update_terminal|
does an fflush, since that's easy.  |wake_up_terminal| and |clear_terminal|
are specified in external C routines, if desired.  We call fflush()
termflush() here, and fix it with a macro in C, so we can cast it to (void)
to keep lint quiet.
@^system dependencies@>

@z
@x remove |input_ln| details
@<Report overflow of the input buffer, and abort@>=
if format_ident=0 then
  begin write_ln(term_out,'Buffer size exceeded!'); goto final_end;
@.Buffer size exceeded@>
  end
else begin cur_input.loc_field:=first; cur_input.limit_field:=last-1;
  overflow("buffer size",buf_size);
@:TeX capacity exceeded buffer size}{\quad buffer size@>
  end
@y

Remove |input_ln| details.
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.37] rescanning the command line 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The following program does the required initialization
without retrieving a possible command line.
It should be clear how to modify this routine to deal with command lines,
if the system permits them.
@^system dependencies@>

@p function init_terminal:boolean; {gets the terminal input started}
@y
@ The following program does the required initialization.
Iff anything has been specified on the command line, then |t_open_in|
will return with |last > first|.
@^system dependencies@>
\pTeXchg{Ignoring semitic spaces same as latin's.}

@p function init_terminal:boolean; {gets the terminal input started}
@z
@x
loop@+begin wake_up_terminal; write(term_out,'**'); update_terminal;
@.**@>
  if not input_ln(term_in,true) then {this shouldn't happen}
    begin write_ln(term_out);
    write(term_out,'! End of file on the terminal... why?');
@.End of file on the terminal@>
    init_terminal:=false; return;
    end;
  loc:=first;
  while (loc<last)and(buffer[loc]=" ") do incr(loc);
@y first check command line
if last > first then 
  begin loc := first;
  while (loc < last) and (buffer[loc]=' ') do incr(loc);
  if loc < last then 
    begin init_terminal := true;
    goto exit;
    end;
  end;
loop@+begin wake_up_terminal; 
   if format_ident=0 then bwterm('**')
   else begin print_nl("**"); end;
update_terminal;
@.**@>
 left_input := true;
  if not input_ln(term_in,true) then {this shouldn't happen}
    begin write_ln(term_out);
    write(term_out, '! End of file on the terminal... why?');
@.End of file on the terminal@>
    init_terminal:=false;
    return;
    end;
  loc:=first;
  while (loc<last)and((buffer[loc]=" ")or(buffer[loc]=" ")) do incr(loc);
@z
@x
  write_ln(term_out,'Please type the name of your input file.');
@y
  print_nl("Please type the name of your input file.");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.49] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    49
@<Character |k| cannot be printed@>=
  (k<" ")or(k>"~")
@y    49===================
\pTeXchg{In raw printing all characters are printable.}
@<Character |k| cannot be printed@>=
  ((not rawprtchr) and ((k<" ")or(k=127)))
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [4.51] a_open_in of pool file needs path specifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
name_of_file:=pool_name; {we needn't set |name_length|}
if a_open_in(pool_file) then
@y
vstrcpy(name_of_file+1, pool_name); {this is how you copy strings in C}
if a_open_in(pool_file,pool_path_spec) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [4.51,52,53] make TEX.POOL lowercase in messages; fix reading it
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else  bad_pool('! I can''t read TEX.POOL.')
@y
else begin
   {Like |bad_pool|, but must not close file if we never opened it}
   wake_up_terminal; write_ln(term_out, '! I can''t read tex.pool.');
   get_strings_started:= false; return;
end
@z
@x
begin if eof(pool_file) then bad_pool('! TEX.POOL has no check sum.');
@.TEX.POOL has no check sum@>
read(pool_file,m,n); {read two digits of string length}
@y
begin if eof(pool_file) then bad_pool('! tex.pool has no check sum.');
@.TEX.POOL has no check sum@>
rread(pool_file,m); rread(pool_file,n); {read two digits of string length}
@z
@x
    bad_pool('! TEX.POOL line doesn''t begin with two digits.');
@y
    bad_pool('! tex.pool line doesn''t begin with two digits.');
@z
@x
    begin if eoln(pool_file) then m:=' '@+else read(pool_file,m);
@y
    begin if eoln(pool_file) then m:=' '@+else rread(pool_file,m);
@z
@x
  bad_pool('! TEX.POOL check sum doesn''t have nine digits.');
@y
  bad_pool('! tex.pool check sum doesn''t have nine digits.');
@z
@x
  incr(k); read(pool_file,n);
@y
  incr(k); rread(pool_file,n);
@z
@x
done: if a<>@$ then bad_pool('! TEX.POOL doesn''t match; TANGLE me again.');
@y
done: if a<>@$ then bad_pool('! tex.pool doesn''t match; tangle me again.');
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.56]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d wterm(#)==write(term_out,#)
@d wterm_ln(#)==write_ln(term_out,#)
@d wterm_cr==write_ln(term_out)
@d wlog(#)==write(log_file,#)
@d wlog_ln(#)==write_ln(log_file,#)
@d wlog_cr==write_ln(log_file)
@y
\pTeXchg{We use external C function to write bidirectional strings.
   To prevent ad hoc misusing original macros, we rename some of them.}
@d bwterm_ln(#)==write_ln(term_out,#)
@d bwlog_ln(#)==write_ln(log_file,#)
@d bwlog(#)==write(log_file,#)
@d bwterm==b_w_term                         {external C definition}
@d cwlog==c_w_log                           {external C definition}
@d cwlog_cr==c_w_log_cr                     {external C definition}
@d cwterm==c_w_term                         {external C definition}
@d cwterm_cr==c_w_term_cr                   {external C definition}
@d cwfile==c_w_file                         {external C definition}
@d cwfile_cr==c_w_file_cr                   {external C definition}

@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.57]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |print_ln|
@<Basic print...@>=
procedure print_ln; {prints an end-of-line}
begin case selector of
term_and_log: begin wterm_cr; wlog_cr;
  term_offset:=0; file_offset:=0;
  end;
log_only: begin wlog_cr; file_offset:=0;
  end;
term_only: begin wterm_cr; term_offset:=0;
  end;
no_print,pseudo,new_string: do_nothing;
othercases write_ln(write_file[selector])
@y
\pTeXnewprt
@<Basic print...@>=
procedure print_ln; {prints an end-of-line}
begin @<Reset directinal variables@>;
case selector of
term_and_log: begin cwterm_cr; cwlog_cr; end;
log_only:  cwlog_cr;
term_only: cwterm_cr;
no_print,pseudo,new_string: do_nothing;
othercases cwfile_cr;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.58]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |print_char|
@<Basic printing...@>=
procedure print_char(@!s:ASCII_code); {prints a single character}
label exit;
begin if @<Character |s| is the current new-line character@> then
 if selector<pseudo then
  begin print_ln; return;
  end;
case selector of
term_and_log: begin wterm(xchr[s]); wlog(xchr[s]);
  incr(term_offset); incr(file_offset);
  if term_offset=max_print_line then
    begin wterm_cr; term_offset:=0;
    end;
  if file_offset=max_print_line then
    begin wlog_cr; file_offset:=0;
    end;
  end;
log_only: begin wlog(xchr[s]); incr(file_offset);
  if file_offset=max_print_line then print_ln;
  end;
term_only: begin wterm(xchr[s]); incr(term_offset);
@y
\pTeXchg{To print strings in approperiate language we use |strequiv| macro.}
@<Basic printing...@>=
@<Define |get_streq|@>@/
@#
procedure print_char(@!s:ASCII_code); {prints a single character}
label exit;
begin if @<Character |s| is the current new-line character@> then
 if selector<pseudo then
  begin print_ln; return;
  end;
 strequiv(s); @<Reset directinal variables@>;
case selector of
term_and_log: begin cwterm(s); cwlog(s);
  if term_offset=max_print_line then cwterm_cr; 
  if file_offset=max_print_line then cwlog_cr;
  end;
log_only: begin cwlog(s); 
  if file_offset=max_print_line then print_ln;
  end;
term_only: begin cwterm(s);
@z
@x
othercases write(write_file[selector],xchr[s])
@y
othercases cwfile (s)
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.59]  printing string variant in latin or semitic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Basic print...@>=
procedure print(@!s:integer); {prints string |s|}
label exit;
var j:pool_pointer; {current character code position}
@!nl:integer; {new-line character to restore}
@y
\pTeXnewprt
@<Basic print...@>=
@<Define |pprint|@>@/
@#
procedure print(@!s:integer); {prints string |s|}
label exit;
var nl:integer; {new-line character to restore}
@z
@x
      begin print_char(s); return; {internal strings are not expanded}
@y
      begin pushprinteq; print_char(s); popprinteq;
            return; {internal strings are not expanded}
@z
@x
    j:=str_start[s];
    while j<str_start[s+1] do
      begin print_char(so(str_pool[j])); incr(j);
      end;
@y
    pprint(s);
@z
@x
j:=str_start[s];
while j<str_start[s+1] do
  begin print_char(so(str_pool[j])); incr(j);
  end;
exit:end;
@y
pprint(s);
exit:end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.60] slow_print
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Basic print...@>=
@y
\pTeXnewprt
@<Basic print...@>=
@z
@x
else begin j:=str_start[s];
@y
else begin strequiv(s); j:=str_start[s];
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.61] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Initialize the output...@>=
wterm(banner);
if format_ident=0 then wterm_ln(' (no format preloaded)')
else  begin slow_print(format_ident); print_ln;
  end;
update_terminal;
@y
\pTeXchg{We use external function |initonterm| to show \pTeX{} cover page.}
@<Initialize the output...@>=
initonterm;
virtex_ident:=format_ident;
if format_ident<>0 then 
     begin print(banner);
       if format_ident <> initex then print_ln;
       slow_print(format_ident); print_ln;
       update_terminal;
    end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.62] print_nl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Basic print...@>=
@y
\pTeXnewprt
@<Basic print...@>=
@z
@x
print(s);
end;
@y
strequiv(s); print(s);
end;
@#
@<Define |LorRprt| procedures@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.64] print_the_digs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ An array of digits in the range |0..15| is printed by |print_the_digs|.
@y
@ An array of digits in the range |0..15| is printed by |print_the_digs|.
\pTeXchg{Print numbers in current language.}
@z
@x
begin while k>0 do
  begin decr(k);
  if dig[k]<10 then print_char("0"+dig[k])
  else print_char("A"-10+dig[k]);
  end;
@y
var @!i:eight_bits; {a loop index}
begin @<Print the |dig| array in approperiate direction@>;@/ 
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.67] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_two(@!n:integer); {prints two least significant digits}
begin n:=abs(n) mod 100; print_char("0"+(n div 10));
print_char("0"+(n mod 10));
end;
@y
\pTeXchg{Print numbers in current language.}
@p procedure print_two(@!n:integer); {prints two least significant digits}
begin n:=abs(n) mod 100; 
@<Print two digit in approperiate direction@>;@/
end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.68] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    68
@d print_ASCII == print
@y    68===================
\pTeXchg{|semichrout| will be defined as a C macro.}
@d print_ASCII == print
@d print_s_ASCII(#) == print(semichrout(#))
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.69] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_roman_int(@!n:integer);
@y
\pTeXchg{Roman numbers should be printed in latin language.}
@p procedure print_roman_int(@!n:integer);
@z
@x
begin j:=str_start["m2d5c2l5x2v5i"]; v:=1000;
@y
begin pushprinteq; j:=str_start["m2d5c2l5x2v5i"]; v:=1000;
@z
@x
  if n<=0 then return; {nonpositive input produces no output}
@y
  if n<=0 then begin popprinteq; return; end;
@z
@x
exit:end;
@y
exit: popprinteq; end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.70]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_current_string; {prints a yet-unmade string}
@y
\pTeXnewprt
@p procedure print_current_string; {prints a yet-unmade string}
@z
@x
begin j:=str_start[str_ptr];
while j<pool_ptr do
  begin print_char(so(str_pool[j])); incr(j);
  end;
@y
begin pushprinteq; j:=str_start[str_ptr];
while j<pool_ptr do
  begin print_char(so(str_pool[j])); incr(j);
  end;
popprinteq;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.81] Eliminate nonlocal goto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C cannot do non-local goto's.
% Plus, it's nicer just to do an exit with the appropriate status code
% under Unix.  We call it "uexit" because there's a WEB symbol called
% "exit" already.  We use a C macro to change uexit() back to exit().
% RESET_KEYBORD 
@x
@<Error hand...@>=
procedure jump_out;
begin goto end_of_TEX;
end;
@y
@d do_final_end==begin
   update_terminal;
   @= resetkeyboard@>;
   ready_already:=0;
   if (history <> spotless) and (history <> warning_issued) then
       uexit(1)
   else
       uexit(0);
   end
@<Error hand...@>=
procedure jump_out;
begin
close_files_and_terminate;
do_final_end;
end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.83] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Get user's advice...@>=
@y
@ 
\pTeXchg{Don't use uppercase for semitic characters.}
@<Get user's advice...@>=
@z
@x
  if c>="a" then c:=c+"A"-"a"; {convert to uppercase}
@y
  if not issemichr(c) then if c>="a" then c:=c+"A"-"a"; {convert to uppercase}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.84] switch-to-editor option
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Interpret code |c| and |return| if done@>=
case c of
"0","1","2","3","4","5","6","7","8","9": if deletions_allowed then
  @<Delete \(c)|c-"0"| tokens and |goto continue|@>;
@t\4\4@>@;@+@!debug "D": begin debug_help; goto continue;@+end;@+gubed@/
"E": if base_ptr>0 then
  begin print_nl("You want to edit file ");
@.You want to edit file x@>
  slow_print(input_stack[base_ptr].name_field);
  print(" at line "); print_int(line);
  interaction:=scroll_mode; jump_out;
  end;
"H": @<Print the help information and |goto continue|@>;
"I":@<Introduce new material from the terminal and |return|@>;
"Q","R","S":@<Change the interaction level and |return|@>;
"X":begin interaction:=scroll_mode; jump_out;
@y
\pTeXusechr
@d edit_file==input_stack[base_ptr]

@<Interpret code |c| and |return| if done@>=
case c of
"0","1","2","3","4","5","6","7","8","9",
"۰","۱","۲","۳","۴","۵","۶","۷","۸","۹": if deletions_allowed then
  @<Delete \(c)|c-"0"| tokens and |goto continue|@>;
@t\4\4@>@;@+@!debug "D","غ‍","غ": begin debug_help;goto continue;@+end;@+gubed@/
"E","و": if base_ptr>0 then
  begin edit_name_length := 0;
    if edit_file.area_field = (edit_file.name_field - 1) then
       begin edit_name_start:=str_start[edit_file.area_field];
             edit_name_length:=length (edit_file.area_field);
       end
    else edit_name_start:=str_start[edit_file.name_field];
    edit_name_length:=edit_name_length + length (edit_file.name_field);
    if edit_file.ext_field = (edit_file.name_field + 1) then
       edit_name_length:=edit_name_length + length (edit_file.ext_field);
    edit_line:=line;
    edit_direction:=direction_stack[in_open];
    jump_out;
  end;
"H","ک‍","ک": @<Print the help information and |goto continue|@>;
"I","د":@<Introduce new material from the terminal and |return|@>;
"Q","R","S","س‍","س","ت‍","ت","ن‍","ن":
  @<Change the interaction level and |return|@>;
"X","خ‍","خ":begin interaction:=scroll_mode; jump_out;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.86] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Change the interaction...@>=
begin error_count:=0; interaction:=batch_mode+c-"Q";
print("OK, entering ");
case c of
"Q":begin print_esc("batchmode"); decr(selector);
  end;
"R":print_esc("nonstopmode");
"S":print_esc("scrollmode");
end; {there are no other cases}
print("..."); print_ln; update_terminal; return;
end
@y
\pTeXusechr
@<Change the interaction...@>=
begin error_count:=0; 
if not issemichr(c) then interaction:=batch_mode+c-"Q"
else case c of
  "س‍","س": interaction:=batch_mode;
  "ت‍","ت": interaction:=nonstop_mode;
  "ن‍","ن": interaction:=scroll_mode;
  endcases; {there are no other cases}
print("OK, entering ");
case c of
"Q","س‍","س":begin print_esc("batchmode"); decr(selector);
  end;
"R","ت‍","ت":print_esc("nonstopmode");
"S","ن‍","ن":print_esc("scrollmode");
end; {there are no other cases}
LorRprt("..."," می‌شویم..."); print_ln; update_terminal;
help_ptr:=0;
return;
end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.87] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Introduce new material...@>=
@y
\pTeXchg{Insert language dependent space.}
@<Introduce new material...@>=
@z
@x
  begin loc:=first+1; buffer[first]:=" ";
@y
  begin loc:=first+1; L_or_S(buffer[first]:=" ")(buffer[first]:=" ");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.88] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Delete \(c)|c-"0"| tokens...@>=
@y
\pTeXusechr
@<Delete \(c)|c-"0"| tokens...@>=
@z
@x
if (last>first+1) and (buffer[first+1]>="0")and(buffer[first+1]<="9") then
@y
if (c>="۰")and(c<="۹") then c:=c-"۰"+"0"; if (last>first+1) and 
(buffer[first+1]>="۰")and(buffer[first+1]<="۹") then
  buffer[first+1]:=buffer[first+1]-"۰"+"0";
if (last>first+1) and (buffer[first+1]>="0")and(buffer[first+1]<="9") then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.98] Rename interrup variable to interruptoccured
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d check_interrupt==begin if interrupt<>0 then pause_for_instructions;
@y
@d interrupt==interruptoccured
@d check_interrupt==begin if interrupt<>0 then pause_for_instructions;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [7.103] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_scaled(@!s:scaled); {prints scaled real, rounded to five
@y
\pTeXchg{Print numbers in approperiate language. Here we rename
  |print_scaled| for latin printing, and redefine the procedure to
  check language befor printing.}
@p procedure print_scaled_Lft (@!s:scaled); {prints scaled real, rounded to five
@z
@x
end;
@y
end;
@#
@<Redefine |print_scaled|@>@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [7.109] Handle definition of glue_ratio in an include file as a typedef
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Types...@>=
@!glue_ratio=real; {one-word representation of a glue expansion factor}
@y
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [8.110] Make it easy to build a bigger TeX.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d min_quarterword=0 {smallest allowable value in a |quarterword|}
@d max_quarterword=255 {largest allowable value in a |quarterword|}
@d min_halfword==0 {smallest allowable value in a |halfword|}
@d max_halfword==65535 {largest allowable value in a |halfword|}
@y
@d min_quarterword=0 {smallest allowable value in a |quarterword|}
@d max_quarterword=1023 {largest allowable value in a |quarterword|}
@d min_halfword==0 {smallest allowable value in a |halfword|}
@d max_halfword==@"3FFFFFFF {largest allowable value in a |halfword|}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [8.112] Efficiency!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@^inner loop@>@^system dependencies@>

@d qi(#)==#+min_quarterword
  {to put an |eight_bits| item into a quarterword}
@d qo(#)==#-min_quarterword
  {to take an |eight_bits| item out of a quarterword}
@d hi(#)==#+min_halfword
  {to put a sixteen-bit item into a halfword}
@d ho(#)==#-min_halfword
  {to take a sixteen-bit item from a halfword}
@y
So they have been simplified here in the obvious way.
@^inner loop@>@^system dependencies@>

@d qi(#)==# {to put an |eight_bits| item into a quarterword}
@d qo(#)==# {to take an |eight_bits| item from a quarterword}
@d hi(#)==# {to put a sixteen-bit item into a halfword}
@d ho(#)==# {to take a sixteen-bit item from a halfword}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [8.113] Hand-code some more things in C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!two_halves = packed record@;@/
  @!rh:halfword;
  case two_choices of
  1: (@!lh:halfword);
  2: (@!b0:quarterword; @!b1:quarterword);
  end;
@!four_quarters = packed record@;@/
  @!b0:quarterword;
  @!b1:quarterword;
  @!b2:quarterword;
  @!b3:quarterword;
  end;
@!memory_word = record@;@/
  case four_choices of
  1: (@!int:integer);
  2: (@!gr:glue_ratio);
  3: (@!hh:two_halves);
  4: (@!qqqq:four_quarters);
  end;
@!word_file = file of memory_word;
@y
@=#include "texmemory.h";@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [9.116] Change mem to zmem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We do this so that we can define mem to be a register pointer to the
% memory array for speed.
@x
@!mem : array[mem_min..mem_max] of memory_word; {the big dynamic storage area}
@y
@!zmem : array[mem_min..mem_max] of memory_word; {the big dynamic storage area}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [9.127] Fix casting problem in C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% There are several of these.  They come from the rules C uses for
% comparing signed and unsigned quantities.  Just doing the comparison
% can result in incorrect evaluation wrt the way Pascal would do it.
@x
if r>p+1 then @<Allocate from the top of node |p| and |goto found|@>;
@y
if r>toint(p+1) then @<Allocate from the top of node |p| and |goto found|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [10.149] Adding |mid_rule| feature
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
in a subscript.
@y
in a subscript.

\pTeXchg{We also use glue node for adding |mid_rule| and introduce two more 
subtypes.
The |leader_ptr| in this cases hold font number of |mid_rule| for computing
 |rule_ht| in accordance with character fonts.}
@z
@x    149
@d x_leaders=102 {|subtype| for expanded leaders}
@y    149===================
@d x_leaders=102 {|subtype| for expanded leaders}

@d active_mid_rule=103 {|subtype| for active |mid_rule| leaders}
@d suprsd_mid_rule=104 {|subtype| for supressed |mid_rule| leaders}

@d activate_mid_rule(#)==begin
     if (mrule_init>=0) and (subtype(#)>active_mid_rule) then 
        subtype(#):=active_mid_rule; end
@d suppress_mid_rule(#)==begin
  if subtype(#)=active_mid_rule then subtype(#):=suprsd_mid_rule; end
@d is_mrule(#)==(subtype(#)>=active_mid_rule)
@d is_not_mrule(#)==(subtype(#)<active_mid_rule)
@d is_active_rule(#)==(subtype(#)=active_mid_rule)
@d is_supressed(#)==(subtype(#)=suprsd_mid_rule)
@d is_not_supressed(#)==(subtype(#)<>suprsd_mid_rule)
@z
@x
@d unset_node=13 {|type| for an unset node}
@d glue_stretch(#)==mem[#+glue_offset].sc {total stretch in an unset node}
@d glue_shrink==shift_amount {total shrink in an unset node}
@d span_count==subtype {indicates the number of spanned columns}
@y
\pTeXchg{But we use |span_count| (as |subtype| of a box node) with special 
values for 
left or right justification. (|right_justify| and |left_justify|).}

@d unset_node=13 {|type| for an unset node}
@d glue_stretch(#)==mem[#+glue_offset].sc {total stretch in an unset node}
@d glue_shrink==shift_amount {total shrink in an unset node}
@d span_count==subtype {indicates the number of spanned columns}
@d right_justify=max_quarterword
@d left_justify=max_quarterword-1

@p @<Declare functions needed for special kinds of nodes@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [11.165] fix the word "free" so that it doesn't conflict with the C routine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
are debugging.)
@y
are debugging.)

@d free==free_arr
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [11.168] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Check single-word...@>=
@y
@ 
\pTeXchg{Print language alternates message.}
@<Check single-word...@>=
@z
@x    
    print_int(q); goto done1;
@y
    print_int(q); or_S(print(" به هم ریخته است")); goto done1;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [11.169] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Check variable-size...@>=
@y
@ 
\pTeXchg{Print language alternates message.}
@<Check variable-size...@>=
@z
@x    
  print_int(q); goto done2;
@y
  print_int(q); or_S(print(" به هم ریخته است"));  goto done2; 
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.174]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure short_display(@!p:integer); {prints highlights of list |p|}
@y
\pTeXchg{Check semitic  (twin) fonts.}
@p procedure short_display(@!p:integer); {prints highlights of list |p|}
@z
@x
      begin if font(p)<>font_in_short_display then
        begin if (font(p)<font_base)or(font(p)>font_max) then
@y
      begin if (font(p)<>font_in_short_display) and
               (font(p)<>fontwin[font_in_short_display]) then
        begin if (font(p)>font_max) then
@z
@x
      print_ASCII(qo(character(p)));
@y
      @<Print |p| according to |fontwin[font(p)]|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.175] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Print a short indication of the contents of node |p|@>=
@y
@ 
\pTeXchg{Check |mid_rule| glues.}
@<Print a short indication of the contents of node |p|@>=
@z
@x
glue_node: if glue_ptr(p)<>zero_glue then print_char(" ");
@y
glue_node: if is_active_rule(p) then print_char("ـ‍") 
           else if is_not_supressed(p) then 
                   if glue_ptr(p)<>zero_glue then print_char(" ");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.176] Eliminate some unsigned comparisons to zero (continued)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_font_and_char(@!p:integer); {prints |char_node| data}
@y
\pTeXchg{Check semitic  (twin) fonts.}
@p procedure print_font_and_char(@!p:integer); {prints |char_node| data}
@z
@x
else  begin if (font(p)<font_base)or(font(p)>font_max) then print_char("*")
@y
else  begin if (font(p)>font_max) then print_char("*")
@z
@x
  print_char(" "); print_ASCII(qo(character(p)));
@y
  print_char(" "); @<Print |p| according to |fontwin[font(p)]|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.180] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d node_list_display(#)==
  begin append_char("."); show_node_list(#); flush_char;
@y
\pTeXaltstr
@d node_list_display(#)==
  begin L_or_S(append_char("."))(append_char("."));
        show_node_list(#); flush_char;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.184] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display box |p|@>=
begin if type(p)=hlist_node then print_esc("h")
else if type(p)=vlist_node then print_esc("v")
else print_esc("unset");
print("box("); print_scaled(height(p)); print_char("+");
print_scaled(depth(p)); print(")x"); print_scaled(width(p));
if type(p)=unset_node then
  @<Display special fields of the unset node |p|@>
else  begin @<Display the value of |glue_set(p)|@>;
  if shift_amount(p)<>0 then
    begin print(", shifted "); print_scaled(shift_amount(p));
    end;
  end;
@y
@ 
\pTeXaltstr
@<Display box |p|@>=
begin if latin_speech then
  begin if type(p)=hlist_node then print_esc("h")
        else if type(p)=vlist_node then print_esc("v") else print_esc("unset");
        print("box(");
  end
else begin print_esc("کادر");
        if type(p)=hlist_node then print_char("ا")
        else if type(p)=vlist_node then print_char("و") else print("نامعین");
        print_char("(");
     end;
print_scaled(height(p)); print_char("+");
print_scaled(depth(p)); print(")x"); print_scaled(width(p));
if type(p)=unset_node then @<Display special fields of the unset node |p|@>
else  begin @<Display the value of |glue_set(p)|@>;
  if shift_amount(p)<>0 then
      begin print(", shifted "); print_scaled(shift_amount(p)); end;
  if subtype(p)=right_justify then  print(", right justified")
  else if subtype(p)=left_justify then  print(", left justified");
  end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.185]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display special fields of the unset node |p|@>=
begin if span_count(p)<>min_quarterword then
  begin print(" ("); print_int(qo(span_count(p))+1);
  print(" columns)");
  end;
if glue_stretch(p)<>0 then
  begin print(", stretch "); print_glue(glue_stretch(p),glue_order(p),0);
  end;
if glue_shrink(p)<>0 then
  begin print(", shrink "); print_glue(glue_shrink(p),glue_sign(p),0);
  end;
end
@y
@ 
\pTeXchg{Using |glue_order| values |> 3| for left or right justifications.}
@<Display special fields of the unset node |p|@>=
begin if span_count(p)<left_justify then
  if span_count(p)<>min_quarterword then
    begin print(" ("); print_int(qo(span_count(p))+1); print(" columns)"); end;
if glue_stretch(p)<>0 then
  begin print(", stretch "); print_glue(glue_stretch(p),glue_order(p) mod 4,0); 
    {in case |glue_order|(p)>4}
  end;
if glue_shrink(p)<>0 then
  begin print(", shrink "); print_glue(glue_shrink(p),glue_sign(p),0); end;
if (subtype(p)=right_justify) or (glue_order(p)>7) then
      print(", right justified")
else if (subtype(p)=left_justify) or (glue_order(p)>3) then
  print(", left justified");
end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.187] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display rule |p|@>=
@y
@ 
\pTeXchg{Check |rule| direction.}
@<Display rule |p|@>=
@z
@x
print_rule_dimen(depth(p)); print(")x"); print_rule_dimen(width(p));
@y
print_rule_dimen(depth(p)); print(")x"); print_rule_dimen(width(p));
if subtype(p)=right_justify then  print(", right justified")
else if subtype(p)=left_justify then print(", left justified");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.190] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display leaders |p|@>=
@y
@ 
\pTeXaltstr
@<Display leaders |p|@>=
@z
@x
begin print_esc("");
if subtype(p)=c_leaders then print_char("c")
else if subtype(p)=x_leaders then print_char("x");
print("leaders "); print_spec(glue_ptr(p),0);
node_list_display(leader_ptr(p)); {recursive call}
@y
begin if is_not_mrule(p) then
        begin L_or_S(print_esc(""))(print_esc("نشانگر"));
          if subtype(p)=c_leaders then LorRprt("c","مرکزی ")
          else if subtype(p)=x_leaders then LorRprt("x","گسترشی ");
          L_or(print("leaders "));
        end
     else begin or_S(print_esc("میانخط "));
            if is_supressed(p) then print("supressed ")
            else print("active ");
            L_or(print_esc("midrule "));
          end;
if is_not_supressed(p) then print_spec(glue_ptr(p),0);
if is_not_mrule(p) then node_list_display(leader_ptr(p)); {recursive call}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.192] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display math node |p|@>=
@y
@ 
\pTeXaltstr
@<Display math node |p|@>=
@z
@x
begin print_esc("math");
if subtype(p)=before then print("on")
else print("off");
@y
begin L_or(print_esc("math"));
if subtype(p)=before then print("on") else print("off");
or_S(print_esc("ریاضی"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.195] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Display discretionary |p|@>=
@y
\pTeXaltstr
@<Display discretionary |p|@>=
@z
@x
append_char("|"); show_node_list(post_break(p)); flush_char; {recursive call}
@y
L_or_S(append_char("|"))(append_char("|"));
show_node_list(post_break(p)); flush_char; {recursive call}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [13.202]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure flush_node_list(@!p:pointer); {erase list of nodes starting at |p|}
@y
\pTeXchg{Check |mid_rule| glues.}
@p procedure flush_node_list(@!p:pointer); {erase list of nodes starting at |p|}
@z
@x    202
    glue_node: begin fast_delete_glue_ref(glue_ptr(p));
      if leader_ptr(p)<>null then flush_node_list(leader_ptr(p));
      end;
@y    202===================
    glue_node: begin fast_delete_glue_ref(glue_ptr(p));
      if is_mrule(p) then leader_ptr(p):=null
      else if leader_ptr(p)<>null then flush_node_list(leader_ptr(p));
      end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [14.206]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Case statement to copy...@>=
@y
@ 
\pTeXchg{Check |mid_rule| glues.}
@<Case statement to copy...@>=
@z
@x    206
  glue_ptr(r):=glue_ptr(p); leader_ptr(r):=copy_node_list(leader_ptr(p));
  end;
@y    206===================
  glue_ptr(r):=glue_ptr(p);
  if is_not_mrule(p) then leader_ptr(r):=copy_node_list(leader_ptr(p))
  else leader_ptr(r):=leader_ptr(p);
  end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [15.208]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d char_num=16 {character specified numerically ( \.{\\char} )}
@y
\pTeXchg{We have such commands namely |semi_given| and |LR|.}
@d char_num=16 {character specified numerically ( \.{\\char} )}
@z
@x    208
@d max_non_prefixed_command=70 {largest command code that can't be \.{\\global}}
@y    208===================
@d semi_given=71 {character code defined by \.{\\semichardef}}
@d LR=72 {text direction (\.{\\beginL},\.{\\beginR},\.{\\endL},\.{\\endR})}
@d max_non_prefixed_command=72 {largest command code that can't be \.{\\global}}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [15.209]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    209
@d toks_register=71 {token list register ( \.{\\toks} )}
@d assign_toks=72 {special token list ( \.{\\output}, \.{\\everypar}, etc.~)}
@d assign_int=73 {user-defined integer ( \.{\\tolerance}, \.{\\day}, etc.~)}
@d assign_dimen=74 {user-defined length ( \.{\\hsize}, etc.~)}
@d assign_glue=75 {user-defined glue ( \.{\\baselineskip}, etc.~)}
@d assign_mu_glue=76 {user-defined muglue ( \.{\\thinmuskip}, etc.~)}
@d assign_font_dimen=77 {user-defined font dimension ( \.{\\fontdimen} )}
@d assign_font_int=78 {user-defined font integer ( \.{\\hyphenchar},
  \.{\\skewchar} )}
@d set_aux=79 {specify state info ( \.{\\spacefactor}, \.{\\prevdepth} )}
@d set_prev_graf=80 {specify state info ( \.{\\prevgraf} )}
@d set_page_dimen=81 {specify state info ( \.{\\pagegoal}, etc.~)}
@d set_page_int=82 {specify state info ( \.{\\deadcycles},
  \.{\\insertpenalties} )}
@d set_box_dimen=83 {change dimension of box ( \.{\\wd}, \.{\\ht}, \.{\\dp} )}
@d set_shape=84 {specify fancy paragraph shape ( \.{\\parshape} )}
@d def_code=85 {define a character code ( \.{\\catcode}, etc.~)}
@d def_family=86 {declare math fonts ( \.{\\textfont}, etc.~)}
@d set_font=87 {set current font ( font identifiers )}
@d def_font=88 {define a font file ( \.{\\font} )}
@d register=89 {internal register ( \.{\\count}, \.{\\dimen}, etc.~)}
@d max_internal=89 {the largest code that can follow \.{\\the}}
@d advance=90 {advance a register or parameter ( \.{\\advance} )}
@d multiply=91 {multiply a register or parameter ( \.{\\multiply} )}
@d divide=92 {divide a register or parameter ( \.{\\divide} )}
@d prefix=93 {qualify a definition ( \.{\\global}, \.{\\long}, \.{\\outer} )}
@d let=94 {assign a command code ( \.{\\let}, \.{\\futurelet} )}
@d shorthand_def=95 {code definition ( \.{\\chardef}, \.{\\countdef}, etc.~)}
@d read_to_cs=96 {read into a control sequence ( \.{\\read} )}
@d def=97 {macro definition ( \.{\\def}, \.{\\gdef}, \.{\\xdef}, \.{\\edef} )}
@d set_box=98 {set a box ( \.{\\setbox} )}
@d hyph_data=99 {hyphenation data ( \.{\\hyphenation}, \.{\\patterns} )}
@d set_interaction=100 {define level of interaction ( \.{\\batchmode}, etc.~)}
@d max_command=100 {the largest command code seen at |big_switch|}
@y    209===================
\pTeXchg{We also introduce new such commands namely, |LR_setting|, 
  |LR_getting|, |switch_font|, |let_name|, |eq_name|.}
@d toks_register=73 {token list register ( \.{\\toks} )}
@d assign_toks=74 {special token list ( \.{\\output}, \.{\\everypar}, etc.~)}
@d assign_int=75 {user-defined integer ( \.{\\tolerance}, \.{\\day}, etc.~)}
@d assign_dimen=76 {user-defined length ( \.{\\hsize}, etc.~)}
@d assign_glue=77 {user-defined glue ( \.{\\baselineskip}, etc.~)}
@d assign_mu_glue=78 {user-defined muglue ( \.{\\thinmuskip}, etc.~)}
@d assign_font_dimen=79 {user-defined font dimension ( \.{\\fontdimen} )}
@d assign_font_int=80 {user-defined font integer ( \.{\\hyphenchar},
  \.{\\skewchar} )}
@d set_aux=81 {specify state info ( \.{\\spacefactor}, \.{\\prevdepth} )}
@d set_prev_graf=82 {specify state info ( \.{\\prevgraf} )}
@d set_page_dimen=83 {specify state info ( \.{\\pagegoal}, etc.~)}
@d set_page_int=84 {specify state info ( \.{\\deadcycles},
  \.{\\insertpenalties} )}
@d set_box_dimen=85 {change dimension of box ( \.{\\wd}, \.{\\ht}, \.{\\dp} )}
@d set_shape=86 {specify fancy paragraph shape ( \.{\\parshape} )}
@d def_code=87 {define a character code ( \.{\\catcode}, etc.~)}
@d def_family=88 {declare math fonts ( \.{\\textfont}, etc.~)}
@d set_font=89 {set current latin or semitic font ( font identifiers )}
@d def_font=90 {define a latin or semitic font file ( \.{\\font},
  \.{\\semifont}, \.{\\activefont} )}
@d register=91 {internal register ( \.{\\count}, \.{\\dimen}, etc.~)}
@d max_internal=91 {the largest code that can follow \.{\\the}}
@d advance=92 {advance a register or parameter ( \.{\\advance} )}
@d multiply=93 {multiply a register or parameter ( \.{\\multiply} )}
@d divide=94 {divide a register or parameter ( \.{\\divide} )}
@d prefix=95 {qualify a definition ( \.{\\global}, \.{\\long}, \.{\\outer} )}
@d let=96 {assign a command code ( \.{\\let}, \.{\\futurelet} )}
@d shorthand_def=97 {code definition ( \.{\\chardef}, \.{\\countdef}, etc.~)}
@d read_to_cs=98 {read into a control sequence ( \.{\\read} )}
@d def=99 {macro definition ( \.{\\def}, \.{\\gdef}, \.{\\xdef}, \.{\\edef} )}
@d set_box=100 {set a box ( \.{\\setbox} )}
@d hyph_data=101 {hyphenation data ( \.{\\hyphenation}, \.{\\patterns} )}
@d set_interaction=102 {define level of interaction ( \.{\\batchmode}, etc.~)}
@d LR_setting=103 {define directional things (e.g. \.{\\LtoR}, $\ldots$ )}
@d LR_getting=104 {get directional things (e.g. \.{\\curdirection}, 
                                        $\ldots$ )}
@d switch_font=105 {set current semitic font to base or twin font}
@d let_name=106 {set command names equal for semitic or latin mode}
@d eq_name=107 {command name for equivalent control sequence}
@d max_command=107 {the largest command code seen at |big_switch|}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [16.211]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d vmode=1 {vertical mode}
@d hmode=vmode+max_command+1 {horizontal mode}
@d mmode=hmode+max_command+1 {math mode}

@p procedure print_mode(@!m:integer); {prints the mode represented by |m|}
begin if m>0 then
@y
\pTeXaltstr
@d vmode=1 {vertical mode}
@d hmode=vmode+max_command+1 {horizontal mode}
@d mmode=hmode+max_command+1 {math mode}

@p procedure print_mode(@!m:integer); {prints the mode represented by |m|}
begin or_S(print("حالت "));
if m>0 then
@z
@x
print(" mode");
@y
L_or(print(" mode"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [16.212]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
be pushed onto |nest| if necessary.
@y
be pushed onto |nest| if necessary.
\pTeXchg{We should add a field to deal with properly nested |LR| states.}
@z
@x    212
  @!head_field,@!tail_field: pointer;
  @!pg_field,@!ml_field: integer;@+
  @!aux_field: memory_word;
@y    212==================
  @!head_field,@!tail_field: pointer;
  @!pg_field,@!ml_field: integer;@+
  @!aux_field,@!LR_aux_field: memory_word;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [16.216]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    216
@p procedure push_nest; {enter a new semantic level, save the old}
@y
\pTeXchg{Initialize |stkLR| in each nesting level.}
@p @<|LR| nest routines@>
@#
procedure push_nest; {enter a new semantic level, save the old}
@z
@x
incr(nest_ptr); head:=get_avail; tail:=head; prev_graf:=0; mode_line:=line;
@y    216==================
incr(nest_ptr); head:=get_avail; tail:=head; prev_graf:=0; mode_line:=line;
stkLR:=get_avail; stkLR_cmd:= 0; stkLR_src := 0;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [16.217]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    217
@p procedure pop_nest; {leave a semantic level, re-enter the old}
begin free_avail(head); decr(nest_ptr); cur_list:=nest[nest_ptr];
end;
@y    217==================
\pTeXchg{We should flush |stkLR| at end of each nesting level.}
@p procedure pop_nest; {leave a semantic level, re-enter the old}
var p:pointer;
begin free_avail(head); if in_auto_LR then pop_stkLR;
while stkLR<>null do begin p:=stkLR; stkLR:=link(p); free_avail(p); end;
decr(nest_ptr); cur_list:=nest[nest_ptr];
end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [16.218] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure@?print_totals; forward;@t\2@>
@y
\pTeXaltstr
@p procedure@?print_totals; forward;@t\2@>
@z
@x
  print_nl("### "); print_mode(m);
  print(" entered at line "); print_int(abs(nest[p].ml_field));
@y
  print_nl("### ");
  if latin_speech then begin print_mode(m);
         print(" entered at line "); print_int(abs(nest[p].ml_field)); end
  else begin print("در سطر "); print_int(abs(nest[p].ml_field));
         print(" وارد "); print_mode(m); print(" شدیم"); end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [16.219] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Show the auxiliary...@>=
@y
@ 
\pTeXaltstr
@<Show the auxiliary...@>=
@z
@x
    if nest[p].pg_field<>1 then print_char("s");
@y
    if nest[p].pg_field<>1 then L_or(print_char("s"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.222]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
(since they are used in error recovery).
@y
(since they are used in error recovery).
\pTeXchg{We also have new permanent control sequences.}
@z
@x    222
@d frozen_null_font=frozen_control_sequence+10
@y    222====================
@d frozen_bgn_L=frozen_control_sequence+10 {permanent `\.{\\beginL}'}
@d frozen_bgn_R=frozen_control_sequence+11 {permanent `\.{\\beginR}'}
@d frozen_end_L=frozen_control_sequence+12 {permanent `\.{\\endL}'}
@d frozen_end_R=frozen_control_sequence+13 {permanent `\.{\\endR}'}
@d frozen_null_font=frozen_control_sequence+14
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.223]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Show equivalent |n|, in region 1 or 2@>=
@y
\pTeXaltstr
@<Show equivalent |n|, in region 1 or 2@>=
@z
@x Adding eqchar
  begin print_char(":"); show_token_list(link(equiv(n)),null,32);
@y
  begin print_char(":"); set_eq_show(eq_type(n));
  show_token_list(link(equiv(n)),null,32); eq_show:=false;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.224]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
parameters have larger numbers than the others.
@y
parameters have larger numbers than the others.
\pTeXchg{We also have more new parameters.}
@z
@x  224
@d par_fill_skip_code=14 {glue on last line of paragraph}
@d thin_mu_skip_code=15 {thin space in math formula}
@d med_mu_skip_code=16 {medium space in math formula}
@d thick_mu_skip_code=17 {thick space in math formula}
@d glue_pars=18 {total number of glue parameters}
@y    224====================
@d semi_space_skip_code=14 {glue between semitic words (if not |zero_glue|)}
@d semi_xspace_skip_code=15 {glue after semitic sentences (if not |zero_glue|)}
@d mid_rule_code=16 {rule between semitic characters, if appropriate}
@d par_fill_skip_code=17 {glue on last line of paragraph}
@d thin_mu_skip_code=18 {thin space in math formula}
@d med_mu_skip_code=19 {medium space in math formula}
@d thick_mu_skip_code=20 {thick space in math formula}
@d glue_pars=21 {total number of glue parameters}
@z
@x    224
@d xspace_skip==glue_par(xspace_skip_code)
@y    224====================
@d xspace_skip==glue_par(xspace_skip_code)
@d semi_space_skip==glue_par(semi_space_skip_code)
@d semi_xspace_skip==glue_par(semi_xspace_skip_code)
@d mid_rule==glue_par(mid_rule_code)
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.225] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
xspace_skip_code: print_esc("xspaceskip");
@y
xspace_skip_code: print_esc("xspaceskip");
semi_space_skip_code: print_esc("semispaceskip");
semi_xspace_skip_code: print_esc("semixspaceskip");
mid_rule_code: print_esc("midrulespec");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.230]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
registers.
@y
registers.
\pTeXchg{We also have more new token parameters and new table.}
@z
@x
@d err_help_loc=local_base+9 {points to token list for \.{\\errhelp}}
@d toks_base=local_base+10 {table of 256 token list registers}
@y
@d every_semi_par_loc=local_base+9
  {points to token list for \.{\\everysemipar}}
@d every_semi_math_loc=local_base+10 
  {points to token list for \.{\\everysemimath}}
@d every_semi_display_loc=local_base+11 
  {points to token list for \.{\\everysemidisplay}}
@d after_every_display_loc=local_base+12
  {points to token list for \.{\\everycr}}
@d err_help_loc=local_base+13 {points to token list for \.{\\errhelp}}
@d toks_base=local_base+14 {table of 256 token list registers}
@z
@x
@d cur_font_loc=box_base+256 {internal font number outside math mode}
@d math_font_base=cur_font_loc+1 {table of 48 math font numbers}
@y
@d cur_LRswch_loc=box_base+256 {automatic |bi_directional| typesetting switch}
@d cur_speech_loc=cur_LRswch_loc+1 {current speech switch}
@d cur_direction_loc=cur_speech_loc+1 {current direction switch}
@d vbox_justify_loc=cur_direction_loc+1 {current vbox justufication}
@d cur_font_loc=vbox_justify_loc+1 {internal font number outside math mode}
@d cur_latif_loc=cur_font_loc+1 {internal latin font number }
@d cur_semif_loc=cur_latif_loc+1 {internal semitic font number }
@d math_font_base=cur_semif_loc+1 {table of 48 math font numbers}
@z
@x
@d math_code_base=sf_code_base+256 {table of 256 math mode mappings}
@d int_base=math_code_base+256 {beginning of region 5}
@y
@d locate_code_base=sf_code_base+256  {table of 256 |locate_code| mappings}
@d acc_factor_base=locate_code_base+256 {table of 256 |acc_factor| mappings}
@d eq_char_base=acc_factor_base+256 {table of 256 |eq_chars|}
@d eq_charif_base=eq_char_base+256 {table of 256 |eq_charsif|}
@d join_attrib_base=eq_charif_base+256 {table of 256 |join_attributes|}
@d math_code_base=join_attrib_base+256 {table of 256 math mode mappings}
@d int_base=math_code_base+256 {beginning of region 5}
@z
@x
@d math_code(#)==equiv(math_code_base+#)
@y
@#
@d math_code(#)==equiv(math_code_base+#)
@d every_semi_par==equiv(every_semi_par_loc)
@d every_semi_math==equiv(every_semi_math_loc)
@d after_every_display==equiv(after_every_display_loc)
@d every_semi_display==equiv(every_semi_display_loc)
@d cur_LR_swch==equiv(cur_LRswch_loc)
@d cur_speech==equiv(cur_speech_loc)
@d cur_direction==equiv(cur_direction_loc)
@d vbox_justify==equiv(vbox_justify_loc)
@d R_to_L_vbox==(vbox_justify=R_to_L)
@d L_to_R_vbox==(vbox_justify=L_to_R)
@d cur_latif==equiv(cur_latif_loc)
@d cur_semif==equiv(cur_semif_loc)
@d locate_code(#)==equiv(locate_code_base+semichrout(#))
@d acc_factor(#)==equiv(acc_factor_base+semichrout(#))
@d join_attrib(#)==equiv(join_attrib_base+semichrout(#))
@d eqch(#)==equiv(eq_char_base+#)
@d eqif(#)==equiv(eq_charif_base+#)
@d is_semi_font(#)==(fontwin[#]<>null_font)
@d is_latin_font(#)==(fontwin[#]=null_font)
@d is_twin_font(#)==(fontwin[#]=twin_tag)
@d has_twin_font(#)==(fontwin[#]<twin_tag) {|fontwin[#]>null_font| checked }
@d is_dbl_font(#)==(fontwin[#]=dbl_tag)
@z
@x
@!@:err_help_}{\.{\\errhelp} primitive@>
@y
@!@:err_help_}{\.{\\errhelp} primitive@>
primitive("everysemipar",assign_toks,every_semi_par_loc);
@!@:every_semi_par_}{\.{\\everysemipar} primitive@>
primitive("everysemimath",assign_toks,every_semi_math_loc);
@!@:every_semi_math_}{\.{\\everysemimath} primitive@>
primitive("aftereverydisplay",assign_toks,after_every_display_loc);
@!@:after_every_display_}{\.{\\aftereverydisplay} primitive@>
primitive("everysemidisplay",assign_toks,every_semi_display_loc);
@!@:every_semi_display_}{\.{\\everysemidisplay} primitive@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.231]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |print_cmd_chr|
  othercases print_esc("errhelp")
@y 
  every_semi_par_loc: print_esc("everysemipar");
  every_semi_math_loc: print_esc("everysemimath");
  every_semi_display_loc: print_esc("everysemidisplay");
  after_every_display_loc: print_esc("aftereverydisplay");
  othercases print_esc("errhelp")
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.233] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else if n<cur_font_loc then
@y
else if n<cur_LRswch_loc then
@z
@x
else if n<cat_code_base then @<Show the font identifier in |eqtb[n]|@>
@y
@<Test bidirectionals@>@/
else if n<cat_code_base then @<Show the font identifier in |eqtb[n]|@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.234] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin if n=cur_font_loc then print("current font")
@y
begin if n=cur_font_loc then print("current active font")
else if n=cur_latif_loc then print("current latin font")
else if n=cur_semif_loc then print("current semitic font")
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.235] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  else  begin print_esc("sfcode"); print_int(n-sf_code_base);
@y
  else if n<locate_code_base then
    begin print_esc("sfcode"); print_int(n-sf_code_base);
    end
  else if n<acc_factor_base then
    begin print_esc("lcode"); print_int(n-locate_code_base);
    end
  else if n<eq_char_base then
    begin print_esc("accfactor"); print_int(n-acc_factor_base);
    end
  else if n<eq_charif_base then
    begin print_esc("eqchar"); print_int(n-eq_char_base);
    end
  else if n<join_attrib_base then
    begin print_esc("eqcharif"); print_int(n-eq_charif_base);
    end
  else begin print_esc("jattrib"); print_int(n-join_attrib_base);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.236] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
that will be defined later.
@y
that will be defined later.
\pTeXchg{We also have new int parameters and also want to increase |count| 
table.}
@z
@x
@d int_pars=55 {total number of integer parameters}
@d count_base=int_base+int_pars {256 user \.{\\count} registers}
@d del_code_base=count_base+256 {256 delimiter code mappings}
@y
@d dig_fam_code=55 {current semitic family}
@d vbox_justification_code=56
@d mrule_init_code=57
@d semi_day_code=58 {current day of the month}
@d semi_month_code=59 {current month of the year}
@d semi_year_code=60 {current year of Hejri Shamsi}
@d LR_showswch_code=61
@d LR_miscswch_code=62
@d int_pars=63 {total number of integer parameters}
@d count_base=int_base+int_pars {512 user \.{\\count} registers}
@d del_code_base=count_base+512 {256 delimiter code mappings}
@z
@x
@d year==int_par(year_code)
@y
@d year==int_par(year_code)
@d semi_day==int_par(semi_day_code)
@d semi_month==int_par(semi_month_code)
@d semi_year==int_par(semi_year_code)
@d dig_fam==int_par(dig_fam_code)
@d vbox_justification==int_par(vbox_justification_code)
@d R_to_L_par==(vbox_justification > 0)
@d L_to_R_par==(vbox_justification < 0)
@d R_to_L_line==(R_to_L_vbox and (vbox_justification > 1))
@d LR_showswch==int_par(LR_showswch_code)
@d eqchring==(chrbit(LR_showswch,1))
@d eqnaming==(chrbit(LR_showswch,2))
@d eqshwing==(chrbit(LR_showswch,4))
@d eqwrting==(chrbit(LR_showswch,8))
@d eqspcial==(chrbit(LR_showswch,16))
@d rawprtchr==(chrbit(LR_showswch,32))
@d set_eq_show(#)==eq_show:=eqshwing and(#<=long_outer_call)
@d LR_miscswch==int_par(LR_miscswch_code)
@d addRcmds==(chrbit(LR_miscswch,1))
@d addLcmdh==(chrbit(LR_miscswch,2))
@d addRcmdh==(chrbit(LR_miscswch,4))
@d addLcmds==(chrbit(LR_miscswch,8))
@d ignrautoLR==(chrbit(LR_miscswch,16))
@d mrule_init==int_par(mrule_init_code)
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.237] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
othercases print("[unknown integer parameter!]")
@y
semi_day_code:print_esc("semiday");
semi_month_code:print_esc("semimonth");
semi_year_code:print_esc("semiyear");
dig_fam_code:print_esc("semifam");
vbox_justification_code:print_esc("vboxjustification");
LR_showswch_code:print_esc("LRshowswitch");
LR_miscswch_code:print_esc("LRmiscswitch");
mrule_init_code:print_esc("midruleinit");
othercases print("[unknown integer parameter!]")
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.241] fix_date_and_time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
Since standard \PASCAL\ cannot provide such information, something special
is needed. The program here simply specifies July 4, 1776, at noon; but
users probably want a better approximation to the truth.

@p procedure fix_date_and_time;
begin time:=12*60; {minutes since midnight}
day:=4; {fourth day of the month}
month:=7; {seventh month of the year}
year:=1776; {Anno Domini}
end;
@y
("dateandtime") in turn is a C macro, which calls |get_date_and_time|, passing
it the addresses of the day, month, etc., so they can be set by the
routine.  |get_date_and_time| also sets up interrupt catching if that
is conditionally compiled in the C code.

@d fix_date_and_time==date_and_time(time,day,month,year,
          semi_day,semi_month,semi_year)
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.243] alternate escape_char
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Set variable |c| to the current escape character@>=c:=escape_char
@y
@ 
\pTeXaltstr
@<Set variable |c| to the current escape character@>=c:=escape_char;
   if ((c >= 0) and (c < 256) and semitic_speech) then c:=alt_str[c]
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.247] fix_date_and_time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
here, and the 256 \.{\\dimen} registers.
@y
here, and the 256 \.{\\dimen} registers.
\pTeXchg{We also want to increase |dimen| table.}
@z
@x
  {table of 256 user-defined \.{\\dimen} registers}
@d eqtb_size=scaled_base+255 {largest subscript of |eqtb|}
@y
  {table of 512 user-defined \.{\\dimen} registers}
@d eqtb_size=scaled_base+511 {largest subscript of |eqtb|}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.253] Change eqtb to zeqtb
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!eqtb:array[active_base..eqtb_size] of memory_word;
@y
@!zeqtb:array[active_base..eqtb_size] of memory_word;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [18.265]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Put each of \TeX's primitives into the hash table@>=
primitive(" ",ex_space,0);@/
@!@:Single-character primitives /}{\quad\.{\\\ }@>
@y
\pTeXchg{We should redefine some primitives namely |ex_space|, |accent|, 
   |char_num|, |def_font| and |halign|, as two language dependent ones.}
@<Put each of \TeX's primitives into the hash table@>=
@z
@x
primitive("accent",accent,0);@/
@!@:accent_}{\.{\\accent} primitive@>
@y
@z
@x
primitive("char",char_num,0);@/
@!@:char_}{\.{\\char} primitive@>
@y
@z
@x
primitive("font",def_font,0);@/
@!@:font_}{\.{\\font} primitive@>
@y
@z
@x
primitive("halign",halign,0);@/
@!@:halign_}{\.{\\halign} primitive@>
@y
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [18.266] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%SEMIACCENT
@x
@<Cases of |print_cmd_chr|...@>=
accent: print_esc("accent");
@y
\pTeXchg{We should also redefine those |print_cmd_chr| cases.}
@<Cases of |print_cmd_chr|...@>=
@z
@x
char_num: print_esc("char");
@y
@z
@x
def_font: print_esc("font");
@y
@z
@x
ex_space: print_esc(" ");
@y
@z
@x
halign: print_esc("halign");
@y
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [20.289]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x
@d space_token=@'5040 {$2^8\cdot|spacer|+|" "|$}
 @y
@d space_token=@'5040 {$2^8\cdot|spacer|+|" "|$}
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [20.294]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
|out_param| commands.
@y
|out_param| commands.
\pTeXaltstr
@z
@x Adding eqchar
  letter,other_char: print(c);
mac_param: begin print(c); print(c);
  end;
out_param: begin print(match_chr);
@y
  letter,other_char: if eq_show and(eqch(c)<>0)then print_char(c)else print(c);
mac_param: if eq_show and eqch(c)<>0 then begin print_char(c);print_char(c);end
           else begin print(c); print(c); end;
out_param: begin if eq_show and eqch(match_chr)<>null then
                    print_char (match_chr) else print(match_chr);
@z
@x Adding eqchar
match: begin match_chr:=c; print(c); incr(n); print_char(n);
@y
match: begin match_chr:=c; 
        if eq_show and eqch(c)<>0 then print_char(c) else print(c); 
        incr(n); print_char(n);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [20.296]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_meaning;
@y
\pTeXaltstr
@p procedure print_meaning;
@z
@x Adding eqchar
  begin print_char(":"); print_ln; token_show(cur_chr);
@y
  begin print_char(":"); print_ln;
      set_eq_show(cur_cmd); token_show(cur_chr); eq_show:=false;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [21.298] Add variable t for variation of LR commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d chr_cmd(#)==begin print(#); print_ASCII(chr_code);
@y
\pTeXaltstr
@d semi_space_token=@'5240 {$2^8\cdot|spacer|+|" "|$}
@d chr_cmd(#)==begin print(#); print_ASCII(chr_code);
@z
@x |print_cmd_chr|
begin case cmd of
@y
var @!t:integer;
begin case cmd of
@z
@x
spacer: chr_cmd("blank space ");
letter: chr_cmd("the letter ");
other_char: chr_cmd("the character ");
@y
spacer: if is_semi_chr(chr_code) then chr_cmd("semitic blank space ")
        else chr_cmd("latin blank space ");
letter: if is_semi_chr(chr_code) then chr_cmd("the semitic letter ")
        else chr_cmd("the latin letter ");
other_char: if is_semi_chr(chr_code) then chr_cmd("the semitic character ")
            else chr_cmd("the latin character ");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [21.300] Saving file area and extension to save pool space at end of file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  @!start_field,@!loc_field, @!limit_field, @!name_field: halfword;
@y
  @!start_field,@!loc_field, @!limit_field, @!name_field,
  @!ext_field,@!area_field:  halfword;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [21.302] Saving file area and extension to save pool space at end of file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d name==cur_input.name_field {name of the current file}
@y
@d name==cur_input.name_field {name of the current file}
@d ext==cur_input.ext_field {extension of the current file}
@d area==cur_input.area_field {area of the current file}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.306] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Declare the procedure called |runaway|@>=
@y
\pTeXaltstr
@<Declare the procedure called |runaway|@>=
@z
@x
  begin print_nl("Runaway ");
@y
  begin L_or_S(print_nl("Runaway "))(print_nl(""));
@z
@x
  print_char("?");print_ln; show_token_list(link(p),null,error_line-10);
@y
  or_S(print(" بی‌انتها"));
  print_char("?");print_ln; show_token_list(link(p),null,error_line-10);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.307] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d token_list=0 {|state| code when scanning a token list}
@y
\pTeXchg{We should define new token list parameters.}
@d token_list=0 {|state| code when scanning a token list}
@z
@x
@d mark_text=14 {|token_type| code for \.{\\topmark}, etc.}
@d write_text=15 {|token_type| code for \.{\\write}}
@y
@#
@d every_semi_par_text=14 {|token_type| code for \.{\\everysemipar}}
@d every_semi_math_text=15 {|token_type| code for \.{\\everysemimath}}
@d after_every_display_text=16 {|token_type| code for \.{\\aftereverydisplay}}
@d every_semi_display_text=17 {|token_type| code for \.{\\everysemidisplay}}
@#
@d mark_text=18 {|token_type| code for \.{\\topmark}, etc.}
@d write_text=19 {|token_type| code for \.{\\write}}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.308] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
othercases print_nl("?") {this should never happen}
@y
every_semi_par_text: print_nl("<everysemipar> ");
every_semi_math_text: print_nl("<everysemimath> ");
after_every_display_text: print_nl("<aftereverydisplay> ");
every_semi_display_text: print_nl("<everysemidisplay> ");
othercases print_nl("?") {this should never happen}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.317] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Print two lines using the tricky pseudoprinted information@>=
@y
\pTeXnewprt
@<Print two lines using the tricky pseudoprinted information@>=
@z
@x
for q:=p to first_count-1 do print_char(trick_buf[q mod error_line]);
@y
pushprinteq;
for q:=p to first_count-1 do print_char(trick_buf[q mod error_line]);
popprinteq;
@z
@x
for q:=first_count to p-1 do print_char(trick_buf[q mod error_line]);
@y
pushprinteq;
for q:=first_count to p-1 do print_char(trick_buf[q mod error_line]);
popprinteq;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.319] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Pseudoprint the token list@>=
@y
@ 
\pTeXaltstr
@<Pseudoprint the token list@>=
@z
@x Adding eqchar
if token_type<macro then show_token_list(start,loc,100000)
else show_token_list(link(start),loc,100000) {avoid reference count}
@y
set_eq_show(token_type);
if token_type<macro then show_token_list(start,loc,100000)
else show_token_list(link(start),loc,100000); {avoid reference count}
eq_show:=false
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.329] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x Remove file name from string pool 
@p procedure end_file_reading;
begin first:=start; line:=line_stack[index];
if name>17 then a_close(cur_file); {forget it}
pop_input; decr(in_open);
end;
@y
@p procedure end_file_reading;
begin first:=start; line:=line_stack[index];
if name>17 then a_close(cur_file); {forget it}
if (name=str_ptr-1)or(ext=str_ptr-1)then{we can conserve string pool space now}
  begin flush_string; if (name=str_ptr-1) then flush_string;
     if (area=str_ptr-1) then flush_string; end;pop_input; decr(in_open); end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [23.331] use a different for loop index, local to tex_body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
first:=buf_size; repeat buffer[first]:=0; decr(first); until first=0;
@y
bufindx:=buf_size; repeat buffer[bufindx]:=0; decr(bufindx); until bufindx=0;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.332]  Getting the next token
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
|end_line_char| has |ignore| as its catcode.)
@y
|end_line_char| has |ignore| as its catcode.)

@p @<Bidirectional procedures@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.336] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure check_outer_validity;
@y
\pTeXaltstr
@p procedure check_outer_validity;
@z
@x
  else  begin print_err("Incomplete "); print_cmd_chr(if_test,cur_if);
@.Incomplete \\if...@>
    print("; all text was ignored after line "); print_int(skip_line);
@y
  else  begin LorRprt_err("Incomplete ",""); print_cmd_chr(if_test,cur_if);
@.Incomplete \\if...@>
  print("; all text was ignored after line ");  print_int(skip_line); 
  or_S(print(" نادیده گرفته شد"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.337]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Back up an outer control sequence so that it can be reread@>=
@y
\pTeXusechr
@<Back up an outer control sequence so that it can be reread@>=
@z
@x
  cur_cmd:=spacer; cur_chr:=" "; {replace it by a space}
@y
  set_directed_space;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.338] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Tell the user what has run away...@>=
begin runaway; {print a definition, argument, or preamble}
@y
@ 
\pTeXaltstr
@<Tell the user what has run away...@>=
begin runaway; {print a definition, argument, or preamble}
L_or(
@z
@x
  end;
print(" while scanning ");
@y
  end); L_or_S(print(" while scanning "))(print_err("هنگامی که در حال "));
@z
@x
print(" of "); sprint_cs(warning_index);
@y
print(" of "); sprint_cs(warning_index); or_S(print("» بودم "));
or_S(if cur_cs=0 then print("File ended")
     else  begin cur_cs:=0; print("Forbidden control sequence found"); end);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.341] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d switch=25 {a label in |get_next|}
@y
\pTeXeqnm
@d switch=25 {a label in |get_next|}
@z
@x Adding |eq_name| command
begin restart: cur_cs:=0;
@y
begin restart: cur_cs:=0; cur_eq:=0;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.348]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Finish line, emit a space@>=
@y
\pTeXusechr
@<Finish line, emit a space@>=
@z
@x
begin loc:=limit+1; cur_cmd:=spacer; cur_chr:=" ";
@y
begin loc:=limit+1; set_directed_space;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.349]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Enter |skip_blanks| state, emit a space@>=
@y
\pTeXaltstr
@<Enter |skip_blanks| state, emit a space@>=
@z
@x
begin state:=skip_blanks; cur_chr:=" ";
@y
begin state:=skip_blanks;
if issemichr(cur_chr) then cur_chr:=" " else cur_chr:=" ";
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.356] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Scan ahead in the buffer...@>=
@y
@ 
\pTeXeqnm
@<Scan ahead in the buffer...@>=
@z
@x Adding |eq_name| command
  begin cur_cs:=id_lookup(loc,k-loc); loc:=k; goto found;
@y
  begin cur_cs:=id_lookup(loc,k-loc); loc:=k;
        @<Check |eq_name| command@>; goto found;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [22.357] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Input from token list, |goto restart| if end of list or
@y
\pTeXeqnm
@<Input from token list, |goto restart| if end of list or
@z
@x Adding |eq_name| command
    begin cur_cs:=t-cs_token_flag;
@y
    begin cur_cs:=t-cs_token_flag; @<Check |eq_name| command@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.365] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure get_token; {sets |cur_cmd|, |cur_chr|, |cur_tok|}
@y
\pTeXeqnm
@p procedure get_token; {sets |cur_cmd|, |cur_chr|, |cur_tok|}
@z
@x
if cur_cs=0 then cur_tok:=(cur_cmd*@'400)+cur_chr
else cur_tok:=cs_token_flag+cur_cs;
@y
@<Set |cur_tok| and |eq_tok|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.374] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Look up the characters of list |r| in the hash table...@>=
@y
@ 
\pTeXeqnm
@<Look up the characters of list |r| in the hash table...@>=
@z
@x
if j>first+1 then
  begin no_new_control_sequence:=false; cur_cs:=id_lookup(first,j-first);
@y
cur_eq:=0;
if j>first+1 then
  begin no_new_control_sequence:=false; cur_cs:=id_lookup(first,j-first);
        @<Check |eq_name| command@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.376]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Put each...@>=
primitive("input",input,0);@/
@!@:input_}{\.{\\input} primitive@>
primitive("endinput",input,1);@/
@!@:end_input_}{\.{\\endinput} primitive@>
@y
\pTeXchg{We should redefine |input| primitive as two language dependent ones.}
@<Put each...@>=
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.377]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
input: if chr_code=0 then print_esc("input")@+else print_esc("endinput");
@y
input: if chr_code = L_to_R then print_esc("input")@+
  else if chr_code=R_to_L then print_esc("inputR")@+ else print_esc("endinput");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.378]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Initiate or terminate input...@>=
if cur_chr>0 then force_eof:=true
else if name_in_progress then insert_relax
else start_input
@y
@ 
\pTeXchg{Deal with |left_or_right| files.}
@<Initiate or terminate input...@>=
if cur_chr=0 then force_eof:=true
else if name_in_progress then insert_relax
else begin if in_open<>max_in_open then direction_stack[in_open+1]:=cur_chr;
  start_input;  end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.380] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure get_x_token; {sets |cur_cmd|, |cur_chr|, |cur_tok|,
@y
\pTeXeqnm
@p procedure get_x_token; {sets |cur_cmd|, |cur_chr|, |cur_tok|,
@z
@x
done: if cur_cs=0 then cur_tok:=(cur_cmd*@'400)+cur_chr
else cur_tok:=cs_token_flag+cur_cs;
@y
done: @<Set |cur_tok| and |eq_tok|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.381] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure x_token; {|get_x_token| without the initial |get_next|}
@y
\pTeXeqnm
@p procedure x_token; {|get_x_token| without the initial |get_next|}
@z
@x Adding eqcharif
if cur_cs=0 then cur_tok:=(cur_cmd*@'400)+cur_chr
else cur_tok:=cs_token_flag+cur_cs;
@y
@<Set |cur_tok| and |eq_tok|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.392]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Scan a parameter until its delimiter string has been found; or, ...@>=
@y
\pTeXeqnm
@<Scan a parameter until its delimiter string has been found; or, ...@>=
@z
@x
if cur_tok=info(r) then
@y
if (cur_tok=info(r))or (eq_tok=info(r)) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.393]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Store the current token, but |goto continue| if it is...@>=
@y
@ 
\pTeXusechr
@<Store the current token, but |goto continue| if it is...@>=
@z
@x
begin if cur_tok=space_token then
@y
begin if (cur_tok=space_token)or(cur_tok=semi_space_token) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.401]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Show the text of the macro being expanded@>=
@y
@ 
\pTeXaltstr
@<Show the text of the macro being expanded@>=
@z
@x
token_show(ref_count); end_diagnostic(false);
@y
eq_show:=eqshwing; token_show(ref_count); eq_show:=0; end_diagnostic(false);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.405] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure scan_optional_equals;
@y
\pTeXeqnm
@p procedure scan_optional_equals;
@z
@x
if cur_tok<>other_token+"=" then back_input;
@y
if not cur_eq_other("=") then back_input;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.407] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  changing scan_keyword
@p function scan_keyword(@!s:str_number):boolean; {look for a given string}
@y
\pTeXchg{Introduce semitic keywords. 
Here we use original function as |scan_one_keyword| and redefine
function |scan_keyword| to check alternate strings.
}
@p function scan_one_keyword(@!s:str_number):boolean; {look for a given string}
@z
@x
    scan_keyword:=false; return;
@y
    scan_one_keyword:=false; return;
@z
@x
flush_list(link(backup_head)); scan_keyword:=true;
exit:end;
@y
flush_list(link(backup_head)); scan_one_keyword:=true;
exit:end;
@#
function scan_keyword(@!s:str_number):boolean; {look for a given string}
var a:str_number; {tail of the backup list}
b:boolean;
begin if semitic_speech and (alt_str[s]>0) then begin a:=s; s:=alt_str[s]; end
      else a:=abs(alt_str[s]);
  b:=scan_one_keyword (s); if (not b) and (a<>s) then b:=scan_one_keyword(a);
  scan_keyword:=b;
end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.413] scan_something_internal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
|cur_cmd<min_internal| or |cur_cmd>max_internal|.
@y
|cur_cmd<min_internal| or |cur_cmd>max_internal|.
\pTeXchg{Introduce new internal parameters.}
@z
@x
@p procedure scan_something_internal(@!level:small_number;@!negative:boolean);
@y
@p @<Declare |find_last|@>@/
@#
procedure scan_something_internal(@!level:small_number;@!negative:boolean);
@z
@x  defining new variables
@!p:0..nest_size; {index into |nest|}
@y
@!p:0..nest_size; {index into |nest|}
@!t:halfword;
@!q:pointer;
@z
@x  adding semi_given
char_given,math_given: scanned_result(cur_chr)(int_val);
@y
semi_given,char_given,math_given: scanned_result(cur_chr)(int_val);
LR_getting: scanned_result(equiv(m))(int_val);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.424] scan_something_internal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Fetch an item in the current node...@>=
@y
\pTeXchg{We should retrieve last internal parameters without 
         counting |LR_node|'s.}
@<Fetch an item in the current node...@>=
@z
@x  observing mid_rule and auto_LR nodes
    case cur_chr of
    int_val: if type(tail)=penalty_node then cur_val:=penalty(tail);
    dimen_val: if type(tail)=kern_node then cur_val:=width(tail);
    glue_val: if type(tail)=glue_node then
      begin cur_val:=glue_ptr(tail);
      if subtype(tail)=mu_glue then cur_val_level:=mu_val;
      end;
    end {there are no other cases}
@y
  begin t:=null;
    case cur_chr of
    int_val: t:=penalty_node;
    dimen_val: t:=kern_node;
    glue_val: t:=glue_node;
    end; {there are no other cases}
    if t<>null then begin q:=find_last (t);
      if (q<>null) then begin
        if (link(q)<>null) and (type(link(q))=t) then q:=link(q);
        case cur_chr of
        int_val: cur_val:=penalty(q);
        dimen_val: cur_val:=width(q);
        glue_val: begin cur_val:=glue_ptr(q);
         if subtype(q)=mu_glue then cur_val_level:=mu_val;
        end;
        end; {there are no other cases}
      end;
    end;
  end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.426]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Fetch a font integer@>=
@y
@ 
\pTeXchg{We have new font integer.}
@<Fetch a font integer@>=
@z
@x
else scanned_result(skew_char[cur_val])(int_val);
@y
else if m=1 then scanned_result(skew_char[cur_val])(int_val)
  else if m=2 then
          if (level=tok_val)and(cur_val<=font_max) then
               scanned_result(font_id_base+fontwin[cur_val])(ident_val)
          else scanned_result(fontwin[cur_val])(int_val)
       else @<Complain that \.{\\the} can't do this; give zero result@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.427] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Fetch a register@>=
begin scan_eight_bit_int;
@y
@ 
\pTeXchg{Our |count| and |dimen| tables are increased.}
@<Fetch a register@>=
begin if (m <> int_val) and (m <> dimen_val) then scan_eight_bit_int
      else scan_nine_bit_int;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.428] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Complain that \.{\\the} can't do this; give zero result@>=
@y
@ 
\pTeXaltstr
@<Complain that \.{\\the} can't do this; give zero result@>=
@z
@x
print("' after "); print_esc("the");
@y
print("' after "); print_esc("the"); or_S(print(" بکار ببرید"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.436]  misplaced \pTeX message is due to  WEB system!!!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Declare procedures that scan restricted classes of integers@>=
@y
@ 
\pTeXchg{We use |mathchar| range @'100001 throught @'110000 for
   semitic numbers in math mode.}
@<Declare procedures that scan restricted classes of integers@>=
@z
@x
if (cur_val<0)or(cur_val>@'77777) then
@y
if (cur_val<0)or(cur_val>@'110000)or(cur_val=@'100000) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.437] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if (cur_val<0)or(cur_val>@'777777777) then
@y
if (cur_val<0)or(cur_val>@'1100000000)or(cur_val=@'1000000000) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.440] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure scan_int; {sets |cur_val| to an integer}
@y
\pTeXusechr
@d semi_octal_token=other_token+"ُ"
@d semi_alpha_token=other_token+"`"
@d semi_point_token=other_token+"٫" {semitic decimal point}
@p procedure scan_int; {sets |cur_val| to an integer}
@z
@x
if cur_tok=alpha_token then @<Scan an alphabetic character code into |cur_val|@>
@y
if (cur_tok=alpha_token) or (cur_tok=semi_alpha_token) then
    @<Scan an alphabetic character code into |cur_val|@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.441] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Get the next non-blank non-sign token...@>=
negative:=false;
repeat @<Get the next non-blank non-call token@>;
if cur_tok=other_token+"-" then
  begin negative := not negative; cur_tok:=other_token+"+";
  end;
until cur_tok<>other_token+"+"
@y
@ 
\pTeXusechr
@<Get the next non-blank non-sign token...@>=
negative:=chk_sign_and_semitic
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.444] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Scan a numeric constant@>=
@y
@ 
\pTeXusechr
@<Scan a numeric constant@>=
@z
@x
if cur_tok=octal_token then
@y
if (cur_tok=octal_token) or (cur_tok=semi_octal_token) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.445] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @d infinity==@'17777777777 {the largest positive value that \TeX\ knows}
@y
@ 
\pTeXusechr
@d infinity==@'17777777777 {the largest positive value that \TeX\ knows}
@d semi_zero_token=other_token+"۰" {zero, the smallest digit}
@z
@x
    (cur_tok<=zero_token+9) then d:=cur_tok-zero_token
  else if radix=16 then
@y
    (cur_tok<=zero_token+9) then d:=cur_tok-zero_token
   else if (cur_tok<semi_zero_token+radix)and(cur_tok>=semi_zero_token)and
    (cur_tok<=semi_zero_token+9) then d:=cur_tok-semi_zero_token
  else if radix=16 then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [26.453]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Scan units and set |cur_val| to $x\cdot(|cur_val|+f/2^{16})$...@>=
@y
\pTeXusechr
@<Scan units and set |cur_val| to $x\cdot(|cur_val|+f/2^{16})$...@>=
@z
@x  "true" after units
attach_fraction: if cur_val>=@'40000 then arith_error:=true
@y
attach_fraction: if scan_keyword("true") then
         @<Adjust \(f)for the magnification ratio@>;
  if cur_val>=@'40000 then arith_error:=true
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.464] Building the token list
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function str_toks(@!b:pool_pointer):pointer;
@y
\pTeXusechr
@p function str_toks(@!b:pool_pointer):pointer;
@z
@x    464
  if t=" " then t:=space_token
@y    464===================
  if t=" " then t:=space_token else if t=" " then t:=semi_space_token
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.468]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d number_code=0 {command code for \.{\\number}}
@d roman_numeral_code=1 {command code for \.{\\romannumeral}}
@d string_code=2 {command code for \.{\\string}}
@d meaning_code=3 {command code for \.{\\meaning}}
@d font_name_code=4 {command code for \.{\\fontname}}
@d job_name_code=5 {command code for \.{\\jobname}}
@y
\pTeXchg{Define new commands.}
@d number_code=0 {command code for \.{\\number}}
@d thousands_code=1 {command code for \.{\\thousands}}
@d millions_code=2 {command code for \.{\\millions}}
@d billions_code=3 {command code for \.{\\billions}}
@d roman_numeral_code=4 {command code for \.{\\romannumeral}}
@d string_code=5 {command code for \.{\\string}}
@d meaning_code=6 {command code for \.{\\meaning}}
@d font_name_code=7 {command code for \.{\\fontname}}
@d job_name_code=8 {command code for \.{\\jobname}}
@z
@x
@!@:job_name_}{\.{\\jobname} primitive@>
@y
@!@:job_name_}{\.{\\jobname} primitive@>
@#
primitive("thousands",convert,thousands_code);@/
@!@:thousands_}{\.{\\thousands} primitive@>
primitive("millions",convert,millions_code);@/
@!@:millions_}{\.{\\millions} primitive@>
primitive("billions",convert,billions_code);@/
@!@:billions_}{\.{\\billions} primitive@>
@#
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.469]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  number_code: print_esc("number");
@y
  number_code: print_esc("number");
  thousands_code: print_esc("thousands");
  millions_code: print_esc("millions");
  billions_code: print_esc("billions");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.471]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
number_code,roman_numeral_code: scan_int;
@y
number_code, thousands_code, millions_code, billions_code,
roman_numeral_code: scan_int;
@z
@x
number_code: print_int(cur_val);
@y
number_code: print_int(cur_val);
thousands_code: print_int((cur_val mod 1000000) div 1000);
millions_code:  print_int((cur_val mod 1000000000) div 1000000);
billions_code:  print_int(cur_val div 1000000000);
@z
@x
  else print_char(cur_chr);
@y
  else print(cur_chr);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.473]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function scan_toks(@!macro_def,@!xpand:boolean):pointer;
@y
\pTeXusechr
@p function scan_toks(@!macro_def,@!xpand:boolean):pointer;
@z
@x
var t:halfword; {token representing the highest parameter number}
@y
var t,tt:halfword; {token representing the highest parameter number}
@z
@x
p:=def_ref; hash_brace:=0; t:=zero_token;
@y
p:=def_ref; hash_brace:=0; t:=zero_token; tt:=semi_zero_token;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.476]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<If the next character is a parameter number...@>=
@y
@ 
\pTeXusechr
@<If the next character is a parameter number...@>=
@z
@x
if t=zero_token+9 then
@y
if (t=zero_token+9)or(tt=semi_zero_token+9) then
@z
@x
else  begin incr(t);
  if cur_tok<>t then
@y
else  begin incr(t); incr (tt);
  if (cur_tok<>t) and (cur_tok<>tt) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.479]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Look for parameter number...@>=
@y
@ 
\pTeXusechr
@<Look for parameter number...@>=
@z
@x
  if (cur_tok<=zero_token)or(cur_tok>t) then
@y
  if (cur_tok<=zero_token)or(cur_tok>t) then
    if (cur_tok<=semi_zero_token)or(cur_tok>tt) then
@z
@x
    sprint_cs(warning_index);
@y
    sprint_cs(warning_index); or_S(print("» قابل قبول نیست"));
@z
@x
  else cur_tok:=out_param_token-"0"+cur_chr;
@y
    else cur_tok:=out_param_token-"۰"+cur_chr
  else cur_tok:=out_param_token-"0"+cur_chr;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [27.483]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Input and store tokens from the next line of the file@>=
@y
@ 
\pTeXchg{Deal with |left_or_right| files.}
@<Input and store tokens from the next line of the file@>=
@z
@x 
else if read_open[m]=just_open then @<Input the first line of |read_file[m]|@>
else @<Input the next line of |read_file[m]|@>;
@y
else begin direction_stack[in_open]:=read_file_direction[m];
  if read_open[m]=just_open then @<Input the first line of |read_file[m]|@>
  else @<Input the next line of |read_file[m]|@>; end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.487] new `if' codes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
We consider now the way \TeX\ handles various kinds of \.{\\if} commands.
@y
We consider now the way \TeX\ handles various kinds of \.{\\if} commands.
\pTeXchg{Introduce new \.{\\if} commands.}
@z
@x    487
@d if_case_code=16 { `\.{\\ifcase}' }
@y    487===============
@d if_case_code=16 { `\.{\\ifcase}' }
@d if_L_code=17 { `\.{\\ifLtoR}' }
@d if_R_code=18 { `\.{\\ifRtoL}' }
@d if_latin_code=19 { `\.{\\iflatin}' }
@d if_left_vbox_code=20 { `\.{\\ifleftvbox}' }
@d if_joinable_code=21 { `\.{\\ifjoinable}' }
@d if_semiticchar_code=22 { `\.{\\ifsemiticchar}' }
@d if_ones_code=23 { `\.{\\ifonesof}' }
@d if_tens_code=24 { `\.{\\iftensof}' }
@d if_hundreds_code=25 { `\.{\\ifhundredsof}' }
@d if_thousands_code=26 { `\.{\\ifthousands}' }
@d if_millions_code=27 { `\.{\\ifmillions}' }
@d if_billions_code=28 { `\.{\\ifbillions}' }
@d if_prehundreds_code=29 { `\.{\\ifprehundreds}' }
@d if_prethousands_code=30 { `\.{\\ifprethousands}' }
@d if_premillions_code=31 { `\.{\\ifpremillions}' }
@d if_prebillions_code=32 { `\.{\\ifprebillions}' }
@d if_setlatin_code=33 { `\.{\\ifsetlatin}' }
@d if_setsemitic_code=34 { `\.{\\ifsetsemitic}' }
@d if_setrawprinting_code=35 { `\.{\\ifsetrawprinting}' }
@d if_LRdir_code=36 { `\.{\\ifautoLRdir}' }
@d if_LRfnt_code=37 { `\.{\\ifautofont}' }
@d if_splited_code=38 { `\.{\\ifsplited}' }
@z
@x    487
@!@:if_case_}{\.{\\ifcase} primitive@>
@y    487===============
@!@:if_case_}{\.{\\ifcase} primitive@>
primitive("ifLtoR",if_test,if_L_code);
@!@:if_L_}{\.{\\ifLtoR} primitive@>
primitive("ifRtoL",if_test,if_R_code);
@!@:if_R_}{\.{\\ifRtoL} primitive@>
primitive("iflatin",if_test,if_latin_code);
@!@:if_latin_}{\.{\\iflatin} primitive@>
primitive("ifleftvbox",if_test,if_left_vbox_code);
@!@:if_left_vbox_}{\.{\\ifleftvbox} primitive@>
primitive("ifjoinable",if_test,if_joinable_code);
@!@:if_joinable_}{\.{\\ifjoinable} primitive@>
primitive("ifsemiticchar",if_test,if_semiticchar_code);
@!@:if_semiticchar_}{\.{\\ifsemiticchar} primitive@>
primitive("ifonesof",if_test,if_ones_code);
@!@:if_ones_}{\.{\\ifonesof} primitive@>
primitive("iftensof",if_test,if_tens_code);
@!@:if_tens_}{\.{\\iftensof} primitive@>
primitive("ifhundredsof",if_test,if_hundreds_code);
@!@:if_hundreds_}{\.{\\ifhundredsof} primitive@>
primitive("ifthousands",if_test,if_thousands_code);
@!@:if_thousands_}{\.{\\ifthousands} primitive@>
primitive("ifmillions",if_test,if_millions_code);
@!@:if_millions_}{\.{\\ifmillions} primitive@>
primitive("ifbillions",if_test,if_billions_code);
@!@:if_billions_}{\.{\\ifbillions} primitive@>
primitive("ifprehundreds",if_test,if_prehundreds_code);
@!@:if_prehundreds_}{\.{\\ifprehundreds} primitive@>
primitive("ifprethousands",if_test,if_prethousands_code);
@!@:if_prethousands_}{\.{\\ifprethousands} primitive@>
primitive("ifpremillions",if_test,if_premillions_code);
@!@:if_premillions_}{\.{\\ifpremillions} primitive@>
primitive("ifprebillions",if_test,if_prebillions_code);
@!@:if_prebillions_}{\.{\\ifprebillions} primitive@>
primitive("ifsetlatin",if_test,if_setlatin_code);
@!@:if_setlatin_}{\.{\\ifsetlatin} primitive@>
primitive("ifsetsemitic",if_test,if_setsemitic_code);
@!@:if_setsemitic_}{\.{\\ifsetsemitic} primitive@>
primitive("ifsetrawprinting",if_test,if_setrawprinting_code);
@!@:if_setrawprinting_}{\.{\\ifsetrawprinting} primitive@>
primitive("ifautoLRdir",if_test,if_LRdir_code);
@!@:if_LRdir_}{\.{\\ifautoLRdir} primitive@>
primitive("ifautofont",if_test,if_LRfnt_code);
@!@:if_LRfnt_}{\.{\\ifautofont} primitive@>
primitive("ifsplited",if_test,if_splited_code);
@!@:if_splited_}{\.{\\ifsplited} primitive@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.488] new `if' codes 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    488
  if_case_code:print_esc("ifcase");
@y    488===============
  if_case_code:print_esc("ifcase");
  if_L_code:print_esc("ifLtoR");
  if_R_code:print_esc("ifRtoL");
  if_latin_code:print_esc("iflatin");
  if_left_vbox_code:print_esc("ifleftvbox");
  if_joinable_code:print_esc("ifjoinable");
  if_semiticchar_code:print_esc("ifsemiticchar");
  if_ones_code:print_esc("ifonesof");
  if_tens_code:print_esc("iftensof");
  if_hundreds_code:print_esc("ifhundredsof");
  if_thousands_code:print_esc("ifthousands");
  if_millions_code:print_esc("ifmillions");
  if_billions_code:print_esc("ifbillions");
  if_prehundreds_code:print_esc("ifprehundreds");
  if_prethousands_code:print_esc("ifprethousands");
  if_premillions_code:print_esc("ifpremillions");
  if_prebillions_code:print_esc("ifprebillions");
  if_setlatin_code:print_esc("ifsetlatin");
  if_setsemitic_code:print_esc("ifsetsemitic");
  if_setrawprinting_code:print_esc("ifsetrawprinting");
  if_LRdir_code:print_esc("ifautoLRdir");
  if_LRfnt_code:print_esc("ifautofont");
  if_splited_code:print_esc("ifsplited");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.496]  new `if' codes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Pop the condition stack@>=
begin p:=cond_ptr; if_line:=if_line_field(p);
@y
@ 
\pTeXchg{Implement \.{\\ifsetlatin} and \.{\\ifsetsemitic} grouping stack.}
@<Pop the condition stack@>=
begin p:=cond_ptr; if_line:=if_line_field(p);  pop_ifstk;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.498] new `if' codes 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure conditional;
label exit,common_ending;
var b:boolean; {is the condition true?}
@!r:"<"..">"; {relation to be evaluated}
@y
\pTeXchg{We add new conditionals and introduce new relation symbols.}
@p @<Declare |pop_ifstk|@>@/
@#
procedure conditional;
label exit,common_ending,done;
var b:boolean; {is the condition true?}
@!r:ASCII_code; {relation to be evaluated}
@!i:integer;
@z
@x
if tracing_commands>1 then @<Display the value of |b|@>;
@y
done:if tracing_commands>1 then @<Display the value of |b|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.501]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Either process \.{\\ifcase} or set |b|...@>=
@y
@ 
\pTeXchg{Implement \.{\\ifsetlatin} and \.{\\ifsetsemitic} grouping stack.}
@<Either process \.{\\ifcase} or set |b|...@>=
@z
@x    501
if_case_code: @<Select the appropriate case
  and |return| or |goto common_ending|@>;
end {there are no other cases}
@y    501===============
@<Process semitic conditionlas@>@/
if_case_code: @<Select the appropriate case
  and |return| or |goto common_ending|@>;
end {there are no other cases}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.503]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Test relation between integers or dimensions@>=
@y
\pTeXchg{Implement new relation symbols.}
@<Test relation between integers or dimensions@>=
@z
@x
if (cur_tok>=other_token+"<")and(cur_tok<=other_token+">") then
@y
if ((cur_tok>=other_token+"<")and(cur_tok<=other_token+">")) or
   ((cur_tok>=other_token+"<")and(cur_tok<=other_token+">")) then
@z
@x
  print_cmd_chr(if_test,this_if);
@y
  print_cmd_chr(if_test,this_if); or_S(print(" درج گردید"));
@z
@x
  back_error; r:="=";
@y
  back_error; L_or_S(r:="=")(r:="=");
@z
@x
"<": b:=(n<cur_val);
"=": b:=(n=cur_val);
">": b:=(n>cur_val);
@y    503===================
"<",">": b:=(n<cur_val);
"=","=": b:=(n=cur_val);
">","<": b:=(n>cur_val);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.506]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
active characters have the smallest tokens, among all control sequences.
@y
active characters have the smallest tokens, among all control sequences.
\pTeXeqnm
@z
@x Adding eqcharif
if this_if=if_char_code then b:=(n=cur_chr)@+else b:=(m=cur_cmd);
@y
if this_if=if_char_code then b:=((n=cur_chr)or@<Test |eqif| n@>)
@+else b:=(m=cur_cmd);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.507]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
are allowed, but we might be scanning a macro definition or preamble.
@y
are allowed, but we might be scanning a macro definition or preamble.
\pTeXeqnm
@z
@x Adding eqcharif
else if cur_cmd<call then b:=(cur_chr=q)
@y
else if cur_cmd<call then b:=((cur_chr=q)or@<Test |eqif| q@>)
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [28.509]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Select the appropriate case and |return| or |goto common_ending|@>=
begin scan_int; n:=cur_val; {|n| is the number of cases to pass}
@y
@ 
\pTeXusechr
@<Select the appropriate case and |return| or |goto common_ending|@>=
begin scan_int; @<Check positional numbers@>@/
 n:=cur_val; {|n| is the number of cases to pass}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.514] TEX area directories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d TEX_area=="TeXinputs:"
@.TeXinputs@>
@d TEX_font_area=="TeXfonts:"
@.TeXfonts@>
@y
We'll handle the path stuff in an external C module.
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.516] more_name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin if c=" " then more_name:=false
@y
begin if (c=" ")or(c=" ") then more_name:=false
@z
@x
  if (c=">")or(c=":") then
@y
  if (c="/") then
@z
@x
  else if (c=".")and(ext_delimiter=0) then ext_delimiter:=cur_length;
@y
  else if c="." then ext_delimiter:=cur_length;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.520] default format
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d format_default_length=20 {length of the |TEX_format_default| string}
@d format_area_length=11 {length of its area part}
@y
Under {\mc UNIX} we don't give the area part, instead depending
on the path searching that will happen during file opening.  This doesn't
really matter, since we change |TEX_format_default| to a char * anyway.

@d format_default_length=9 {length of the |TEX_format_default| string}
@d format_area_length=0 {length of its area part}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.521] plain format location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!TEX_format_default:packed array[1..format_default_length] of char;

@ @<Set init...@>=
TEX_format_default:='TeXformats:plain.fmt';
@y
@!TEX_format_default:c_char_pointer;

@ @<Set init...@>=
TEX_format_default := ' plain.fmt';
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.524] format file opening: only try once, with path search
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin incr(loc); j:=loc; buffer[last]:=" ";
  while buffer[j]<>" " do incr(j);
@y
  begin incr(loc); j:=loc; L_or_S(buffer[last]:=" ")(buffer[last]:=" ");
  while (buffer[j]<>" ")and(buffer[j]<>" ") do incr(j);
@z
@x
  pack_buffered_name(format_area_length,loc,j-1);
    {now try the system format file area}
  if w_open_in(fmt_file) then goto found;
@y
@z
@x wterm_ln --> bwterm_ln
  wterm_ln('Sorry, I can''t find that format;',' will try PLAIN.');
@y
  bwterm_ln('Sorry, I can''t find that format;',' will try PLAIN.');
@z
@x wterm_ln --> bwterm_ln
  wterm_ln('I can''t find the PLAIN format file!');
@y
  bwterm_ln('I can''t find the PLAIN format file!');
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.525] make_name_string
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function make_name_string:str_number;
var k:1..file_name_size; {index into |name_of_file|}
begin if (pool_ptr+name_length>pool_size)or(str_ptr=max_strings)or
 (cur_length>0) then
  make_name_string:="?"
else  begin for k:=1 to name_length do append_char(xord[name_of_file[k]]);
  make_name_string:=make_string;
  end;
end;
function a_make_name_string(var f:alpha_file):str_number;
begin a_make_name_string:=make_name_string;
end;
function b_make_name_string(var f:byte_file):str_number;
begin b_make_name_string:=make_name_string;
end;
function w_make_name_string(var f:word_file):str_number;
begin w_make_name_string:=make_name_string;
end;
@y
With the C version, we know that |real_name_of_file|
contains |name_of_file| prepended with the directory name that was found
by path searching.

If |real_name_of_file| starts with |'./'|, we don't use that part of the
name, since {\mc UNIX} users understand that.
@^system dependencies@>

@p function make_name_string:str_number;
var k,@!kstart:1..file_name_size; {index into |name_of_file|}
begin
  k:=1;
  while (k<file_name_size) and (xord[real_name_of_file[k]]<>" ") do incr(k);
  name_length:=k-1; {the real |name_length|}
  if (pool_ptr+name_length>pool_size)or(str_ptr=max_strings)or
     (cur_length>0) then  make_name_string:="?"
  else begin
    if (xord[real_name_of_file[1]]=".")and(xord[real_name_of_file[2]]="/") then
         kstart:=3
    else kstart:=1;
    for k:=kstart to name_length do append_char(xord[real_name_of_file[k]]);
    make_name_string:=make_string;
  end;
end;

{The |X_make_name_string| functions are changed to macros in C.}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.530] Adding Farsi messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure prompt_file_name(@!s,@!e:str_number);
@y
\pTeXaltstr
@p procedure prompt_file_name(@!s,@!e:str_number);
@z
@x
print_file_name(cur_name,cur_area,cur_ext); print("'.");
@y
print_file_name(cur_name,cur_area,cur_ext); L_or_S(print("'.");)
(if s="input file name" then print("» را پیدا کنم.") else print("» بنویسم."););
@z
@x
print_nl("Please type another "); print(s);
@y
print_nl("Please type another "); print(s); or_S(print(" تایپ کنید"));
@z
@x
clear_terminal; prompt_input(": "); @<Scan file name in the buffer@>;
@y
clear_terminal; left_input := true;
prompt_input(": "); @<Scan file name in the buffer@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.531]  Skip Farsi blanks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Scan file name in the buffer@>=
@y
@ 
\pTeXusechr
@<Scan file name in the buffer@>=
@z
@x
while (buffer[k]=" ")and(k<last) do incr(k);
@y
while ((buffer[k]=" ")or(buffer[k]=" "))and(k<last) do incr(k);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.534] Adjust for C string conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!months:packed array [1..36] of char; {abbreviations of month names}
@y
@!months:c_char_pointer;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.536] Add Farsi messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Print the banner...@>=
@y
@ 
\pTeXchg{Print Farsi date form.}
@<Print the banner...@>=
@z
@x
begin wlog(banner);
slow_print(format_ident); print("  ");
print_int(day); print_char(" ");
months:='JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC';
for k:=3*month-2 to 3*month do wlog(months[k]);
print_char(" "); print_int(year); print_char(" ");
print_two(time div 60); print_char(":"); print_two(time mod 60);
@y    536==============
begin print_nl(banner);
if not (format_ident = initex) then print_ln;
slow_print(format_ident);    print("  ");
if latin_speech then begin print_int(day); print_char(" ");
    months := ' JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC';
    for k:=3*month-2 to 3*month do print_char (months[k]);
    print_char(" "); print_int(year); print_char(" ");
    print_two(time div 60); print_char(":"); print_two(time mod 60);
  end
else begin  print_char(" "); 
       case semi_day of
            1: print("اول");
            2: print("دوم");
            3: print("سوم");
            4: print("چهارم");
            5: print("پنجم");
            6: print("ششم");
            7: print("هفتم");
            8: print("هشتم");
            9: print("نهم");
           10: print("دهم");
           11: print("یازدهم");
           12: print("دوادهم");
           13: print("سیزدهم");
           14: print("چهاردهم");
           15: print("پانزدهم");
           16: print("شانزدهم");
           17: print("هفدهم");
           18: print("هجدهم");
           19: print("نوزدهم");
           20: print("بیستم");
           21: print("بیست و یکم");
           22: print("بیست و دوم");
           23: print("بیست و سوم");
           24: print("بیست و چهارم");
           25: print("بیست و پنجم");
           26: print("بیست و ششم");
           27: print("بیست و هفتم");
           28: print("بیست و هشتم");
           29: print("بیست و نهم");
           30: print("سی‌ام");
           31: print("سی و یکم");
       othercases begin print("روز تعریف نشده (");
                        print_int(semi_day); print (")"); end
       endcases;@/
       print_char(" "); 
       case semi_month of
            1: print("فروردین");
            2: print("اردیبهشت");
            3: print("خرداد");
            4: print("تیر");
            5: print("مرداد");
            6: print("شهریور");
            7: print("مهر");
            8: print("آبان");
            9: print("آذر");
           10: print("دی");
           11: print("بهمن");
           12: print("اسفند");
       othercases begin print ("ماه تعریف نشده (");
                        print_int(semi_month); print (")"); end
       endcases;@/
       print_char(" "); print_int(semi_year); print(" در ساعت ");
       print_two(time mod 60); print_char(":"); print_two(time div 60);
  end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.537] a_open_in of \input file needs path selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if a_open_in(cur_file) then goto done;
  if cur_area="" then
    begin pack_file_name(cur_name,TEX_area,cur_ext);
    if a_open_in(cur_file) then goto done;
    end;
@y
  if a_open_in(cur_file,input_path_spec) then goto done;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.537] {get rid of return of name to string pool} But we do that more
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x Remove file name from string pool. We save ext and area here.
if name=str_ptr-1 then {we can conserve string pool space now}
  begin flush_string; name:=cur_name;
  end;
@y
if (name=str_ptr-1) or (ext=str_ptr-1) then
          {we can conserve string pool space now}
  begin flush_string;
     if (name=str_ptr-1) then flush_string;
     if (area=str_ptr-1) then flush_string;
     name:=cur_name; ext:=cur_ext; area:=cur_area;
  end
else begin ext:=0; area := 0; end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.563] Fix TFM file opening
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if aire="" then pack_file_name(nom,TEX_font_area,".tfm")
else pack_file_name(nom,aire,".tfm");
@y
pack_file_name(nom,aire,".tfm");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.564] reading the tfm file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% As a special case, whenever we open a tfm file, we read its first
% byte into "tfm_temp" right away.  TeX looks at "fbyte" before calling
% "fget", so it ends up seeing every byte.  This is Pascal-like I/O.
@x
@d fget==get(tfm_file)
@d fbyte==tfm_file^
@y
@d fget==tfm_temp:=getc(tfm_file)
@d fbyte==tfm_temp
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.576]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
the new font.
@y
the new font.
\pTeXchg{Deal with \pTeX{} fonts.}
@z
@x    576
font_bc[f]:=bc; font_ec[f]:=ec; font_glue[f]:=null;
@y    576===================
font_bc[f]:=bc; font_ec[f]:=ec; font_glue[f]:=null;
fontwin[f]:=null_font; font_mid_rule[f]:=null;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.577]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    577
if cur_cmd=def_font then f:=cur_font
@y    577===================
if cur_cmd=def_font then if cur_chr=Lftlang then f:=cur_latif
  else if cur_chr<=Rtlang then f:=cur_semif else f:=cur_font
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.578]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x
 @y
\pTeXaltstr
 @z
@x    578
else  begin if writing and(n<=space_shrink_code)and@|
    (n>=space_code)and(font_glue[f]<>null) then
    begin delete_glue_ref(font_glue[f]);
    font_glue[f]:=null;
    end;
@y    578===================
else begin if writing then
    if (n<=space_shrink_code)and(n>=space_code)and(font_glue[f]<>null) then
         begin delete_glue_ref(font_glue[f]); font_glue[f]:=null; end
    else @<Check \pTeX{} font dimen@>@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.581] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print_ASCII(c); print(" in font ");
  slow_print(font_name[f]); print_char("!"); end_diagnostic(false);
@y
  if is_semi_font (f) then print_s_ASCII(c)  else print_ASCII(c);
  print(" in font ");
  slow_print(font_name[f]); LorRprt("!"," موجود نیست!"); end_diagnostic(false);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.597] write_dvi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure write_dvi(@!a,@!b:dvi_index);
var k:dvi_index;
begin for k:=a to b do write(dvi_file,dvi_buf[k]);
end;
@y

In C, we use a macro to call fwrite() or write() directly, writing all
the bytes to be written in one shot.  Much better even than writing four
bytes at a time.
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.617] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print(" TeX output "); print_int(year); print_char(".");
  print_two(month); print_char("."); print_two(day);
  print_char(":"); print_two(time div 60);
  print_two(time mod 60);
@y
  if latin_speech then
    begin print(" Parsi_TeX output "); print_int(year); print_char(".");
      print_two(month); print_char("."); print_two(day);
      print_char(":"); print_two(time div 60);print_two(time mod 60);
    end
  else
    begin saved_lang := cur_speech; cur_speech := Lftlang;
      print(" TeX-e-Parsi output "); print_int(semi_year); print_char("/");
      print_two(semi_month); print_char("/"); print_two(semi_day);
      print_char(":"); print_two(time div 60); print_two(time mod 60);
      cur_speech := saved_lang;
    end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.619]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  |hlist_out|
@!p:pointer; {current position in the hlist}
@y
@!p:pointer; {current position in the hlist}
@!q:pointer; {trailes behind |p|}
@!saved_q:pointer; {for releasing |q|}
@z
@x
g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
incr(cur_s);
@y
g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
@<|re_organize| in |hlist_out|@>;
incr(cur_s);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.619]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    619
decr(cur_s);
@y    619==================
decr(cur_s); free_avail(saved_q);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.622]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    622
glue_node: @<Move right or output leaders@>;
@y    622==================
glue_node: if is_not_supressed(p) then @<Move right or output leaders@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.625] @<Move right or output leaders@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |mid_rule|
if subtype(p)>=a_leaders then
@y    625==================
@<Check |mid_rule|s@>@/
if subtype(p)>=a_leaders then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.631]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x 
rule_node: begin rule_ht:=height(p); rule_dp:=depth(p); rule_wd:=width(p);
@y    631===================
rule_node: begin rule_ht:=height(p); rule_dp:=depth(p); rule_wd:=width(p);
  leader_box:=p;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.632]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    632
  cur_h:=left_edge+shift_amount(p); {shift the box right}
@y    632==================
  if subtype(p)=right_justify then 
        cur_h:=left_edge-shift_amount(p) {shift the box left}
  else  cur_h:=left_edge+shift_amount(p); {shift the box right}
  if R_to_L_node (p) then cur_h:=cur_h+width(this_box)-width(p);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.633]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    633
  begin synch_h; synch_v;
  dvi_out(put_rule); dvi_four(rule_ht); dvi_four(rule_wd);
  end;
@y    633==================
  begin save_h:=cur_h;
    if R_to_L_node (leader_box) then
         cur_h:=cur_h+width(this_box)-rule_wd;
    synch_h; synch_v; dvi_out(put_rule); dvi_four(rule_ht); dvi_four(rule_wd);
    if cur_h<>save_h then begin cur_h:=save_h; synch_h; end;
  end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.637]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    637
begin cur_h:=left_edge+shift_amount(leader_box); synch_h; save_h:=dvi_h;@/
@y
begin cur_h:=left_edge+shift_amount(leader_box); save_h:=cur_h;@/
  if R_to_L_node (leader_box) then
       cur_h:=cur_h+width(this_box)-width(leader_box);
  synch_h;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.638] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |ship_out|
begin if tracing_output>0 then
@y
@<LR ship vars@>@/
if tracing_output>0 then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.639] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |ship_out|
flush_node_list(p);
@y
flush_node_list(p); @<Flush the LR stack@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.642] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print(" ("); print_int(total_pages); print(" page");
  if total_pages<>1 then print_char("s");
  print(", "); print_int(dvi_offset+dvi_ptr); print(" bytes).");
@y
  LorRprt(" ("," نوشته شد ("); print_int(total_pages); print(" page");
  if total_pages<>1 then L_or(print_char("s"));
  print(", "); print_int(dvi_offset+dvi_ptr); print(" bytes).");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.649]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  |hpack|
begin last_badness:=0; r:=get_node(box_node_size); type(r):=hlist_node;
@y    649==================
@!LR_err:integer; {counts missing begins and ends}
@!LR_sv:pointer;
begin last_badness:=0; r:=get_node(box_node_size); type(r):=hlist_node;
LR_sv:=LRsp; LRsp := null; LR_err:=0;
@z
@x    649
exit: hpack:=r;
@y    649==================
exit: @<Check for LR anomalies at the end of |hpack|@>;
@!debug if is_open_LR then confusion (" LRsp in hpack "); gubed
LRsp:=LR_sv; hpack:=r;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.651]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    651
  glue_node:@<Incorporate glue into the horizontal totals@>;
@y    651===================
  glue_node:if is_not_supressed(p) then
    @<Incorporate glue into the horizontal totals@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.656]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    656
if subtype(p)>=a_leaders then
  begin g:=leader_ptr(p);
@y    656===================
if (subtype(p)>=a_leaders)and(subtype(p)<=x_leaders) then
  begin g:=leader_ptr(p);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.660] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if last_badness>100 then print_nl("Underfull")@+else print_nl("Loose");
@y
L_or_S(if last_badness>100 then print_nl("Underfull")@+else print_nl("Loose"))
 (print_nl("\کادرا ی ");
   if last_badness>100 then print("کم‌پر")@+else print("گسسته"));
@z
@x
  print_int(line);
@y
  print_int(line); or_S(print(" بوقوع پیوست"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.669] check midrules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    669
  glue_node: @<Incorporate glue into the vertical totals@>;
@y    669==================
  glue_node: if is_mrule(p) then confusion("mid_rule_2")
    else @<Incorporate glue into the vertical totals@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.674] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if last_badness>100 then print_nl("Underfull")@+else print_nl("Loose");
@y
L_or_S(if last_badness>100 then print_nl("Underfull")@+else print_nl("Loose"))
 (print_nl("\کادرو ی ");
   if last_badness>100 then print("کم‌پر")@+else print("گسسته"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [33.675] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print_int(line);
@y
  print_int(line); or_S(print(" بوقوع پیوست"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [34.691] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin print_esc("fam"); print_int(fam(p)); print_char(" ");
print_ASCII(qo(character(p)));
@y
begin if is_semi_font (font(p)) then print_esc("semifam") else print_esc("fam");
 print_int(fam(p)); print_char(" ");
 @<Print |p| according to |fontwin[font(p)]|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [35.702]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x    702
@d cramped_style(#)==2*(# div 2)+cramped {cramp the style}
@d sub_style(#)==2*(# div 4)+script_style+cramped {smaller and cramped}
@d sup_style(#)==2*(# div 4)+script_style+(# mod 2) {smaller}
@d num_style(#)==#+2-2*(# div 6) {smaller unless already script-script}
@d denom_style(#)==2*(# div 2)+cramped+2-2*(# div 6) {smaller, cramped}
 @y    702===================
@d cramped_style(#)==2*((#) div 2)+cramped {cramp the style}
@d sub_style(#)==2*((#) div 4)+script_style+cramped {smaller and cramped}
@d sup_style(#)==begin ss:=(#) mod 2;
   ss:=2*((#) div 4)+script_style+ss; end {smaller}
@d num_style(#)==#+2-2*((#) div 6) {smaller unless already script-script}
@d denom_style(#)==2*((#) div 2)+cramped+2-2*((#) div 6) {smaller, cramped}
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [36.738]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    738
  width(y):=0; p:=new_kern(-delta); link(p):=x; link(y):=p;
@y    738===================
  width(y):=0; subtype(y):=left_justify; {|left_vbox|}
  p:=new_kern(-delta); link(p):=x; link(y):=p;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [36.749]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x    749
@!shift_up,@!shift_down:scaled; {dimensions for box calculation}
 @y    749===================
@!shift_up,@!shift_down:scaled; {dimensions for box calculation}
@!ss:small_number; {auxiliary variable for special `mod' handling}
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [36.750]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x    750
begin x:=clean_box(supscr(q),sup_style(cur_style));
 @y    750===================
begin sup_style(cur_style); x:=clean_box(supscr(q),ss);
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [36.756]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x    756
@!t:small_number; {subsidiary size code}
 @y    756===================
@!t:small_number; {subsidiary size code}
@!ss:small_number; {auxiliary variable for special `mod' handling}
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [36.758]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x    758
begin x:=clean_box(supscr(q),sup_style(cur_style));
 @y    758===================
begin sup_style(cur_style); x:=clean_box(supscr(q),ss);
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [36.759]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    759
x:=vpack(x,natural); shift_amount(x):=shift_down;
@y    759===================
subtype(x):=left_justify; subtype(y):=left_justify; {|left_vbox|}
x:=vpack(x,natural); shift_amount(x):=shift_down;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.770]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |align_chr|
@d align_stack_node_size=5 {number of |mem| words to save alignment states}

@<Glob...@>=
@!cur_align:pointer; {current position in preamble list}
@y    770===================
@d align_stack_node_size=6 {number of |mem| words to save alignment states}

@<Glob...@>=
@!align_cmd:halfword; {current alignment command code}
@!align_chr:halfword; {current alignment |sub_command| code}
@!cur_align:pointer; {current position in preamble list}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.771]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |align_chr|
cur_head:=null; cur_tail:=null;
@y
cur_head:=null; cur_tail:=null; align_cmd:=null; align_chr:=null;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.772]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |align_chr|
info(p+4):=cur_head; link(p+4):=cur_tail;
@y
info(p+4):=cur_head; link(p+4):=cur_tail;
info(p+5):=align_cmd; link(p+5):=align_chr;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.772]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |align_chr|
cur_tail:=link(p+4); cur_head:=info(p+4);
@y
cur_tail:=link(p+4); cur_head:=info(p+4);
align_cmd:=info(p+5); align_chr:=link(p+5);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.774] init_align
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |align_chr| 
push_alignment; align_state:=-1000000; {enter a new alignment level}
@y
push_alignment; align_state:=-1000000; {enter a new alignment level}
align_cmd:=cur_cmd; align_chr:=cur_chr;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.786] init_span
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x insert |begin_R_code| at begin of column
if mode=-hmode then space_factor:=1000
@y
if mode=-hmode then begin  space_factor:=1000;
@<insert |begin_R_code| at begin of column@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.792] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print_esc("cr");
@y
  print_esc("cr"); or_S(print(" تغییر داده‌شد"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.796] fin_col
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x insert matching |end_R_code| at end of column 
  begin adjust_tail:=cur_tail; u:=hpack(link(head),natural); w:=width(u);
@y
  begin adjust_tail:=cur_tail;
@<insert matching |end_R_code| at end of column@>;@/
u:=hpack(link(head),natural); w:=width(u);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.799] fin_row
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x set row justification
  begin p:=hpack(link(head),natural);
@y
  begin p:=hpack(link(head),natural);
   if align_chr=Rtlang then subtype(p):=right_justify
   else subtype(p):=left_justify;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.800]  fin_align 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x introduce |pu| and |pr| to keep predecessor nodes of |u| and |r|
var @!p,@!q,@!r,@!s,@!u,@!v: pointer; {registers for the list operations}
@y
var @!p,@!q,@!r,@!s,@!u,@!v,@!pu,@!pr: pointer;
   {registers for the list operations}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.806] running dimention in rule 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x set rule justification in alignment
  shift_amount(q):=o; link(q):=r; link(s):=q;
@y 
  shift_amount(q):=o; link(q):=r; link(s):=q; subtype(q):=subtype(list_ptr(q));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.807] @<Set the unset box |q| and the unset boxes in it@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x append blank boxes and reverse the columns in a row
repeat @<Set the glue in node |r| and change it from an unset node@>;
r:=link(link(r)); s:=link(link(s));
until r=null;
@y
pr:=list_ptr(q); { keep |r| predecessor in |pr| }
repeat @<Set the glue in node |r| and change it from an unset node@>;
pr:=link(r); { ditto }
r:=link(link(r)); s:=link(link(s));
until r=null;
if align_chr=Rtlang then @<Reverse align columns@>;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% @<Set the glue in node |r|...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x set spanned box width to last column width
if mode=-vmode then
@y
if u<>hold_head then
  if align_chr=Rtlang then begin width(u):=w; w:=width(s); end;
if mode=-vmode then
@z
@x set spanned box as last spanned column
  begin link(u):=link(r); link(r):=link(hold_head); r:=u;
@y
  if align_chr=Rtlang then
       begin link(u):=link(hold_head); link(pu):=r; link(pr):=u; end
  else begin link(u):=link(r); link(r):=link(hold_head); r:=u;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [37.809] Append tabskip 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x keep last blank box of spanned columns in |pu|
s:=link(s); link(u):=new_null_box; u:=link(u); t:=t+width(s);
@y
s:=link(s); link(u):=new_null_box; pu:=u; u:=link(u); t:=t+width(s);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [38.816] line_break
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |mid_rule|
link(temp_head):=link(head);
@y
link(temp_head):=link(head); r:=tail;
@z
@x
  flush_node_list(leader_ptr(tail)); penalty(tail):=inf_penalty;
  end;
@y
  if is_not_mrule(tail) then flush_node_list(leader_ptr(tail))
  else leader_ptr(tail):=null; penalty(tail):=inf_penalty;
  r:=link(head); while link(r)<>tail do r:=link(r);
  end;
if in_auto_LR then begin s:=tail; tail:=r; pop_stkLR; tail_append(s); end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [38.859] Fix a casting/expression evaluation problem.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if abs(fit_class-fitness(r))>1 then d:=d+adj_demerits;
@y
if abs(toint(fit_class)-toint(fitness(r)))>1 then d:=d+adj_demerits;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.866] @<Call |try_break| if |cur_p| is a legal breakpoint...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |mid_rule|
@d kern_break==begin if not is_char_node(link(cur_p)) and auto_breaking then
    if type(link(cur_p))=glue_node then try_break(0,unhyphenated);
@y
@d kern_break==begin if not is_char_node(link(cur_p)) and auto_breaking then
    if (type(link(cur_p))=glue_node) and is_not_mrule(link(cur_p)) then
       try_break(0,unhyphenated);
@z
@x |glue_node:|
  if second_pass and auto_breaking then
@y
  if second_pass and auto_breaking and is_not_mrule(cur_p) then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.868] @<If node |cur_p| is a legal breakpoint, call...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |mid_rule|
if auto_breaking then
@y
if auto_breaking and is_not_mrule(cur_p) then
@z
@x |mid_rule|
check_shrinkage(glue_ptr(cur_p)); q:=glue_ptr(cur_p);
@y
  if second_pass and auto_breaking then activate_mid_rule (cur_p)
  else suppress_mid_rule (cur_p);
  if is_not_supressed(cur_p) then begin
     check_shrinkage(glue_ptr(cur_p)); q:=glue_ptr(cur_p);
@z
@x append end of above begin
active_width[6]:=active_width[6]+shrink(q)
@y
active_width[6]:=active_width[6]+shrink(q)
end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.875] Another casting bug
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin line_diff:=line_number(r)-best_line;
@y
  begin line_diff:=toint(line_number(r))-toint(best_line);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.877] post_line_break
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x prepare to handle LR nodes
@!cur_line: halfword; {the current line number being justified}
begin @<Reverse the links of the relevant passive nodes, setting |cur_p| to the
  first breakpoint@>;
@y
@!cur_line: halfword; {the current line number being justified}
@!tmp:pointer; { for LR manipulation }
begin 
@!debug if is_open_LR then confusion (" LRsp in post_line_break "); gubed
@!debug if is_open_LJ then confusion (" LJsp in post_line_break "); gubed
@<Reverse the links of the relevant passive nodes, setting |cur_p| to the
  first breakpoint@>;
@z
@x LR nodes
prev_graf:=best_line-1;
@y
prev_graf:=best_line-1; @<Flush the LJ stack@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.880]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x LR nodes
@<Modify the end of the line to reflect the nature of the break and to include
  \.{\\rightskip}; also set the proper value of |disc_break|@>;
@y
@<Adjust the LR stack based on LR nodes in this line@>;
@<Modify the end of the line to reflect the nature of the break and to include
  \.{\\rightskip}; also set the proper value of |disc_break|@>;
@<Insert LR nodes at the end of the current line@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.881] @<Modify the end of the line...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |mid_rule| and left or right skip
    glue_ptr(q):=right_skip;
    subtype(q):=right_skip_code+1; add_glue_ref(right_skip);
@y
    if is_mrule(q) then leader_ptr(q):=null;
    if R_to_L_line then
         begin glue_ptr(q):=left_skip; add_glue_ref(left_skip); 
               subtype(q):=left_skip_code+1; 
         end
    else  begin glue_ptr(q):=right_skip; add_glue_ref(right_skip); 
                subtype(q):=right_skip_code+1; 
          end;
@z
@x |accents|
    else if (type(q)=math_node)or(type(q)=kern_node) then width(q):=0;
@y
    else if (type(q)=math_node)or
            ((type(q)=kern_node)and(subtype(q)<>acc_kern)) then width(q):=0;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.886] @<Put the \(r)\.{\\rightskip} glue after node |q|@>;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x left or right skip
r:=new_param_glue(right_skip_code); link(r):=link(q); link(q):=r; q:=r
@y
   if R_to_L_line then r:=new_param_glue(left_skip_code)
   else r:=new_param_glue(right_skip_code);
   link(r):=link(q); link(q):=r; q:=r
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.887] @<Put the \(l)\.{\\leftskip} glue at the left...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x left or right skip
if left_skip<>zero_glue then
  begin r:=new_param_glue(left_skip_code);
  link(r):=q; q:=r;
  end
@y
  if R_to_L_line then begin
     if right_skip<>zero_glue then
       begin r:=new_param_glue(right_skip_code); link(r):=q; q:=r; end;
  end else if left_skip<>zero_glue then 
           begin r:=new_param_glue(left_skip_code); link(r):=q; q:=r; end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [39.889] @<Call the packaging subroutine...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x box justification
shift_amount(just_box):=cur_indent
@y
if R_to_L_vbox then
  begin subtype(just_box):=right_justify; {|cur_indent| := -|cur_indent|;} end
else subtype(just_box):=left_justify;
shift_amount(just_box):=cur_indent
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [40.899] @<Check that the nodes following |hb| permit hyphenation...@>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |mid_rule|
    whatsit_node,glue_node,penalty_node,ins_node,adjust_node,mark_node:
      goto done4;
@y
    whatsit_node,penalty_node,ins_node,adjust_node,mark_node: goto done4;
    glue_node: if is_not_mrule(s) then goto done4 else goto done1;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [42.934] new_hyph_exceptions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x |semitic char|
@!u,@!v:pool_pointer; {indices into |str_pool|}
 @y
@!u,@!v:pool_pointer; {indices into |str_pool|}
@!tmp:halfword;
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [42.935]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x |semitic char|
  char_num: begin scan_char_num; cur_chr:=cur_val; cur_cmd:=char_given;
 @y    935===================
  char_num: begin tmp:=cur_chr; scan_char_num; cur_chr:=cur_val;
    if tmp=Lftlang then cur_cmd:=char_given else cur_cmd:=semi_given;
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [42.937]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x |semitic char|
    begin print_err("Not a letter");
@.Not a letter@>
    help2("Letters in \hyphenation words must have \lccode>0.")@/
 @y
    begin print_err("Not a latin letter");
@.Not a letter@>
    help3("Hyphenation exceptions must contain only latin letters")@/
    ("and latin letters in \hyphenation words must have \lccode>0.")@/
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [43.943] web2c can't parse negative lower bounds in arrays.  Sorry.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!init@! trie_op_hash:array[-trie_op_size..trie_op_size] of 0..trie_op_size;
@y
@!init@! trie_op_hash:array[neg_trie_op_size..trie_op_size] of 0..trie_op_size;
@z
@x
var h:-trie_op_size..trie_op_size; {trial hash location}
@y
var h:neg_trie_op_size..trie_op_size; {trial hash location}
@z
@x 944
begin h:=abs(n+313*d+361*v+1009*cur_lang) mod (trie_op_size+trie_op_size)
  - trie_op_size;
@y
begin h:=abs(toint(n)+313*toint(d)+361*toint(v)+1009*toint(cur_lang))
  mod (trie_op_size - neg_trie_op_size) + neg_trie_op_size;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [43.947] A casting problem.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin h:=abs(trie_c[p]+1009*trie_o[p]+@|
    2718*trie_l[p]+3142*trie_r[p]) mod trie_size;
@y
begin h:=abs(toint(trie_c[p])+1009*toint(trie_o[p])+@|
    2718*toint(trie_l[p])+3142*toint(trie_r[p])) mod trie_size;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [45.989] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x 989
@!output_active:boolean; {are we in the midst of an output routine?}
@y
@!output_active:boolean; {are we in the midst of an output routine?}
@!splited_ins:array [0..255] of boolean;
@z

@x 990
output_active:=false; insert_penalties:=0;
@y
output_active:=false; insert_penalties:=0;
for i:=0 to 255 do splited_ins [i] := false;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [45.992] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
flush_node_list(box(n)); box(n):=null;
end;
@y
flush_node_list(box(n)); box(n):=null;
end;
@#
@<Define |append_mid_rule| procedure@>@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1014]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
insert_penalties:=0; {this will count the number of insertions held over}
@y
insert_penalties:=0; {this will count the number of insertions held over}
for q:=0 to 255 do splited_ins [q] := false;
@z

@x 1021
      free_node(temp_ptr,box_node_size); wait:=true;
@y
      free_node(temp_ptr,box_node_size); wait:=true;
   splited_ins[subtype(r)] := true;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1029]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x    1029
with particular care.
 @y    1029=================
with particular care.

 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1030]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |main_loop|
@^inner loop@>
@y
@^inner loop@>
\pTeXchg{We should double cases of inner loop to read semitic characters 
and assign approperiate font in accordance with their joining attributes.}
@z
@x |main_loop|
@d append_normal_space=120 {go here to append a normal space between words}
@y
@d append_normal_space=120 {go here to append a normal space between words}
@#
@d pre_lookahead_one=121 {backing from |main_loop_lookahead+1|}
@d post_lookahead_one=122 {skip |semi_chr| check in |main_loop_lookahead+1|}
@#
@d semi_main_loop=130 {go here to typeset |cur_chr| in the current font}
@d semi_mid_loop=135 {like |main_loop_2|, but |f| is already adjusted}
@d semi_lookahead=140 {like |main_loop_2|, but several variables are set up}
@d semi_lig_loop=145 {go here to check for ligature or kern}

@d manual=0   {should be |> normal < LRsw_max|}
@d autoLR=1   {should be |> normal < LRsw_max|}
@d autofont=2   {should be |> normal < LRsw_max|}
@d automatic=3   {should be |> normal < LRsw_max|}

@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1030]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |main_loop|
  append_normal_space,exit;
var@!t:integer; {general-purpose temporary variable}
@y
semi_main_loop,semi_main_loop+1,semi_main_loop+2,semi_mid_loop,
  semi_lookahead,semi_lookahead+1,semi_lookahead+2,semi_lookahead+3,
  semi_lig_loop, append_normal_space,exit;
var@!t:integer; {general-purpose temporary variable}
@!l:quarterword; {the current character or ligature}
@!c:eight_bits; {the most recent character}
@!r:halfword; {the next character for ligature/kern matching}
@!k:0..font_mem_size; {index into |font_info|}
@!q:pointer; {where a ligature should be detached}
@!i:four_quarters; {character information bytes for |l|}
@!j:four_quarters; {ligature/kern command}
@!f,f1,acc_font:internal_font_number; {the current font}
@!fontadj:boolean; {should the current font be adjusted?}
@!acc_char:four_quarters;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1030]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |main_loop|
big_switch: get_x_token;@/
@y
@<Reset last char params@>;@/
big_switch: get_x_token;@/
@z
@x
hmode+letter,hmode+other_char,hmode+char_given: goto main_loop;
hmode+char_num: begin scan_char_num; cur_chr:=cur_val; goto main_loop;@+end;
@y
hmode+letter,hmode+other_char:
if is_semi_char(cur_chr) then goto semi_main_loop else goto main_loop;
hmode+char_given: goto main_loop;
hmode+semi_given: goto semi_main_loop;
hmode+char_num: begin 
       if (cur_chr=Lftlang) and check_latin_font then goto big_switch
       else if (cur_chr=Rtlang) and check_semitic_font then goto big_switch;
       t:=cur_chr; scan_char_num; cur_chr:=cur_val;
       if t=Lftlang then goto main_loop else goto semi_main_loop;
  end;
@z
@x
hmode+spacer: if space_factor=1000 then goto append_normal_space
  else app_space;
hmode+ex_space,mmode+ex_space: goto append_normal_space;
@y    1030=================
hmode+spacer,hmode+ex_space: begin
  if (cur_chr=Rtlang) or (is_semi_char(cur_chr)) then
       begin if check_semitic_font then goto big_switch; end
  else if check_latin_font then goto big_switch;
  if (cur_cmd=ex_space)or(space_factor=1000) then goto append_normal_space
  else call_app_space;
  end;
mmode+ex_space: begin if cur_chr=Rtlang then set_semi_font else set_latin_font;
       goto append_normal_space;
  end;
@z
@x
end; {of the big |case| statement}
goto big_switch;
@y
end; {of the big |case| statement}
goto big_switch;
semi_main_loop: @<handle semitic character such as TeX main loop@>;
@z
 @x
@d adjust_space_factor==@t@>@;@/
 @y
@d adjust_space_factor==@t@>@;@/
 @z
@x |main_loop|
@<Append character |cur_chr|...@>=
adjust_space_factor;@/
@y
@<Append character |cur_chr|...@>=
  if check_latin_font then goto big_switch;@/
  adjust_space_factor; 
  @<Reset last char params@>;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1031]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if cur_cmd=char_given then goto main_loop_lookahead+1;
@y
if cur_cmd=char_given then goto post_lookahead_one;
@z
@x
if cur_cmd=char_given then goto main_loop_lookahead+1;
if cur_cmd=char_num then
  begin scan_char_num; cur_chr:=cur_val; goto main_loop_lookahead+1;
  end;
if cur_cmd=no_boundary then bchar:=non_char;
cur_r:=bchar; lig_stack:=null; goto main_lig_loop;
main_loop_lookahead+1: adjust_space_factor;
@y
if cur_cmd=char_given then goto post_lookahead_one;
if (cur_cmd=char_num) and (cur_chr = Lftlang) then
  begin scan_char_num; cur_chr:=cur_val; goto post_lookahead_one;
  end;
if cur_cmd=no_boundary then bchar:=non_char;
pre_lookahead_one:
cur_r:=bchar; lig_stack:=null; goto main_lig_loop;
main_loop_lookahead+1:
  if is_semi_char(cur_chr) then goto pre_lookahead_one;
post_lookahead_one: adjust_space_factor;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1041]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1041
@<Append a normal inter-word space...@>=
if space_skip=zero_glue then
  begin @<Find the glue specification, |main_p|, for
    text spaces in the current font@>;
  temp_ptr:=new_glue(main_p);
  end
else temp_ptr:=new_param_glue(space_skip_code);
link(tail):=temp_ptr; tail:=temp_ptr;
goto big_switch
@y    1041=================
@<Append a normal inter-word space...@>=
if is_semi_font (cur_font) then
  if semi_space_skip=zero_glue then
  begin @<Find the glue specification, |main_p|, for
    text spaces in the current font@>;
  temp_ptr:=new_glue(main_p);
  end
  else temp_ptr:=new_param_glue(semi_space_skip_code)
else if space_skip=zero_glue then
  begin @<Find the glue specification, |main_p|, for...@>;
  temp_ptr:=new_glue(main_p);
    end
  else temp_ptr:=new_param_glue(space_skip_code);
link(tail):=temp_ptr; tail:=temp_ptr;
@<Reset last char params@>;@/
goto big_switch
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1043]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1043
procedure app_space; {handle spaces when |space_factor<>1000|}
var@!q:pointer; {glue node}
begin if (space_factor>=2000)and(xspace_skip<>zero_glue) then
  q:=new_param_glue(xspace_skip_code)
else  begin if space_skip<>zero_glue then main_p:=space_skip
  else @<Find the glue specification...@>;
  main_p:=new_spec(main_p);
  @<Modify the glue specification in |main_p| according to the space factor@>;
  q:=new_glue(main_p); glue_ref_count(main_p):=null;
  end;
link(tail):=q; tail:=q;
end;
@y    1043===================
procedure app_space(xsp,sp:halfword); {handle spaces when |space_factor<>1000|}
var@!q:pointer; {glue node}
begin if (space_factor>=2000)and(glue_par(xsp)<>zero_glue) then
         q:=new_param_glue(xsp)
else  begin if glue_par(sp)<>zero_glue then main_p:=glue_par(sp)
  else @<Find the glue specification...@>;
  main_p:=new_spec(main_p);
  @<Modify the glue specification in |main_p| according to the space factor@>;
  q:=new_glue(main_p); glue_ref_count(main_p):=null;
  end;
link(tail):=q; tail:=q;
@<Reset last char params@>;@/
end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1049] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
print("' in "); print_mode(mode);
@y
print("' in "); print_mode(mode); or_S(print(" بکار ببرید"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [46.1050] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x
("return to the right one by typing `I}' or `I$' or `I\par'.");@/
error;
end;
 @y
("return to the right one by typing `I}' or `I$' or `I\par'.");@/
error;
end;
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1056]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if abs(mode)=vmode then prev_depth:=ignore_depth
  else if abs(mode)=hmode then space_factor:=1000;
@y
  if abs(mode)=vmode then
    begin prev_depth:=ignore_depth; @<Set rule justification@>;@/
    end
  else if abs(mode)=hmode then space_factor:=1000;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1070] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if par_shape_ptr<>null then eq_define(par_shape_loc,shape_ref,null);
@y
if par_shape_ptr<>null then eq_define(par_shape_loc,shape_ref,null);
@<Check parargraph justification@>;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1071]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x hboxR
@!@:hbox_}{\.{\\hbox} primitive@>
 @y
@!@:hbox_}{\.{\\hbox} primitive@>
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1072]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x hboxR
  othercases print_esc("hbox")
@y
  vtop_code+hmode+1: print_esc("hboxR");
  othercases print_esc("hbox")
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1076]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    if adjust_tail<>null then
@y
    @<Set |cur_box| justification@>;@/
    if adjust_tail<>null then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1078]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  leader_ptr(tail):=cur_box;
@y
  leader_ptr(tail):=cur_box;
  if abs(mode)=vmode then @<Set |cur_box| justification@>;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1081]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
cur_box:=tail; shift_amount(cur_box):=0;
@y
cur_box:=tail; shift_amount(cur_box):=0; subtype(cur_box):=min_quarterword;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1083]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x hboxR
begin k:=cur_chr-vtop_code; saved(0):=box_context;
@y
begin k:=cur_chr-vtop_code; saved(0):=box_context;
      if k>hmode then n:=1 else n:=0; k:=k-n;
@z
@x
  if every_hbox<>null then begin_token_list(every_hbox,every_hbox_text);
@y
@<Test |n=1|@>;@/
  if every_hbox<>null then begin_token_list(every_hbox,every_hbox_text);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1086]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1086
if mode=-hmode then cur_box:=hpack(link(head),saved(2),saved(1))
@y    1086==================
if mode=-hmode then begin @<Test |auto_LR|@>;@/
   cur_box:=hpack(link(head),saved(2),saved(1)); end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1090]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1090
   vmode+ex_space,vmode+no_boundary:@t@>@;@/
  begin back_input; new_graf(true);
  end;

@y    1090==================
   vmode+ex_space,vmode+no_boundary,vmode+semi_given,vmode+LR:@t@>@;@/
  begin back_input; new_graf(true);
  end;

@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1091]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |new_graf|
if indented then
  begin tail:=new_null_box; link(head):=tail; width(tail):=par_indent;@+
  end;
if every_par<>null then begin_token_list(every_par,every_par_text);
@y    1091==================
emit_par_LR;@/
if indented then
  begin tail_append(new_null_box); width(tail):=par_indent; @+
  end;
@<Insert |every_semi_par|@>;@/
if every_par<>null then begin_token_list(every_par,every_par_text);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1108] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure end_graf;
begin if mode=hmode then
  begin if head=tail then pop_nest {null paragraphs are ignored}
  else line_break(widow_penalty);
@y
procedure LR_line_break(@!wp:integer);
var p:pointer; 
begin  p:=link(head);
       while ((p<>null) and (whatsit_LR(p)))  do p:=link(p);
       if p<>null then line_break(wp)
       else begin p:=link(head); pop_nest; flush_node_list (p); end;
end;
procedure end_graf; 
begin if mode=hmode then
  begin if head=tail then pop_nest {null paragraphs are ignored}
  else LR_line_break (widow_penalty); 
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1117]  delete_last procedure checking auto_LR interference 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure delete_last;
label exit;
var @!p,@!q:pointer; {run through the current list}
@!m:quarterword; {the length of a replacement list}
begin if (mode=vmode)and(tail=head) then
  @<Apologize for inability to do the operation now,
    unless \.{\\unskip} follows non-glue@>
else  begin if not is_char_node(tail) then if type(tail)=cur_chr then
    begin q:=head;
    repeat p:=q;
    if not is_char_node(q) then if type(q)=disc_node then
      begin for m:=1 to replace_count(q) do p:=link(p);
      if p=tail then return;
      end;
    q:=link(p);
    until q=tail;
    link(p):=null; flush_node_list(tail); tail:=p;
    end;
  end;
@y
procedure delete_last;
label exit;
var @!p,@!q:pointer; {run through the current list}
begin if (mode=vmode)and(tail=head) then
  @<Apologize for inability to do the operation now,
    unless \.{\\unskip} follows non-glue@>
else begin p:=find_last (cur_chr);
       if p<>null then begin
         if (p=head) and ((link(p)=null) or (type(link(p))<>cur_chr)) then
            begin q:=p; head:=link(p); end
         else 
         if link(p)<>tail then begin q:=link(p); link(p):=link(q); p:=q; end
         else begin q:=tail; tail:=p; end;
         link(p):=null; flush_node_list(q); 
       end;
     end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1121]  procedure unpackage adding left or right justify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x Are this change necessary ???? (test it)
while link(tail)<>null do tail:=link(tail);
exit:end;
@y
if abs(mode)=vmode then
  while link(tail)<>null do
    begin tail:=link(tail);
    if (type(tail)=rule_node) or
       (type(tail)=hlist_node) or
       (type(tail)=vlist_node) then
      if subtype(tail)=min_quarterword then
        if R_to_L_vbox then subtype(tail):=right_justify
        else subtype(tail):=left_justify;
    end
else while link(tail)<>null do tail:=link(tail);
exit:end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1119]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1119
  and set |q| to the list's tail@>;
p:=link(head); pop_nest;
@y    1119==================
  and set |q| to the list's tail@>;
p:=link(head); pop_nest; if link(q)<>null then q:=link(q);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1122]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x     1122
hmode+accent: make_accent;
@y
hmode+accent: if cur_chr=Lftlang then make_accent
              else if cur_chr > Rtlang+1 then retain_acc := true
              else make_semi_accent (cur_chr > Rtlang);
@z
@x
@<Declare act...@>=
procedure make_accent;
@y
\pTeXchg{Semitic accents are more complicated, so we left 
|make_accent| procedure for latin accents and define a new function
to deal with semitic accents.}
@<Declare act...@>=
procedure make_accent;
@z
@x    1123
begin scan_char_num; f:=cur_font; p:=new_character(f,cur_val);
@y    1123==================
begin scan_char_num; f:=cur_latif; p:=new_character(f,cur_val);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1124]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1124 
q:=null; f:=cur_font;
@y    1124==================
q:=null;
  if (((cur_cmd=letter)or(cur_cmd=other_char)) and has_semi_font(cur_chr))
       or  ((cur_cmd=char_num)and(cur_chr=Rtlang)) 
       or  (cur_cmd=semi_given) then
    begin  f:=cur_semif; if cur_cmd=semi_given then cur_cmd:=char_given; end
  else  f:=cur_latif;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1128] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if cur_tok=tab_token+"&" then
@y
if (cur_tok=tab_token+"&") or (cur_tok=tab_token+"&") then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1139]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1139
if every_math<>null then begin_token_list(every_math,every_math_text);
end
@y    1139==================
if every_math<>null then begin_token_list(every_math,every_math_text);
@<Insert |every_semi_math|@>;@/
end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1145]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1145
else  begin line_break(display_widow_penalty);@/
@y
else  begin LR_line_break(display_widow_penalty);@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1149]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if every_display<>null then begin_token_list(every_display,every_display_text);
@y
if every_display<>null then begin_token_list(every_display,every_display_text);
@<Insert |every_semi_display|@>;@/
@z
@x
    begin l:=hsize-abs(hang_indent);
    if hang_indent>0 then s:=hang_indent@+else s:=0;
@y
    begin 
      if R_to_L_vbox then
           if hang_indent>0 then begin l:=hsize-hang_indent; s:=0; end
           else begin s:=-hang_indent; l:=hsize; end
      else begin l:=hsize-abs(hang_indent);
                 if hang_indent>0 then s:=hang_indent@+else s:=0; end;
@z
@x
  s:=mem[p-1].sc; l:=mem[p].sc;
@y
    s:=mem[p-1].sc; l:=mem[p].sc;
    if R_to_L_vbox then if s > 0 then s := 0 else s:=-s;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1151]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1151
@d fam_in_range==((cur_fam>=0)and(cur_fam<16))

@<Declare act...@>=
@y
\pTeXchg{Using |dig_fam| for semitic digits in math and reporting illegal
 semitic characters.}
@d digfam_in_range==((dig_fam>=0)and(dig_fam<16))
@d fam_in_range==((cur_fam>=0)and(cur_fam<16))

@<Declare act...@>=
@<Declare |report_math_illegal_case|@>;@/
@#
@z
@x
letter,other_char,char_given: begin c:=ho(math_code(cur_chr));
    if c=@'100000 then
      begin @<Treat |cur_chr| as an active character@>;
      goto restart;
      end;
    end;
char_num: begin scan_char_num; cur_chr:=cur_val; cur_cmd:=char_given;
  goto reswitch;
  end;
@y    1151===================
letter,other_char,char_given,semi_given: begin 
    if ((cur_cmd = semi_given) or 
       (is_semi_char(cur_chr) and (cur_cmd <> char_given))) then
       begin report_math_illegal_case(false); goto restart; end;
    c:=ho(math_code(cur_chr));
    if c=@'100000 then
       begin @<Treat |cur_chr| as an active character@>; goto restart; end;
    end;
char_num:
  if cur_chr=Lftlang then begin scan_char_num; cur_chr:=cur_val;
          cur_cmd:=char_given; goto reswitch; end
  else begin scan_char_num; cur_chr:=cur_val;
          report_math_illegal_case(false); goto restart; end;
@z
@x
if (c>=var_code)and fam_in_range then fam(p):=cur_fam
@y
if (c>digvar_code)and digfam_in_range then fam(p):=dig_fam
else if (c>=var_code)and fam_in_range then fam(p):=cur_fam
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1154]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1154
mmode+letter,mmode+other_char,mmode+char_given:
  set_math_char(ho(math_code(cur_chr)));
mmode+char_num: begin scan_char_num; cur_chr:=cur_val;
  set_math_char(ho(math_code(cur_chr)));
  end;
@y    1154===================
mmode+letter,mmode+other_char: if not is_semi_char(cur_chr) then
    set_math_char(ho(math_code(cur_chr)))
  else report_math_illegal_case(true);
mmode+char_given: set_math_char(ho(math_code(cur_chr)));
mmode+semi_given: report_math_illegal_case(true);
mmode+char_num: if cur_chr<>Lftlang then report_math_illegal_case(true)
                else  begin scan_char_num; cur_chr:=cur_val;
                            set_math_char(ho(math_code(cur_chr))) end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1155]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1155
begin if c>=@'100000 then
@y
begin if c=@'100000 then
@z
@x
  if c>=var_code then
    begin if fam_in_range then fam(nucleus(p)):=cur_fam;
@y
  if c>=var_code then
    begin if (c>digvar_code)and digfam_in_range then fam(nucleus(p)):=dig_fam
    else if fam_in_range then fam(nucleus(p)):=cur_fam;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1160]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  letter,other_char: cur_val:=del_code(cur_chr);
@y
  letter,other_char: if is_semi_char(cur_chr) then cur_val:=-1
                   else cur_val:=del_code(cur_chr);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1165]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x using dig_fam
if (cur_val>=var_code)and fam_in_range then fam(accent_chr(tail)):=cur_fam
else fam(accent_chr(tail)):=(cur_val div 256) mod 16;
@y
if (cur_val>digvar_code)and digfam_in_range then fam(accent_chr(tail)):=dig_fam
else if (cur_val>=var_code)and fam_in_range then fam(accent_chr(tail)):=cur_fam
else fam(accent_chr(tail)):=(cur_val div 256) mod 16;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1196]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x |after_math|
cur_mlist:=p; cur_style:=text_style; mlist_penalties:=(mode>0); mlist_to_hlist;
link(tail):=link(temp_head);
while link(tail)<>null do tail:=link(tail);
@y    1196==================
@<Append a |bgn_L| to the tail of the current mlist@>;
cur_mlist:=p; cur_style:=text_style; 
mlist_penalties:=(mode>0); mlist_to_hlist;
link(tail):=link(temp_head);
while link(tail)<>null do tail:=link(tail);
@<Append an |end_L| to the tail of the current mlist@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1200]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x implementing |after_every_display| primitive
@<Scan an optional space@>;
if nest_ptr=1 then build_page;
@y
emit_par_LR;@/
@<Scan an optional space@>;
if nest_ptr=1 then build_page;
@<Insert |after_every_display|@>;@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  [48.1203] @<Append the glue or equation number preceding the display@>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  MUST BE CHECKED --> subtype(a):=left_justify;
if l and(e=0) then {it follows that |type(a)=hlist_node|}
  begin shift_amount(a):=s; append_to_vlist(a);
  tail_append(new_penalty(inf_penalty));
@y
if l and(e=0) then {it follows that |type(a)=hlist_node|}
  begin shift_amount(a):=s; append_to_vlist(a);
   subtype(a):=left_justify; {the equation number should be left justified}
   tail_append(new_penalty(inf_penalty));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1204] @<Append the display and perhaps also the equation number@>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%INSTEAD OF USING REFLECT COMMANDS I WANT TO RE_ORGANIZE THE DVI FILE IN PLACE
@x    1204
shift_amount(b):=s+d; append_to_vlist(b)
@y    1204==================
shift_amount(b):=s+d; append_to_vlist(b);
subtype(b):=left_justify {formula are always left justify }
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [48.1205]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  shift_amount(a):=s+z-width(a);
  append_to_vlist(a);
@y
  shift_amount(a):=s+z-width(a); append_to_vlist(a); subtype(a):=left_justify;
    {the equation number should be right justified, but the |shift_amount|
     has been set to do the job} 
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1210] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Adding to Big switch of main control
@x    1210
any_mode(set_interaction):prefixed_command;
@y    1210==================
any_mode(LR_setting),
any_mode(switch_font),
any_mode(let_name),
any_mode(set_interaction):prefixed_command;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1212] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
print_cmd_chr(cur_cmd,cur_chr); print_char("'");
@y
print_cmd_chr(cur_cmd,cur_chr); L_or_S(print_char("'"))(print("» بکار ببرید"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1213] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin print_err("You can't use `"); print_esc("long"); print("' or `");
@y
  begin LorRprt_err("You can't use `","شما نمیبایست از «");
  print_esc("long"); print("' or `");
@z
@x
  print_cmd_chr(cur_cmd,cur_chr); print_char("'");
@y
  print_cmd_chr(cur_cmd,cur_chr);
  L_or_S(print_char("'"))(print("» استفاده کنید"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1215] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Declare subprocedures for |prefixed_command|@>=
procedure get_r_token;
@y
@<Declare subprocedures for |prefixed_command|@>=
@<Declare \pTeX{} subprocedures for |prefixed_command|@>@/
procedure get_r_token;
@z
@x
until cur_tok<>space_token;
@y
until (cur_tok<>space_token) and (cur_tok<>semi_space_token);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1217]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1217
set_font: define(cur_font_loc,data,cur_chr);
@y    1217=================
set_font: begin define(cur_font_loc,data,cur_chr);
    if is_semi_font (cur_chr) then define(cur_semif_loc,data,cur_chr)
    else define(cur_latif_loc,data,cur_chr); end;
switch_font: begin if (cur_chr<>0) and has_twin_font (cur_semif) then
     begin cur_chr:=fontwin[cur_semif]; define(cur_semif_loc,data,cur_chr); end
     else cur_chr := cur_semif; define(cur_font_loc,data,cur_chr); end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1221] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    if cur_tok=other_token+"=" then
@y
    if cur_eq_other("=") then
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1222]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1222
@d toks_def_code=6 {|shorthand_def| for \.{\\toksdef}}
@y    1222=================
@d toks_def_code=6 {|shorthand_def| for \.{\\toksdef}}
@d semi_char_def_code=7 {|shorthand_def| for \.{\\semichardef}}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1222]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1222
primitive("toksdef",shorthand_def,toks_def_code);@/
@!@:toks_def_}{\.{\\toksdef} primitive@>
@y    1222=================
primitive("toksdef",shorthand_def,toks_def_code);@/
@!@:toks_def_}{\.{\\toksdef} primitive@>
primitive("semichardef",shorthand_def,semi_char_def_code);@/
@!@:semi_char_def_}{\.{\\semichardef} primitive@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1223] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  othercases print_esc("toksdef")
  endcases;
char_given: begin print_esc("char"); print_hex(chr_code);
  end;
math_given: begin print_esc("mathchar"); print_hex(chr_code);
@y
  toks_def_code: print_esc("toksdef");
  othercases print_esc("semichardef");
  endcases;
semi_given: begin print_esc("semichar");
  L_or_S(print_hex(chr_code))(print_int(chr_code));
  end;
char_given: begin print_esc("char");
  L_or_S(print_hex(chr_code))(print_int(chr_code));
  end;
math_given: begin print_esc("mathchar");
  L_or_S(print_hex(chr_code))(print_int(chr_code));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1224]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1224
  char_def_code: begin scan_char_num; define(p,char_given,cur_val);
@y    1224=================
  semi_char_def_code: begin scan_char_num;
      define(p,semi_given,cur_val); end;
  char_def_code: begin scan_char_num; define(p,char_given,cur_val);
@z
@x
  othercases begin scan_eight_bit_int;
@y
  othercases begin if (n <> count_def_code) and (n <> dimen_def_code) then
                       scan_eight_bit_int
                   else scan_nine_bit_int;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1226] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
      info(q):=right_brace_token+"}";
      q:=get_avail; info(q):=left_brace_token+"{";
@y
      L_or_S(info(q):=right_brace_token+"}")(info(q):=right_brace_token+"}");
      q:=get_avail; 
      L_or_S(info(q):=left_brace_token+"{")(info(q):=left_brace_token+"{");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1230]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1230
@!@:cat_code_}{\.{\\catcode} primitive@>
@y    1230=================
@!@:cat_code_}{\.{\\catcode} primitive@>
primitive("lcode",def_code,locate_code_base);
@!@:locate_code_}{\.{\\lcode} primitive@>
primitive("accfactor",def_code,acc_factor_base);
@!@:acc_factor_}{\.{\\accfactor} primitive@>
primitive("eqchar",def_code,eq_char_base);@/
@!@:eqch_}{\.{\\eqchar} primitive@>
primitive("eqcharif",def_code,eq_charif_base);@/
@!@:eqif_}{\.{\\eqcharif} primitive@>
primitive("jattrib",def_code,join_attrib_base);
@!@:join_attrib_}{\.{\\jattrib} primitive@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1231] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  else print_esc("delcode");
@y
  else if chr_code=locate_code_base then print_esc("lcode")
  else if chr_code=acc_factor_base then print_esc("accfactor")
  else if chr_code=eq_char_base then print_esc("eqchar")
  else if chr_code=eq_charif_base then print_esc("eqcharif")
  else if chr_code=join_attrib_base then print_esc("jattrib")
  else print_esc("delcode");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1232] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    print_int(n);
@y
    print_int(n); or_S(print(" باشد"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1233]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1233
@ @<Let |n| be the largest...@>=
if cur_chr=cat_code_base then n:=max_char_code
else if cur_chr=math_code_base then n:=@'100000
@y    1233=================
@ 
\pTeXchg{Our new tables has different maximum values.}
@<Let |n| be the largest...@>=
if cur_chr=cat_code_base then n:=max_char_code
else if cur_chr=math_code_base then n:=@'110000
else @<Check semitic char tables@>@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1236] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else if scan_keyword("by") then do_nothing; {optional `\.{by}'}
@y
else if (scan_keyword("by")) or
        ((q=multiply) and (scan_keyword("در"))) or
        ((q=advance) and (scan_keyword("بقدر"))) or
        ((q=divide) and (scan_keyword("بر"))) then do_nothing;
  {optional `\.{by}'}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1237] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    print("' after "); print_cmd_chr(q,0);
@y
    print("' after "); print_cmd_chr(q,0); or_S(print(" بکار ببرید"));
@z
@x
p:=cur_chr; scan_eight_bit_int;
@y
p:=cur_chr; 
if (p <> int_val) and (p <> dimen_val) then scan_eight_bit_int
      else scan_nine_bit_int;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1244] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin print_err("Bad "); print_esc("prevgraf");
@y
 begin LorRprt_err("Bad ",""); print_esc("prevgraf"); or_S(print(" نامناسب"));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1251] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
hyph_data: if chr_code=1 then print_esc("patterns")
  else print_esc("hyphenation");
@y
hyph_data: if chr_code=1 then print_esc("patterns")
  else print_esc("hyphenation");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1253]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1253
assign_font_int: begin n:=cur_chr; scan_font_ident; f:=cur_val;
  scan_optional_equals; scan_int;
  if n=0 then hyphen_char[f]:=cur_val@+else skew_char[f]:=cur_val;
  end;
@y    1253===================
assign_font_int: begin n:=cur_chr; scan_font_ident;
  if n=3 then
    if is_semi_font (cur_val) then fontwin[cur_val]:=twin_tag
    else begin print_err("Invalid font identifier, ignored");
      help1("Latin fonts can't be converted to twin fonts.");
      error;
      end
  else begin f:=cur_val; scan_optional_equals;
    if n=2 then
      if is_latin_font (f) then
        begin print_err("Invalid font identifier, ignored.");
        help1("Latin fonts can't have twin fonts.");
        error;
        end
      else begin @<Get the next non-blank non-call token@>;
        back_input; scan_font_ident;
        if is_semi_font (cur_val) then
          begin fontwin[cur_val]:=twin_tag;
          fontwin[f]:=cur_val;
          end
        else begin print_err("Invalid font identifier, ignored.");
          help1("Latin fonts can't be twin fonts.");
          error;
          end;
        end
    else begin scan_int;
         if n=0 then hyphen_char[f]:=cur_val@+else skew_char[f]:=cur_val;
         end;
    end;
  end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1254]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1254
@!@:skew_char_}{\.{\\skewchar} primitive@>
@y    1254===================
@!@:skew_char_}{\.{\\skewchar} primitive@>
primitive("twinfont",assign_font_int,2);
@!@:twin_font_}{\.{\\twinfont} primitive@>
primitive("maketwin",assign_font_int,3);
@!@:make_twin_}{\.{\\maketwin} primitive@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1255] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  else print_esc("skewchar");
@y
  else if chr_code=1 then print_esc("skewchar")
  else if chr_code=2 then print_esc("twinfont")
  else print_esc("maketwin");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1256]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1256
def_font: new_font(a);
@y    1256===================
def_font: if cur_chr>Rtlang then
  begin print_err("Improper use of `\activefont', ignored");
  help3("Control sequence `\activefont' is only for inspection,")@/
  ("not for font defining. I deleted your command.")@/
  ("If you really want to define a font, just type `I\font' or `I\semifont'.");
  error;
  end
else if cur_chr=Lftlang then new_font(a) else new_semi_font(a);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1257] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Declare subprocedures for |prefixed_command|@>=
procedure new_font(@!a:small_number);
@y
@ @<Declare subprocedures for |prefixed_command|@>=
@<Declare \pTeX{} font procedures for |prefixed_command|@>@/
procedure new_font(@!a:small_number);
@z
@x
f:=read_font_info(u,cur_name,cur_area,s);
@y
f:=read_font_info(u,cur_name,cur_area,s); fontwin[f]:=null_font;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1261] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
set_font:begin print("select font "); slow_print(font_name[chr_code]);
@y
switch_font:begin  
  if cur_chr <> 0 then print("switch twin font ")
                  else print("switch base font ");
  slow_print(font_name[chr_code]);
  if font_size[chr_code]<>font_dsize[chr_code] then
    begin print(" at "); print_scaled(font_size[chr_code]); print("pt");
    end;
  end;
set_font:begin if is_latin_font (chr_code) then 
  print("select latin font ")
  else if is_twin_font (chr_code) then 
      print("select twin semitic font ")
    else print("select main semitic font ");
  slow_print(font_name[chr_code]);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1272]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    
primitive("openin",in_stream,1);
@!@:open_in_}{\.{\\openin} primitive@>
@y
primitive("openin",in_stream,L_to_R);
@!@:open_in_}{\.{\\openin} primitive@>
primitive("openinR",in_stream,R_to_L);
@!@:open_in_R_}{\.{\\openinR} primitive@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1273] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  else print_esc("openin");
@y
  else if chr_code=L_to_R then print_esc("openin")
    else print_esc("openinR");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1275] a_open_in of \read file needs path specifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    
var c:0..1; {1 for \.{\\openin}, 0 for \.{\\closein}}
@y
var c:0..R_to_L; {1 for \.{\\openin}, 0 for \.{\\closein}}
@z
@x
  if a_open_in(read_file[n]) then read_open[n]:=just_open;
@y
  if a_open_in(read_file[n],read_path_spec) then 
    begin read_open[n]:=just_open; read_file_direction[n]:=c; end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1278] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x
message: if chr_code=0 then print_esc("message")
  else print_esc("errmessage");
 @y
message: if chr_code=0 then print_esc("message")
  else print_esc("errmessage");
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1295] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
long_call: print_esc("long macro");
outer_call: print_esc("outer macro");
long_outer_call: begin print_esc("long"); print_esc("outer macro");
  end;
end_template: print_esc("outer endtemplate");
@y
long_call:
  L_or_S(print_esc("long macro"))(print("ماکروی "); print_esc("بلند"));
outer_call:
  L_or_S(print_esc("outer macro"))(print("ماکروی "); print_esc("برونی"));
long_outer_call: 
  begin L_or_S(print_esc("long"); print_esc("outer macro"))
  (print("ماکروی "); print_esc("بلند"); print_esc("برونی")); 
  end;
end_template: 
  L_or_S(print_esc("outer endtemplate"))
  (print("پایان‌الگوی "); print_esc("برونی")); 
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1302] Eliminate unused variable w in |store_fmt_file|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!x: integer; {something to dump}
@!w: four_quarters; {four ASCII codes}
@y
@!x: integer; {something to dump}
@!saved_lang:language_type; {the language of \TeX\ messages.}
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1303] Eliminate unused variable w in |load_fmt_file|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x wterm_ln --> bwterm_ln
  wterm_ln('---! Must increase the ',#);
@y
  bwterm_ln('---! Must increase the ',#);
@z
@x
@!x: integer; {something undumped}
@!w: four_quarters; {four ASCII codes}
@y
@!x: integer; {something undumped}
@z
@x wterm_ln --> bwterm_ln
  wterm_ln('(Fatal format file error; I''m stymied)');
@y
  bwterm_ln('(Fatal format file error; I''m stymied)');
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.passim] Fix reading and writing fmt_file for C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x       1305
@d dump_wd(#)==begin fmt_file^:=#; put(fmt_file);@+end
@d dump_int(#)==begin fmt_file^.int:=#; put(fmt_file);@+end
@d dump_hh(#)==begin fmt_file^.hh:=#; put(fmt_file);@+end
@d dump_qqqq(#)==begin fmt_file^.qqqq:=#; put(fmt_file);@+end
@y       1305
@d dump_wd(#)==put_fmt_word(#)
@d dump_int(#)==put_fmt_int(#)
@d dump_hh(#)==put_fmt_hh(#)
@d dump_qqqq(#)==put_fmt_qqqq(#)
@z
@x       1306
@d undump_wd(#)==begin get(fmt_file); #:=fmt_file^;@+end
@d undump_int(#)==begin get(fmt_file); #:=fmt_file^.int;@+end
@d undump_hh(#)==begin get(fmt_file); #:=fmt_file^.hh;@+end
@d undump_qqqq(#)==begin get(fmt_file); #:=fmt_file^.qqqq;@+end
@y       1306
@d undump_wd(#)==get_fmt_word(#)
@d undump_int(#)==get_fmt_int(#)
@d undump_hh(#)==get_fmt_hh(#)
@d undump_qqqq(#)==get_fmt_qqqq(#)
@z
@x       1308
x:=fmt_file^.int;
@y       1308
get_fmt_int(x);                 {This is reading the first word of the fmt file}
@z
########################################################################
% Make dumping/undumping more efficient in C
########################################################################
@x        1309
for k:=0 to str_ptr do dump_int(str_start[k]);
k:=0;
while k+4<pool_ptr do
  begin dump_four_ASCII; k:=k+4;
  end;
k:=pool_ptr-4; dump_four_ASCII;
@y        1309
dump_things(str_start[0], str_ptr+1);
dump_things(str_pool[0], pool_ptr);
dump_things(alt_str[0], str_ptr+1);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1309] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
print_ln; print_int(str_ptr); print(" strings of total length ");
print_int(pool_ptr)
@y
print_ln; print_int(str_ptr);
print(" strings of total length ");
print_int(pool_ptr)
@z
########################################################################
% Make dumping/undumping more efficient in C
########################################################################
@x        1310
for k:=0 to str_ptr do undump(0)(pool_ptr)(str_start[k]);
k:=0;
while k+4<pool_ptr do
  begin undump_four_ASCII; k:=k+4;
  end;
k:=pool_ptr-4; undump_four_ASCII;
@y        1310
undump_things(str_start[0], str_ptr+1);
undump_things(str_pool[0], pool_ptr);
undump_things(alt_str[0], str_ptr+1);
@z
@x        1311
repeat for k:=p to q+1 do dump_wd(mem[k]);
x:=x+q+2-p; var_used:=var_used+q-p;
p:=q+node_size(q); q:=rlink(q);
until q=rover;
var_used:=var_used+lo_mem_max-p; dyn_used:=mem_end+1-hi_mem_min;@/
for k:=p to lo_mem_max do dump_wd(mem[k]);
x:=x+lo_mem_max+1-p;
dump_int(hi_mem_min); dump_int(avail);
for k:=hi_mem_min to mem_end do dump_wd(mem[k]);
@y        1311
repeat
 dump_things(mem[p], q+2-p);
x:=x+q+2-p; var_used:=var_used+q-p;
p:=q+node_size(q); q:=rlink(q);
until q=rover;
var_used:=var_used+lo_mem_max-p; dyn_used:=mem_end+1-hi_mem_min;@/
dump_things(mem[p], lo_mem_max+1-p);
x:=x+lo_mem_max+1-p;
dump_int(hi_mem_min); dump_int(avail);
dump_things(mem[hi_mem_min], mem_end+1-hi_mem_min);
@z
########################################################################
% Make dumping/undumping more efficient in C
########################################################################
@x        1312
repeat for k:=p to q+1 do undump_wd(mem[k]);
p:=q+node_size(q);
if (p>lo_mem_max)or((q>=rlink(q))and(rlink(q)<>rover)) then goto bad_fmt;
q:=rlink(q);
until q=rover;
for k:=p to lo_mem_max do undump_wd(mem[k]);
@y        1312
repeat
  undump_things(mem[p], q+2-p);
p:=q+node_size(q);
if (p>lo_mem_max)or((q>=rlink(q))and(rlink(q)<>rover)) then goto bad_fmt;
q:=rlink(q);
until q=rover;
undump_things(mem[p], lo_mem_max+1-p);
@z
@x        1312
for k:=hi_mem_min to mem_end do undump_wd(mem[k]);
@y        1312
undump_things(mem[hi_mem_min], mem_end+1-hi_mem_min);
@z
@x        1315       
while k<l do
  begin dump_wd(eqtb[k]); incr(k);
  end;
@y        1315
dump_things(eqtb[k], l-k);
@z
@x        1316
while k<l do
  begin dump_wd(eqtb[k]); incr(k);
  end;
@y        1316
dump_things(eqtb[k], l-k);
@z
@x        1317
for j:=k to k+x-1 do undump_wd(eqtb[j]);
@y        1317
undump_things(eqtb[k], x);
@z
@x        1318
for p:=hash_used+1 to undefined_control_sequence-1 do dump_hh(hash[p]);
@y        1318
dump_things(hash[hash_used+1], undefined_control_sequence-1-hash_used);
@z
########################################################################
% Make dumping/undumping more efficient in C
########################################################################
@x        1319
for p:=hash_used+1 to undefined_control_sequence-1 do undump_hh(hash[p]);
@y        1319
undump_things(hash[hash_used+1], undefined_control_sequence-1-hash_used);
@z
@x        1320
for k:=0 to fmem_ptr-1 do dump_wd(font_info[k]);
dump_int(font_ptr);
for k:=null_font to font_ptr do
  @<Dump the array info for internal font number |k|@>;
@y        1320
@<Dump the array info for internal font number |k|@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1320] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if font_ptr<>font_base+1 then print_char("s")
@y
if font_ptr<>font_base+1 then L_or(print_char("s"))
@z
########################################################################
% Make dumping/undumping more efficient in C
########################################################################
@x        1321
for k:=0 to fmem_ptr-1 do undump_wd(font_info[k]);
undump_size(font_base)(font_max)('font max')(font_ptr);
for k:=null_font to font_ptr do
  @<Undump the array info for internal font number |k|@>
@y        1321
@<Undump the array info for internal font number |k|@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1322] Writing font info (almost at end of dump stuff)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Knuth's code writes all the information relevant to a single font
% in the same section of the fmt file.  But it's a lot faster to
% write the arrays of information out, one whole array at a time.
% So that's the way we handle dumping and undumping font info.
@x     1322
@ @<Dump the array info for internal font number |k|@>=
begin dump_qqqq(font_check[k]);
dump_int(font_size[k]);
dump_int(font_dsize[k]);
dump_int(font_params[k]);@/
dump_int(hyphen_char[k]);
dump_int(skew_char[k]);@/
dump_int(font_name[k]);
dump_int(font_area[k]);@/
dump_int(font_bc[k]);
dump_int(font_ec[k]);@/
dump_int(char_base[k]);
dump_int(width_base[k]);
dump_int(height_base[k]);@/
dump_int(depth_base[k]);
dump_int(italic_base[k]);
dump_int(lig_kern_base[k]);@/
dump_int(kern_base[k]);
dump_int(exten_base[k]);
dump_int(param_base[k]);@/
dump_int(font_glue[k]);@/
dump_int(bchar_label[k]);
dump_int(font_bchar[k]);
dump_int(font_false_bchar[k]);@/
print_nl("\font"); print_esc(font_id_text(k)); print_char("=");
print_file_name(font_name[k],font_area[k],"");
if font_size[k]<>font_dsize[k] then
  begin print(" at "); print_scaled(font_size[k]); print("pt");
  end;
end
@y       1322================
@ @<Dump the array info for internal font number |k|@>=
begin dump_things(font_info[0], fmem_ptr);
dump_int(font_ptr);
dump_things(font_check[null_font], font_ptr+1-null_font);
dump_things(font_size[null_font], font_ptr+1-null_font);
dump_things(font_dsize[null_font], font_ptr+1-null_font);
dump_things(font_params[null_font], font_ptr+1-null_font);
dump_things(hyphen_char[null_font], font_ptr+1-null_font);
dump_things(skew_char[null_font], font_ptr+1-null_font);
dump_things(font_name[null_font], font_ptr+1-null_font);
dump_things(font_area[null_font], font_ptr+1-null_font);
dump_things(font_bc[null_font], font_ptr+1-null_font);
dump_things(font_ec[null_font], font_ptr+1-null_font);
dump_things(char_base[null_font], font_ptr+1-null_font);
dump_things(width_base[null_font], font_ptr+1-null_font);
dump_things(height_base[null_font], font_ptr+1-null_font);
dump_things(depth_base[null_font], font_ptr+1-null_font);
dump_things(italic_base[null_font], font_ptr+1-null_font);
dump_things(lig_kern_base[null_font], font_ptr+1-null_font);
dump_things(kern_base[null_font], font_ptr+1-null_font);
dump_things(exten_base[null_font], font_ptr+1-null_font);
dump_things(param_base[null_font], font_ptr+1-null_font);
dump_things(font_glue[null_font], font_ptr+1-null_font);
dump_things(bchar_label[null_font], font_ptr+1-null_font);
dump_things(font_bchar[null_font], font_ptr+1-null_font);
dump_things(font_false_bchar[null_font], font_ptr+1-null_font);
dump_things(fontwin[null_font], font_ptr+1-null_font);
dump_things(font_mid_rule[null_font], font_ptr+1-null_font);
for k:=null_font to font_ptr do
 begin
  print_nl("\font"); print_esc(font_id_text(k)); print_char("=");
  print_file_name(font_name[k],font_area[k],"");
  if font_size[k]<>font_dsize[k] then begin
    print(" at "); print_scaled(font_size[k]);print("pt");
    end;
 end;
end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1323] Reading font info for C (Nearly done with undump stuff)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1323
@ @<Undump the array info for internal font number |k|@>=
begin undump_qqqq(font_check[k]);@/
undump_int(font_size[k]);
undump_int(font_dsize[k]);
undump(min_halfword)(max_halfword)(font_params[k]);@/
undump_int(hyphen_char[k]);
undump_int(skew_char[k]);@/
undump(0)(str_ptr)(font_name[k]);
undump(0)(str_ptr)(font_area[k]);@/
undump(0)(255)(font_bc[k]);
undump(0)(255)(font_ec[k]);@/
undump_int(char_base[k]);
undump_int(width_base[k]);
undump_int(height_base[k]);@/
undump_int(depth_base[k]);
undump_int(italic_base[k]);
undump_int(lig_kern_base[k]);@/
undump_int(kern_base[k]);
undump_int(exten_base[k]);
undump_int(param_base[k]);@/
undump(min_halfword)(lo_mem_max)(font_glue[k]);@/
undump(0)(fmem_ptr-1)(bchar_label[k]);
undump(min_quarterword)(non_char)(font_bchar[k]);
undump(min_quarterword)(non_char)(font_false_bchar[k]);
end
@y       1323===========
@  The way this is done in C makes the reference to
the internal font number meaningless, but putting the code
here preserves the association with the WEB modules.

@<Undump the array info for internal font number |k|@>=
begin undump_things(font_info[0], fmem_ptr);
undump_size(font_base)(font_max)('font max')(font_ptr);
undump_things(font_check[null_font], font_ptr+1-null_font);
undump_things(font_size[null_font], font_ptr+1-null_font);
undump_things(font_dsize[null_font], font_ptr+1-null_font);
undump_things(font_params[null_font], font_ptr+1-null_font);
undump_things(hyphen_char[null_font], font_ptr+1-null_font);
undump_things(skew_char[null_font], font_ptr+1-null_font);
undump_things(font_name[null_font], font_ptr+1-null_font);
undump_things(font_area[null_font], font_ptr+1-null_font);
undump_things(font_bc[null_font], font_ptr+1-null_font);
undump_things(font_ec[null_font], font_ptr+1-null_font);
undump_things(char_base[null_font], font_ptr+1-null_font);
undump_things(width_base[null_font], font_ptr+1-null_font);
undump_things(height_base[null_font], font_ptr+1-null_font);
undump_things(depth_base[null_font], font_ptr+1-null_font);
undump_things(italic_base[null_font], font_ptr+1-null_font);
undump_things(lig_kern_base[null_font], font_ptr+1-null_font);
undump_things(kern_base[null_font], font_ptr+1-null_font);
undump_things(exten_base[null_font], font_ptr+1-null_font);
undump_things(param_base[null_font], font_ptr+1-null_font);
undump_things(font_glue[null_font], font_ptr+1-null_font);
undump_things(bchar_label[null_font], font_ptr+1-null_font);
undump_things(font_bchar[null_font], font_ptr+1-null_font);
undump_things(font_false_bchar[null_font], font_ptr+1-null_font);
undump_things(fontwin[null_font], font_ptr+1-null_font);
undump_things(font_mid_rule[null_font], font_ptr+1-null_font);
end
@z
@x
print_ln; print_int(hyph_count); print(" hyphenation exception");
if hyph_count<>1 then print_char("s");
@y
print_ln; print_int(hyph_count); L_or_S(print(" hyphenation exception"); 
     if hyph_count<>1 then print_char("s"))
(if hyph_count<>1 then print(" استثنائات") else print(" استثناء");
 print(" تیره‌بندی"));
@z
@x       1324
for k:=0 to trie_max do dump_hh(trie[k]);
dump_int(trie_op_ptr);
for k:=1 to trie_op_ptr do
  begin dump_int(hyf_distance[k]);
  dump_int(hyf_num[k]);
  dump_int(hyf_next[k]);
  end;
@y       1324
dump_things(trie[0], trie_max+1);
dump_int(trie_op_ptr);
dump_things(hyf_distance[min_quarterword+1], trie_op_ptr-min_quarterword);
dump_things(hyf_num[min_quarterword+1], trie_op_ptr-min_quarterword);
dump_things(hyf_next[min_quarterword+1], trie_op_ptr-min_quarterword);
@z
@x
if trie_op_ptr<>1 then print_char("s");
@y
if trie_op_ptr<>1 then L_or(print_char("s"));
@z
@x       1325
for k:=0 to j do undump_hh(trie[k]);
@y
undump_things(trie[0], j+1);
@z
@x
for k:=1 to j do
  begin undump(0)(63)(hyf_distance[k]); {a |small_number|}
  undump(0)(63)(hyf_num[k]);
  undump(min_quarterword)(max_quarterword)(hyf_next[k]);
  end;
@y       1325
undump_things(hyf_distance[1], j);
undump_things(hyf_num[1], j);
undump_things(hyf_next[1], j);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1328] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
print(" (preloaded format="); print(job_name); print_char(" ");
print_int(year); print_char(".");
print_int(month); print_char("."); print_int(day); print_char(")");
@y
    saved_lang := cur_speech; cur_speech := Lftlang;
    print(" (preloaded format="); print(job_name); print_char(" ");
    print_int(year); print_char(".");
    print_int(month); print_char("."); print_int(day); print_char(")");
    cur_speech := saved_lang;
@z
@x
pack_job_name(format_extension);
@y
selector:=new_string;
    cur_speech := Rtlang;
    print(" (شکلبندی آماده="); print(jobname); print_char(" ");
    print_int(semi_day); print_char("٫"); print_int(semi_month); 
    print_char("٫"); print_int(semi_year mod 100); print_char(")");
    cur_speech := saved_lang;
    if interaction=batch_mode then selector:=log_only
    else selector:=term_and_log;
str_room(1);
k:=make_string;
alt_str [k] := -format_ident; alt_str [format_ident] := k;
pack_job_name(format_extension);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1332] uexit() call depends on `history'; procedure-ize main prog;
%       Also, add call to set_paths
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ Now this is really it: \TeX\ starts and ends here.

The initial test involving |ready_already| should be deleted if the
\PASCAL\ runtime system is smart enough to detect such a ``mistake.''
@y
@ Now this is really it: \TeX\ starts and ends here.

Use the value of |history| to determine what exit-code to use.  We use
1 if |history <> spotless| and 0 otherwise.
@z
@x
@p begin @!{|start_here|}
history:=fatal_error_stop; {in case we quit during initialization}
t_open_out; {open the terminal for output}
if ready_already=314159 then goto start_of_TEX;
@y
@p procedure tex_body(speech:language_type;direction:direction_type);
label @<Labels in the outer block@>@/
var bufindx:0..buf_size; {an index used in a for loop below}
@!virtex_ident:str_number;
begin @!{|start_here|}
history:=fatal_error_stop; {in case we quit during initialization}
rawprtflg:=0; eq_show:=false; LRsp:=null; SPCsp:=null; LJsp := null;
t_open_out; {open the terminal for output}
set_paths; {get default file paths from the Unix environment}
virtex_ident:=max_strings + 1;
if ready_already=314159 then goto start_of_TEX;
@z
@x wterm_ln --> bwterm_ln
  begin wterm_ln('Ouch---my internal constants have been clobbered!',
@y
  begin bwterm_ln('Ouch---my internal constants have been clobbered!',
@z
@x  set speech and direction if specified in command line
start_of_TEX: @<Initialize the output routines@>;
@y
start_of_TEX: 
if speech <> 0 then geq_define (cur_speech_loc,data,speech);
if direction <> 0 then begin
   geq_define (vbox_justify_loc,data,direction);
   geq_define (cur_direction_loc,data,direction); end;
@<Reset directinal variables@>;
@<Initialize the output routines@>;
@z
@x
final_end: ready_already:=0;
end.
@y
final_end: do_final_end;
end {|tex_body|};
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1333] omit call to wake_up_terminal on normal termination
%           print new line before termination; switch to editor if nec.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
wake_up_terminal; @<Finish the \.{DVI} file@>;
if log_opened then
  begin wlog_cr; a_close(log_file); selector:=selector-2;
  if selector=term_only then
    begin print_nl("Transcript written on ");
@.Transcript written...@>
    slow_print(log_name); print_char(".");
    end;
  end;
end;
@y
@<Finish the \.{DVI} file@>;
if log_opened then
  begin cwlog_cr; @!stat check_last_options; tats
   a_close(log_file); selector:=selector-2;
  if selector=term_only then
    begin print_nl("Transcript written on ");
@.Transcript written...@>
    slow_print(log_name); L_or_S(print_char("."))(print(" نوشته‌شد."));
    end;
  end;
print_ln;
if (edit_name_start<>0) and (interaction>batch_mode) then
    
calledit(str_pool, edit_name_start, edit_name_length,
         edit_line, edit_direction);
end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1334] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Output statistics...@>=
if log_opened then
  begin wlog_ln(' ');
  wlog_ln('Here is how much of TeX''s memory',' you used:');
@.Here is how much...@>
  wlog(' ',str_ptr-init_str_ptr:1,' string');
  if str_ptr<>init_str_ptr+1 then wlog('s');
  wlog_ln(' out of ', max_strings-init_str_ptr:1);@/
  wlog_ln(' ',pool_ptr-init_pool_ptr:1,' string characters out of ',
    pool_size-init_pool_ptr:1);@/
  wlog_ln(' ',lo_mem_max-mem_min+mem_end-hi_mem_min+2:1,@|
    ' words of memory out of ',mem_end+1-mem_min:1);@/
  wlog_ln(' ',cs_count:1,' multiletter control sequences out of ',
    hash_size:1);@/
  wlog(' ',fmem_ptr:1,' words of font info for ',
    font_ptr-font_base:1,' font');
  if font_ptr<>font_base+1 then wlog('s');
  wlog_ln(', out of ',font_mem_size:1,' for ',font_max-font_base:1);@/
  wlog(' ',hyph_count:1,' hyphenation exception');
  if hyph_count<>1 then wlog('s');
  wlog_ln(' out of ',hyph_size:1);@/
  wlog_ln(' ',max_in_stack:1,'i,',max_nest_stack:1,'n,',@|
    max_param_stack:1,'p,',@|
    max_buf_stack+1:1,'b,',@|
    max_save_stack+6:1,'s stack positions out of ',@|
    stack_size:1,'i,',
    nest_size:1,'n,',
    param_size:1,'p,',
    buf_size:1,'b,',
    save_size:1,'s');
  end
@y
@<Output statistics...@>=
if log_opened then
if latin_speech then begin bwlog_ln(' ');
  bwlog_ln('Here is how much of TeX''s memory',' you used:');
@.Here is how much...@>
  bwlog_ln(' ',str_ptr-init_str_ptr:1,' string');
  if str_ptr<>init_str_ptr+1 then bwlog_ln('s');
  bwlog_ln(' out of ', max_strings-init_str_ptr:1);@/
  bwlog_ln(' ',pool_ptr-init_pool_ptr:1,' string characters out of ',
    pool_size-init_pool_ptr:1);@/
  bwlog_ln(' ',lo_mem_max-mem_min+mem_end-hi_mem_min+2:1,@|
    ' words of memory out of ',mem_end+1-mem_min:1);@/
  bwlog_ln(' ',cs_count:1,' multiletter control sequences out of ',
    hash_size:1);@/
  bwlog_ln(' ',fmem_ptr:1,' words of font info for ',
    font_ptr-font_base:1,' font');
  if font_ptr<>font_base+1 then bwlog_ln('s');
  bwlog_ln(', out of ',font_mem_size:1,' for ',font_max-font_base:1);@/
  bwlog_ln(' ',hyph_count:1,' hyphenation exception');
  if hyph_count<>1 then bwlog_ln('s');
  bwlog_ln(' out of ',hyph_size:1);@/
  bwlog_ln(' ',max_in_stack:1,'i,',max_nest_stack:1,'n,',@|
    max_param_stack:1,'p,',@|
    max_buf_stack+1:1,'b,',@|
    max_save_stack+6:1,'s stack positions out of ',@|
    stack_size:1,'i,',
    nest_size:1,'n,',
    param_size:1,'p,',
    buf_size:1,'b,',
    save_size:1,'s');
  end
else begin k:=selector; selector:=log_only;
  print_ln; print("مقدار مصرف شما از حافظه TeX-پارسی عبارتست از: "); print_ln;
@.Here is how much...@>
  print_char(" "); print_int(str_ptr-init_str_ptr); print(" رشته");
  print("، از "); print_int(max_strings-init_str_ptr); print_ln;
  print_char(" "); print_int(pool_ptr-init_pool_ptr);
  print(" رشته نویسه‌ای، از "); print_int(pool_size-init_pool_ptr); print_ln;
  print_char(" "); print_int(lo_mem_max-mem_min+mem_end-hi_mem_min+2);
  print(" خانه حافظه، از "); print_int(mem_end+1-mem_min); print_ln;
  print_char(" "); print_int(cs_count);
  print(" واژه کنترلی چندحرفی، از "); print_int(hash_size); print_ln;
  print_char(" "); print_int(fmem_ptr);
  print(" خانه از اطلاعات قلم‌ها برای "); print_int(font_ptr-font_base);
  print(" قلم، از "); print_int(font_mem_size);
  print(" برای "); print_int(font_max-font_base); print_ln;
  print_char(" "); print_int(hyph_count);
  if hyph_count<>1 then print(" استثنائات") else print(" استثناء");
  print(" تیره‌بندی از "); print_int(hyph_size); print_ln;
  print_char(" "); print_int(max_in_stack); print("آی،");
  print_int(max_nest_stack); print("ان،");
  print_int(max_param_stack); print("پی،");
  print_int(max_buf_stack+1); print("بی،");
  print_int(max_save_stack+6); print("اس خانه پشته از ");
  print_int(stack_size); print("آی،");
  print_int(nest_size); print("ان،");
  print_int(param_size); print("پی،");
  print_int(buf_size); print("بی،");
  print_int(save_size); print("اس"); print_ln;
  selector:=k; 
  end
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1335] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print_int(cur_level-level_one); print_char(")");
@y
  print_int(cur_level-level_one);
  L_or_S(print_char(")"))(print(" بوقوع پیوست)"));
@z
@x
  print_nl("(\dump is performed only by INITEX)"); return;
@y
  print_nl("(\dump is performed only by INITEX)");
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1337]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x 
  while (loc<limit)and(buffer[loc]=" ") do incr(loc);
@y 
  while (loc<limit)and((buffer[loc]=" ")or(buffer[loc]=" ")) do incr(loc);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1337]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    
if (loc<limit)and(cat_code(buffer[loc])<>escape) then start_input;
@y
if speech <> 0 then geq_define (cur_speech_loc,data,speech);
if direction <> 0 then begin
   geq_define (vbox_justify_loc,data,direction);
   geq_define (cur_direction_loc,data,direction); end;
@<Reset directinal variables@>;
if virtex_ident=0 then
   begin print(banner); print_ln;
         slow_print(format_ident); print_ln;
         update_terminal;
   end;
if (loc<limit)and(cat_code(buffer[loc])<>escape) then 
  begin direction_stack[in_open+1]:=cur_direction; start_input;
  end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [52.1338] Core-dump in debugging mode on 0 input
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% In Unix, it's not possible to switch into the debugger while a program
% is running.  The best approximation is to do a core dump, then run
% the debugger on it later.
@x
@d breakpoint=888 {place where a breakpoint is desirable}
@y
@d breakpoint=888 {place where a breakpoint is desirable}
@d end_debug==end_term_IO; cur_speech:=sl; cur_direction:=sd
@z
@x |debug_help|
begin loop begin wake_up_terminal;
@y
@!sl:language_type;
@!sd:direction_type;
begin begin_term_IO; sl:=cur_speech; sd:=cur_direction;
      cur_speech := Lftlang; cur_direction := L_to_R;
 loop begin wake_up_terminal;
@z
@x
  read(term_in,m);
  if m<0 then return
  else if m=0 then
    begin goto breakpoint;@\ {go to every label at least once}
    breakpoint: m:=0; @{'BREAKPOINT'@}@\
    end
  else  begin read(term_in,n);
@y
  read_int(term_in,m);
  if m<0 then begin read_ln(term_in); end_debug; return; end
  else if m=0 then dump_core {Do something to cause a core dump}
  else begin read_int(term_in,n); term_offset:=0;
          {the user's line ended with \<\rm return>}
@z
@x
exit:end;
@y
exit: end_debug; end;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [52.1339] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
13: begin read(term_in,l); print_cmd_chr(n,l);
@y
13: begin read_int(term_in,l);
  term_offset:=0; {the user's line ended with \<\rm return>}
  print_cmd_chr(n,l);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1341]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    
@d write_node=1 {|subtype| in whatsits that represent things to \.{\\write}}
@d close_node=2 {|subtype| in whatsits that represent streams to \.{\\closeout}}
@d special_node=3 {|subtype| in whatsits that represent \.{\\special} things}
@d language_node=4 {|subtype| in whatsits that change the current language}
@y
@d open_R_node=1 {|subtype| in whatsits that represent files to \.{\\openoutR}}
@d write_node=2 {|subtype| in whatsits that represent things to \.{\\write}}
@d eqwrite_node=3 {|subtype| that represent \.{\\eqwrite}}
@d close_node=4 {|subtype| in whatsits that represent streams to \.{\\closeout}}
@d special_node=5 {|subtype| in whatsits that represent \.{\\special} things}
@d language_node=9 {|subtype| in whatsits that change the current language}
@/
@z ATTENSION: any change may affect |LR_node| and |immediate_code| definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1342]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 @x     
@!write_open:array[0..17] of boolean;
 @y
 @!write_open:array[0..17] of boolean;
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1344]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x   
@d immediate_code=4 {command modifier for \.{\\immediate}}
@d set_language_code=5 {command modifier for \.{\\setlanguage}}
@y
@d beginspecial_node=6 {|subtype| in whatsits that represent \.{\\beginspecial}}
@d endspecial_node=7 {|subtype| in whatsits that represent \.{\\endspecial}}
@d LR_node=8 {|subtypes| in whatsits that represent \beginL, etc.}
@d immediate_code=9 {command modifier for \.{\\immediate}}
@d set_language_code=10 {command modifier for \.{\\setlanguage}}
@z
 @x
@!@:open_out_}{\.{\\openout} primitive@>
 @y  
@!@:open_out_}{\.{\\openout} primitive@>
 @z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1346]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x    1346
extension: case chr_code of
  open_node:print_esc("openout");
@y    1346=====================
@<LR cmdchr@>@/
extension: case chr_code of
  open_node:print_esc("openout");
@<LR ext cmdchr@>@/
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1348]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  open_R_node, eqwrite_node
open_node:@<Implement \.{\\openout}@>;
write_node:@<Implement \.{\\write}@>;
@y
open_node,open_R_node:@<Implement \.{\\openout}@>;
eqwrite_node,write_node:@<Implement \.{\\write}@>;
@z
@x  beginspecial_node, endspecial_node
special_node:@<Implement \.{\\special}@>;
@y
special_node,beginspecial_node,endspecial_node:@<Implement \.{\\special}@>;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1354]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  special_switch
begin new_whatsit(special_node,write_node_size); write_stream(tail):=null;
p:=scan_toks(false,true); write_tokens(tail):=def_ref;
end
@y
begin i := cur_speech; j := cur_direction; k:=cur_chr;
if not eqspcial then begin cur_speech := Lftlang; cur_direction := L_to_R; 
                     end;
new_whatsit(k,write_node_size);
if k = endspecial_node then
     if is_open_SPC then begin
            p := info (SPCsp); pop_SPC;
            write_tokens(tail):=write_stream (p);
            add_token_ref (write_tokens(tail));
          end
     else begin print_err("Extra \endspecial, ignored");
      help1("\endspecial must be match with \beginspecial.");
      error; write_tokens(tail):=null;
      end
else begin p:=scan_toks(false,true); write_tokens(tail):=def_ref; end;
if k = beginspecial_node then begin
     q:=scan_toks(false,true); write_stream(tail):=def_ref; 
     push_SPC(tail);
    end
else write_stream(tail):=null;
cur_speech := i;  cur_direction := j;
end

@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1356]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  eqwrite_node
write_node:begin print_write_whatsit("write",p);
@y
eqwrite_node,write_node:begin 
    if subtype(p) = eqwrite_node then print_write_whatsit("eqwrite",p)
    else print_write_whatsit("write",p);
@z
@x  open_R_node, LR_node, beginspecial_node and endspecial_node
othercases print("whatsit?")
@y
@<Print LR |whatsit|@>@/
othercases print("whatsit?")
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1357]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  open_R_node
open_node: begin r:=get_node(open_node_size); words:=open_node_size;
@y
open_node,open_R_node:
  begin r:=get_node(open_node_size); words:=open_node_size;
@z
@x  eqwrite_node
write_node,special_node: begin r:=get_node(write_node_size);
@y
eqwrite_node,write_node,special_node,beginspecial_node,endspecial_node:
       begin r:=get_node(write_node_size);
     if subtype(p) = beginspecial_node then add_token_ref (write_stream(p));
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1357]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  LR_node
close_node,language_node: begin r:=get_node(small_node_size);
@y 
close_node,LR_node,language_node: begin r:=get_node(small_node_size);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1358]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  open_R_node, eqwrite_node, beginspecial_node and endspecial_node
open_node: free_node(p,open_node_size);
write_node,special_node: begin delete_token_ref(write_tokens(p));
@y
open_node,open_R_node: free_node(p,open_node_size);
eqwrite_node,write_node,special_node,beginspecial_node,endspecial_node:
   begin delete_token_ref(write_tokens(p));
    if subtype(p) = beginspecial_node then delete_token_ref(write_stream(p));
@z
@x  LR_node
close_node,language_node: free_node(p,small_node_size);
@y 
close_node,language_node,LR_node: free_node(p,small_node_size);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1360]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x 
@ @<Incorporate a whatsit node into an hbox@>=do_nothing
@y 
@ @<Incorporate a whatsit node into an hbox@>=
if subtype(p)=LR_node then @<Adjust the LR stack for the |hpack| routine@>
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1366]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x LR_node
@ @<Output the whatsit node |p| in an hlist@>=
out_what(p)
@y
@ @<Output the whatsit node |p| in an hlist@>=
if subtype(p)<>LR_node then out_what(p)
else @<Output a reflection instruction if the direction has changed@>
@z
@x |write_out|
token_show(def_ref); print_ln;
@y
eq_show:=(eqwrting or (subtype (p) = eqwrite_node));
 token_show(def_ref); eq_show:=false; print_ln;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1373]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x  open_R_node, eqwrite_node
open_node,write_node,close_node:@<Do some work that has been queued up
  for \.{\\write}@>;
special_node:special_out(p);
@y
open_node,open_R_node,write_node,eqwrite_node,close_node:
  @<Do some work that has been queued up for \.{\\write}@>;
beginspecial_node,endspecial_node,special_node:special_out(p);
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [53.1374]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x eqwrite_node
  if subtype(p)=write_node then write_out(p)
@y
  if (subtype(p)=write_node) or (subtype(p)=eqwrite_node) then write_out(p)
@z
@x  open_R_node  
      write_open[j]:=true;
@y
      write_open[j]:=true; 
      if subtype(p)=open_R_node then write_file_direction[j]:=R_to_L
      else write_file_direction[j]:=L_to_R;
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [54.1376] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
itself will get a new section number.
@^system dependencies@>
@y
itself will get a new section number.
@^system dependencies@>

@ Here is a temporary integer, used as a holder during reading and writing of
TFM files, and a temporary |memory_word|, used in reading/writing format
files.
Also, the variables used to hold ``switch-to-editor'' information.
@^<system dependencies@>

@<Glob...@>=
@!edit_name_start: pool_pointer;
@!edit_name_length,@!edit_line,@!tfm_temp: integer;

@ The |edit_name_start| will be set to point into |str_pool| somewhere after
its beginning if \TeX\ is supposed to switch to an editor on exit.

@<Set init...@>=
edit_name_start:=0;

@* \[55] \TeX-e-Parsi changes.
\beginRt{}
هر چند تغییرات \تک{} در سراسر برنامه اعمال شده است ولی، به منظور حفظ شمارهٔ
 بخشهای برنامهٔ اصلی، حتی‌الامکان تغییرات با عناوینی اعمال شده که در بخشهای بعدی
تعریف می‌شوند.
\endRt

@d LftTag=1  {should be |> normal < LRsw_max|}
@d RtTag=2  {should be |> normal < LRsw_max|}

@<Constants...@>=
@!Lftlang=LftTag; @/
@!Rtlang=RtTag;@/
@!L_to_R=LftTag;
@!R_to_L=RtTag;

@
@<\pTeX{} Types@>=
@!direction_type=L_to_R..R_to_L;@/
@!language_type=Lftlang..Rtlang;@/

@* \[56] \RLt{متن دوجهته}.
\beginRt{}
مجموعهٔ نویسه‌ها در \تک{} دارای  ۲۵۶ عضو است که در حالت عادی ۱۲۸تای آنها 
نویسه‌های راست به چپ فرض می‌شود.

برای نویسه‌های راست به چپ
 علاوه بر \.{\\کدرده}و \.{\\کدضریب‌فاصله}
سه ویژگی دیگر با عناوین \.{\\پیوندپذیری}، \.{\\ضریب‌اعراب} و
\.{\\کدمکان} تعریف شده است.
\endRt

@d ignorable=0
@d unjoinable=1
@d joinable=2

@<Initialize table entries...@>=
cat_code(" "):=spacer; cat_code("\"):=escape;
cat_code("٪"):=comment; cat_code("ـ‍"):=letter;
for k:="آ" to "ئ‍" do cat_code(k):=letter;
for k:=0 to 255 do
  begin join_attrib(k):=unjoinable; locate_code(k):=k;
  end;
locate_code("ا"):="ا"; locate_code("ع"):="ع";
locate_code("ع‍"):="ع‍"; locate_code("غ"):="غ";
locate_code("غ‍"):="غ‍";
locate_code("ه‍"):="ه‍"; locate_code("ی"):="ی";
join_attrib("ـ‍"):=ignorable;
k:="ب‍"; while k<"د" do begin join_attrib(k):=joinable; k:=k+2; end;
k:="س‍"; while k<"ل" do begin join_attrib(k):=joinable; k:=k+2; end;
join_attrib("ل‍"):=joinable; join_attrib("م‍"):=joinable;
join_attrib("ن‍"):=joinable; join_attrib("ه‍"):=joinable;
join_attrib("ه‍"):=joinable; join_attrib("ی‍"):=joinable;
join_attrib("ئ‍"):=joinable;
sf_code("."):=3000; {semitic `.'}

@
@<Check semitic char tables@>=
if cur_chr=join_attrib_base then n:=joinable
@
@<Reset last char params@>=
curchr_attrib:=unjoinable; acc_wd:=0; acc_ht:=0; acc_dp:=0; retain_acc:=false

@ انعطافپذیری مجموعهٔ نویسها.\par
For flexibility on various Farsi character sets,
  we fill |xchr|'s in external C routine that might be read 
  from an external file.

@<Use |setup_xchrs|@>=
setup_xchrs;

@* \[57] \RLt{نمایش دوزبانه}.
\beginRt{}
پیامهای \تک{} می‌تواند به دو زبان بیان شود. پیامها بر اساس 
دو متغیر که در آرایهٔ \اکویی‌تب{} تعریف شده‌اند به شرح زیر نمایش داده می‌شوند:
\تورفته
انتخاب نوع زبان بر اساس متغیر \کاراسپیچ{} که مقدار آن با 
    فرمانهای \.{\\لاتین} و \.{\\سمیتیک} عوض می‌شود.
\تورفته 
همچنین جهت نمایش پیامها، هم روی صفحهٔ نمایش و هم روی پروندهٔ کارنامه، بر اساس 
متغیر \کاردیر{} است که مقدار آن با فرمانهای \.{\\چپ‌براست} و \.{\\راست‌بچپ}
عوض می‌شود.
\endRt{}

@d latin_speech==(cur_speech=Lftlang)
@d semitic_speech==(cur_speech=Rtlang)
@#
@#
@d L_or_S(#)==@+if latin_speech then @+begin #; @+end else L_or_S_end
@d L_or_S_end(#)==@+begin #; @+end
@d L_or(#)==@+if latin_speech then @+begin #; @+end
@d or_S(#)==@+if semitic_speech then @+begin #; @+end

@<Constants...@>=
@!semi_blank=160; {character code for farsi blank }

@ \beginRt{}
متغیرهای زیر برای استفاده در روالهای ورودی از صفحه‌کلید و خروجی روی صفحه‌نمایش 
تعریف می‌شوند. مقدار آنها قبل از فراخوانی روالها برحسب متغیرهای تعریف شده در 
\اکویی‌تب{} تعیین می‌شود.
\endRt

@<Glob...@>=
@!left_or_right:direction_type; {for bi\_directional terminal I/O}
@!left_input:boolean; {for shifting input line in semitic mode }
@!edit_direction: direction_type; {the direction for invoking editor.}

@
@<Reset directinal variables@>=
left_or_right := cur_direction

@ \beginRt{}
اعداد در حالت راست به چپ از کم ارزشترین رقم نوشته می‌شوند 
حال آنکه در حالت چپ به راست به ترتیب عکس است.
\endRt
@<Print the |dig| array in approperiate direction@>=
  if latin_speech then begin
     while k>0 do
      begin decr(k);
       if dig[k]<10 then print_char("0"+dig[k])
       else print_char("A"-10+dig[k]);
     end; end
  else begin
  decr(k); for i:=0 to k do begin
      if dig[i]<10 then print_char("۰"+dig[i])
      else print_char("A"-10+dig[i]); end;
  end
@
@<Print two digit in approperiate direction@>=
  if latin_speech then 
    begin
      print_char("0"+(n div 10));
      print_char("0"+(n mod 10));
    end
  else
    begin
      print_char("0"+(n mod 10));
      print_char("0"+(n div 10));
    end
@
@<Redefine |print_scaled|@>=
procedure print_scaled(@!s:scaled); {prints scaled real, rounded to five
  digits}
var delta:scaled; {amount of allowable inaccuracy}
@!k,kk:0..23; {index to current digit}
@!ss:scaled;
begin
if latin_speech then print_scaled_Lft(s)@+else
begin
 if s<0 then
  begin print_char("-"); negate(s); {print the sign, if negative}
  end;
ss:=s div unity; 
s:=10*(s mod unity)+5; delta:=10; k:=0;
repeat if delta>unity then s:=s+@'100000-50000; {round the last digit}
    dig[k]:=s div unity; incr(k);
    s:=10*(s mod unity); delta:=delta*10;
until s<=delta;
for kk:=k-1 downto 0 do begin decr(k); print_char("۰"+dig[kk]); end;
        print_char("٫"); print_int(ss);
end;
end;
@* \[56] \RLt{رشته‌های جانشین}.
\beginRt{}
برای پیاده کردن رشته‌های جانشین آرایه‌ای به‌نام \آلت‌استی‌آر{} به موازات آرایهٔ 
\استی‌آراستارت{} تعریف می‌کنیم. 
و در آن شمارهٔ رشتهٔ جانشین را می‌نویسیم. اگر این شماره منفی باشد به معنی 
جانشین لاتین بودن 
آن است (یعنی رشتهٔ اصلی فارسی بوده است). 

به این ترتیب با این آرایه 
هم رشتهٔ جانشین معلوم می‌شود و هم مشخص می‌شود که رشتهٔ 
اصلی فارسی یا لاتین است.

برای نمایش رشته‌های جانشین لازم است موارد زیر در نظر گرفته شود:
\تورفته الف‌ـ‍ روالهای چاپ تودرتو هستند یعنی:
\توتورفته سطح اول: شامل روالهای \پرینت‌چر{} و \پرینت‌ان‌ال{} از سایر روالهای چاپ 
   استفاده نمی‌کنند.
\توتورفته سطح دوم: شامل روال \پرینت{} تنها از روالهای سطح اول استفاده می‌کند.
\توتورفته سطح سوم: سایر روالهای چاپ که هم از روالهای سطوح پایینتر و هم از 
     روالهای همسطح استفاده می‌کنند.

\تورفته ب‌ـ‍ در برخی موارد لازم می‌شود عین رشتهٔ داده شده، و نه جانشین آن، چاپ شود.
\تورفته ج‌ـ‍ باید کاربر امکان حذف جانشین‌یابی را داشته باشد.

پیاده‌سازی رشته‌های جانشین در شرایط فوق به‌ترتیب زیر است:
\تورفته ۱ـ‍ متغیری به‌نام \چاپ‌خام{} تعریف می‌کنیم و جانشین‌یابی را براساس مقدار صفر
   این متغیر انجام می‌دهیم.
\تورفته ۲ـ‍ در هرجایی که جانشین رشته انتخاب شد قبل از چاپ آن رشته مقدار متغیر 
فوق را یکی افزایش و پس از چاپ یکی کاهش می‌دهیم.

ماکروهای \اخام{} و \کخام{} عمل افزایش و کاهش را انجام می‌دهند.
\endRt

@d strequiv(#)==#:=get_streq (#)
@d pushprinteq==incr(rawprtflg)
@d popprinteq==decr(rawprtflg)

@<Glob...@>=
@!alt_str: array[str_number] of neg_max_strings..max_strings;
@!rawprtflg: small_number; {are we printing an equived string?}

@
@<Make the first 256...@>=;
for g:=0 to max_strings-1 do alt_str [g] := null;
rawprtflg:=0

@ Function |get_streq| return alternate string.
@<Define |get_streq|@>=
function get_streq (@!s:str_number):str_number; {get the equivalent of s}
var a,e:str_number;
begin
  a := s;
  if rawprtflg = 0 then begin
     e := alt_str [s];
     if latin_speech and (e < 0) then a := -e
     else if semitic_speech and (e > 0) then a := e;
  end;
  get_streq := a;
end;

@ 
@<Define |pprint|@>=
procedure pprint(@!s:integer); {prints equivalent string of |s|}
var j:pool_pointer; {current character code position}
begin 
if s > 255 then strequiv(s);
  pushprinteq;
    j:=str_start[s];
    while j<str_start[s+1] do
      begin print_char(so(str_pool[j])); incr(j);
      end;
  popprinteq;
end;

@ \beginRt{}
دو روال زیر که معادل \ال‌یااس{} است،
صرفاً به منظور کاستن از اندازهٔ برنامه تعریف شده است.
\endRt
@<Define |LorRprt| procedures@>=
procedure LorRprt(@!s1,s2:integer); {print strings |s1| or |s2|}
begin pushprinteq;
    if latin_speech then print (s1) else print (s2);
    popprinteq;
end;
@#
procedure LorRprt_err(@!s1,s2:integer);
begin if interaction=error_stop_mode then wake_up_terminal;
  if latin_speech then begin print_nl("! "); print(s1); end
  else begin print_nl("! "); print(s2); end;
end;
@* \[57] \RLt{ساختار دوجهته}.
\beginRt{}
برای پیاده کردن فرمانهای تعیین جهت، یعنی فرمانهای \.{\\شروع‌راست}، 
\.{\\پایان‌راست}،
\.{\\شروع‌چپ} و \.{\\پایان‌چپ}، که ابتدا و انتهای متون راست بچپ و چپ براست 
را مشخص می‌کنند، از ایدهٔ 
تغییرات پیشنهادی کنوت،  که در نشریهٔ \تاگ‌بوت{} 
 جلد هشتم شمارهٔ~۱ صفحهٔ~۱۴ الی~۲۵ به چاپ رسیده است، استفاده می‌کنیم.

تغییرات پیشنهادی کنوت به گونه‌ای است که برای چاپ، استفاده از برنامه‌های ویژه را
ایجاب می‌نماید. ولی شرکت داده‌کاوی ایران با ایجاد اصلاحات معین در 
نکات پیشنهادی کنوت، لزوم استفاده از برنامه‌های ویژه را حذف کرده است.

چون در بخشهایی از متن، خود \تک{} به‌طور خودکار این فرمانها
 را به متن می‌افزاید، به‌منظور سهولت پیگیری رفتار \تک{}، برای 
 این فرمانها یک پارامتر اضافی تعریف می‌کنیم که نشاندهندهٔ علت افزایش فرمان است.

انواع فرمانهایی که تعریف شده است عبارتند از:
\تورفته
|manLR|
فرمانهایی که به‌طور صریح توسط کاربر صادر شده است.
\تورفته
|autoerr|
فرمانهایی که بر اثر خطای فقدان توازن فرمانهای صریح اضافه شده است.
\تورفته
|autodir|
فرمانهایی که با تشخیص جهت متن اضافه شده است.
\تورفته
|autopar|
فرمانهایی که بر اثر شروع پاراگراف از راست اضافه شده است.
\تورفته
|autocol|
فرمانهایی که برای ستونهای جدول راست به چپ  اضافه شده است.
\تورفته
|manrbox|
فرمانهایی که برای فرمان \.{\\کادراست}  اضافه شده است.
\تورفته
|automath|
فرمانهایی که برای فرمولهای متن راست به چپ  اضافه شده است.

\endRt

@d bgn_L_code=1
@d bgn_R_code=2
@d end_LR_add=3

@d end_L_code=bgn_L_code+end_LR_add
@d end_R_code=bgn_R_code+end_LR_add

@d LR_bias=8
@d manLR=0
@d autoerr=1
@d autodir=2
@d autopar=3
@d autocol=4
@d manrbox=5
@d automath=6

@d dir_bgn_L==(autodir * LR_bias + bgn_L_code)
@d dir_bgn_R==(autodir * LR_bias + bgn_R_code)
@d err_end_L==(autoerr * LR_bias + end_L_code)
@d err_end_R==(autoerr * LR_bias + end_R_code)
@d par_bgn_R==(autopar * LR_bias + bgn_R_code)
@d col_bgn_R==(autocol * LR_bias + bgn_R_code)
@d col_end_R==(autocol * LR_bias + end_R_code)
@d col_bgn_L==(autocol * LR_bias + bgn_L_code)
@d col_end_L==(autocol * LR_bias + end_L_code)
@d box_bgn_R==(manrbox * LR_bias + bgn_R_code)
@d box_end_R==(manrbox * LR_bias + end_R_code)

@d LRcmd==type
@d LRsrc==subtype

@d LRend(#)==(#+end_LR_add)
@d LRbgn(#)==(#-end_LR_add)
@d is_end_LR(#)==(#>end_LR_add)
@d in_auto_LR==(stkLR_src=autodir)
@d auto_LRdir==(chrbit(cur_LR_swch,autoLR))
@d auto_LRfont==(chrbit(cur_LR_swch,autofont))
@d auto_LR_needed==((cur_LR_swch>manual) or (stkLR_cmd=bgn_R_code))

@d is_semi_char(#)==(issemichr(#) and auto_LR_needed)
@d has_semi_font(#)==(issemichr(#) and auto_LRfont)
@
@d stkLR==cur_list.LR_aux_field.hh.rh
@d stkLR_cmd==LRcmd(stkLR)
@d stkLR_src==LRsrc(stkLR)
@d stkLR_end==LRend(stkLR_cmd)
@<Set init...@>=
 stkLR:=null;
@
@<Initialize table entries...@>=
cur_LR_swch:=manual; eq_type(cur_LRswch_loc):=data;
vbox_justification:=0; LR_showswch:=7; { |eqchring| .. |eqnaming| }
LR_miscswch := 1;
eq_level(cur_LRswch_loc):=level_one;@/
vbox_justify:=L_to_R; eq_type(vbox_justify_loc):=data;
eq_level(vbox_justify_loc):=level_one;@/
@
@<LR cmdchr@>=
LR: begin case (chr_code mod LR_bias) of
  bgn_L_code: print_esc("beginL");
  bgn_R_code: print_esc("beginR");
  end_L_code: print_esc("endL");
  end_R_code: print_esc("endR");
  othercases print("!!LR command!!")
  endcases;
  case (chr_code div LR_bias) of
  manLR: print("manual");
  autoerr: print("autoerr");
  autodir: print("autodir");
  autopar: print("autopar");
  autocol: print("autocol");
  manrbox: print("manrbox");
  automath: print("automath");
  othercases print("!!LR source!!")
  endcases; end;
@
@<|LR| nest routines@>=
procedure show_LR(c,s:small_number);
begin cur_cmd:=LR; cur_chr:=c+s*LR_bias; show_cur_cmd_chr;
end;
@#
procedure pop_stkLR;
var p:pointer;
begin @!debug if stkLR = null then confusion("LR_pop_1");
              if link(stkLR) = null then confusion("LR_pop_2"); gubed
  if  tracing_commands > 1 then
     if stkLR_src>autoerr then show_LR(stkLR_end,stkLR_src);
  tail_append(end_LR(stkLR));
  p:=stkLR; stkLR:=link(stkLR); free_avail(p);
end;
@
@d emit_par_LR==if R_to_L_vbox then append_LR(par_bgn_R)
@<Insert |every_semi_par|@>=
if every_semi_par<>null then 
   begin_token_list(every_semi_par,every_semi_par_text)
@
@<Insert |every_semi_math|@>=
if every_semi_math<>null then 
  begin_token_list(every_semi_math,every_semi_math_text)
@
@<Insert |every_semi_display|@>=
if every_semi_display<>null then 
  begin_token_list(every_semi_display,every_semi_display_text)
@ Implementing |after_every_display| primitive.
@<Insert |after_every_display|@>=
if after_every_display<>null then 
   begin_token_list(after_every_display,after_every_display_text)
@
@<Test |auto_LR|@>=
if in_auto_LR then pop_stkLR;
   if (stkLR_src=manrbox) then append_LR (box_end_R)
@
@<Test |n=1|@>=
  if n=1 then append_LR(box_bgn_R);
@
@<insert matching |end_R_code| at end of column@>=
    if align_chr=Rtlang then begin
       if addRcmds then append_LR(col_end_R)
       else if addLcmds then append_LR(col_end_L); end
    else if addLcmdh then append_LR(col_end_L)
         else if addRcmdh then append_LR(col_end_R);
    if in_auto_LR then pop_stkLR
@
@<insert |begin_R_code| at begin of column@>=
   if align_chr=Rtlang then begin
      if addRcmds then append_LR (col_bgn_R)
      else if addLcmds then append_LR (col_bgn_L); end
   else if addLcmdh then append_LR (col_bgn_L)
        else if addRcmdh then append_LR (col_bgn_R); end

@
@d LR_command(#)==type(#+1) {the |LR_command|}
@d LR_source(#)==subtype(#+1) {|auto...| or |manLR|}
@d is_LR(#)==((type(#)=whatsit_node)and(subtype(#)=LR_node))
@d is_auto_LR(#)==(is_LR(#) and (LR_source(#)<>manLR))
@d whatsit_LR(#)==((not is_char_node(#))and is_LR(#))
@d is_bgn_LR(#)==(LR_command(#)<=end_LR_add)
@d end_LR(#)==new_LR(LRend(LRcmd(#)),LRsrc(#))
@d cmd_LR(#)==new_LR(LRcmd(#),LRsrc(#))
@d is_open_LR==(LRsp<>null)
@d LR_match_stk(#)==((is_open_LR)and(LRcmd(LRsp)=(LRbgn(LR_command(#)))))
@d LR_updt(#)==is_bgn_LR(#) then push_LR(#) else if LR_match_stk(#)
@d R_to_L_node(#)==((R_to_L_vbox and (subtype(#)=min_quarterword)) or
       (subtype(#)=right_justify))
@d is_open_SPC==(SPCsp<>null)
@d end_LJ(#)==new_LJ(info(#),true)
@d cmd_LJ(#)==new_LJ(info(#),false)
@d whatsit_LJ(#)==((type(#)=whatsit_node) and (subtype(#)>=beginspecial_node)
                   and (subtype(#)<=LR_node))  
@d is_bgn_LJ(#)==(((subtype(#)=LR_node) and is_bgn_LR(#)) or 
                  (subtype(#)=beginspecial_node))
@d is_end_LJ(#)==(((subtype(#)=LR_node) and
                   is_end_LR(LR_command(#)) and 
                   (subtype(info(LJsp))=LR_node) and
                   is_bgn_LR(info(LJsp)) and
                   (LRend(LR_command(info(LJsp)))=LR_command(#))
                  ) or ((subtype(#)=endspecial_node) and
                        (subtype(info(LJsp))=beginspecial_node)))
@d is_open_LJ==(LJsp<>null)

@<|re_organize| in |hlist_out|@>=
  while ((p<>null) and whatsit_LR(p)) do
    if is_bgn_LR(p) then
      if is_open_LR then p:=re_organize(p) else confusion("LRptr1")
    else confusion("LRptr2");
list_ptr(this_box):=p;
 q:=get_avail; saved_q:=q; link(q):=p

@
@<Cases of |main_control| that build...@>=
hmode+LR: append_LR (cur_chr);

@
@<Glob...@>=
@!LRsp: pointer; {stack of LR nodes in |re_organization|}

@ To appending |LR_nodes| to horizental list we call 
 |new_LR| procedure with parameter |c|, that implies |LR_command|,
 and |s|, which shows source of command,
 to create a |whatsit_node| with subtype |LR_node|.
The |push_LR| and |pop_LR| procedures
are used to checking or reorganizing LR nodes.

@<Declare functions needed for special kinds of nodes@>=
procedure push_LR(p:pointer);
var t:pointer;
begin t:=get_avail; info(t):=info(p+1); link(t):=LRsp; LRsp:=t;
end;
@#
procedure pop_LR;
var t:pointer; begin t:=LRsp; LRsp:=link(t); free_avail(t);
end;
@#
function new_LR(c,s: small_number): pointer;
var p: pointer;
begin p:=get_node(small_node_size); type(p):=whatsit_node; subtype(p):=LR_node;
  LR_command(p):=c; LR_source(p):=s; new_LR:=p;
end;

@
@<Append a |bgn_L| to the tail of the current mlist@>=
if auto_LR_needed then tail_append(new_LR(bgn_L_code, automath))

@
@<Append an |end_L| to the tail of the current mlist@>=
if auto_LR_needed then tail_append(new_LR(end_L_code, automath))

@ @<Flush the LR stack@>=while is_open_LR do pop_LR

@ @<Flush the LJ stack@>=@<Flush the LR stack@>; while is_open_LJ do pop_LJ

@ @<Adjust the LR stack based on LR nodes in this line@>=r:=link(temp_head);
while is_open_LJ do begin s:=cmd_LJ(LJsp); link(s):=r; r:=s; pop_LJ; end;
link(temp_head):=r; q:=r; while q<>cur_break(cur_p) do
  begin if not is_char_node(q) then if whatsit_LJ(q) then
     if is_bgn_LJ (q) then push_LJ (q)
     else if is_open_LJ then if is_end_LJ (q) then pop_LJ; q:=link(q); end

@
@<Insert LR nodes at the end of the current line@>=
if is_open_LJ then begin
 s:=temp_head; r:=link(s); while r<>q do begin s:=r; r:=link(s); end; r:=LJsp;
 while r<>null do begin link(s):=end_LJ(r); s:=link(s); r:=link(r); end;
 link(s):=q; end

@
@<Adjust the LR stack for the |hpack| routine@>=if LR_updt(p) then pop_LR
  else begin incr(LR_err); while link(q)<>p do q:=link(q);
             link(q):=link(p); free_node(p,small_node_size); p:=q; end

@
@<Check for LR anomalies at the end of |hpack|@>=
if is_open_LR then begin while link(q)<>null do q:=link(q);
  repeat link(q):=end_LR(LRsp); q:=link(q); LR_err:=LR_err+10000; pop_LR;
  until LRsp=null; end;
if LR_err>0 then begin print_ln;
  print_nl("\endL or \endR problem (");
  print_int(LR_err div 10000); print("missing, ");
  print_int(LR_err mod 10000); print(" extra");
  LR_err:=0; goto common_ending; end

@ 
@<Output a reflection instruction if the direction has changed@>=
  begin while link(q)<>p do q:=link(q);
  if is_bgn_LR(p) then
    if is_open_LR then link(q):=re_organize(p) else confusion("LRptr3")
  else confusion("LRptr4"); p:=q; end

@
@<Declare procedures needed in |hlist_out|, |vlist_out|@>=
function re_organize(p:pointer): pointer;
label done,done1,restart;
var q,r,t: pointer;
wrap:boolean;
begin wrap:=LR_command(p)<>LRcmd(LRsp);
push_LR (p);
q:=p; p:=link(p); free_node(q,small_node_size);
restart: q:=p; if q=null then confusion("reorganize1");
if whatsit_LR(q) then
  if is_bgn_LR(q) then begin p:=re_organize(q); goto restart; end
  else begin p:=link(q); r:=q; goto done1; end;
r:=link(q);
while r<>null do
  if whatsit_LR(r) then if is_bgn_LR(r) then r:=re_organize(r) else goto done
  else if wrap then begin t:=p; p:=r; r:=link(r); link(p):=t; end
       else begin link(q):=r; q:=r; r:=link(r); end; confusion("reorganize2");
done: link(q):=link(r);
done1:if not LR_match_stk(r) then confusion("reorganize3");
 re_organize:=p; free_node(r,small_node_size);
 pop_LR;
end;

@
@<Bidirectional procedures@>=
procedure LR_unbalance(c:small_number);
begin print_err("Unbalanced ");
if c=end_L_code then print_esc("endL") else print_esc("endR");
print(" command, ignored");
if c=end_L_code then begin
  help2("Your `\endL' command doesn't match any previous `\beginL' command.")@/
  ("Go ahead. I am going to ignore it."); end
else begin
  help2("Your `\endR' command doesn't match any previous `\beginR' command.")@/
  ("Go ahead. I am going to ignore it."); end; error;
end;
@#
procedure LR_unmatched(c:small_number);
begin print_err("Unmatched ");
if c=end_L_code then print_esc("endL") else print_esc("endR");
print(" command, corrected");
if c=end_L_code then begin
  help5("Your `\endL' command doesn't match any previous `\beginL' command.")@/
    ("I have replaced your errorenous `\endL' by a correct `\endR' command,")@/
    ("assuming that you meant to end your previous `\beginR'.")@/
    ("If you don't need it, just type `1' and my insertion will be deleted.")@/
    ("But make sure that your previous `\beginR' would be endded correctly.");
  end
else begin
  help5("Your `\endR' command doesn't match any previous `\beginR' command.")@/
    ("I have replaced your errorenous `\endR' by a correct `\endL' command,")@/
    ("assuming that you meant to end your previous `\beginL'.")@/
    ("If you don't need it, just type `1' and my insertion will be deleted.")@/
    ("But make sure that your previous `\beginL' would be endded correctly.");
  end;
if c=end_L_code then cur_tok:=cs_token_flag+frozen_end_R
else cur_tok:=cs_token_flag+frozen_end_L; ins_error;
end;
@#
procedure append_LR(c:small_number);
var p:pointer;
t:small_number;
begin if stkLR = null then confusion ("LR stack underflow");
  if in_auto_LR then pop_stkLR; t := c div LR_bias; c := c mod LR_bias;
  if is_end_LR (c) then
     if stkLR<>null then
          begin if c<>stkLR_end then LR_unmatched (c); pop_stkLR; end
     else LR_unbalance (c)
  else if (t<>autodir) or (c<>stkLR_cmd) then
      begin if tracing_commands>1 then if t>autodir then show_LR(c,t);
        tail_append(new_LR(c,t)); p:=get_avail; link(p):=stkLR;
        stkLR:=p; stkLR_cmd:=c; stkLR_src:=t; end;
end;
@#

@
@<Set |cur_box| justification@>=
    if R_to_L_vbox then subtype(cur_box):=right_justify
    else subtype(cur_box):=left_justify;
@
@<Set rule justification@>=
    if R_to_L_vbox then subtype(tail):=right_justify
    else subtype(tail):=left_justify
@
@<Check parargraph justification@>=
if R_to_L_par then
  begin if not R_to_L_vbox then
    eq_define(vbox_justify_loc,data,R_to_L);
  end
else if L_to_R_par then
  if not L_to_R_vbox then
     eq_define(vbox_justify_loc,data,L_to_R);
@<Reset last char params@>;@/

@
@<LR ship vars@>=
@!saved_lang:language_type; {the language of \TeX\ messages.}
@!t:pointer;
begin 
@!debug if is_open_LR then confusion (" LRsp in ship_out "); gubed
  t := new_LR (bgn_L_code, 0); push_LR (t); {at outer level}
  free_node (t, small_node_size);


@* \[63] \RLt{پردازش دوجهته}.
\beginRt{}
برای پردازش دوجهته لوازم زیر تعریف شده است:
\تورفته میانخط‌گذاری بر اساس پارامتر \ام‌رول‌اینیت{}، 
که در جدول \اکویی‌تب{} تعریف شده است، انجام می‌شود.
\تورفته چسبندگی حروف در متغیر \کاراتریب{} ثبت می‌شود.
\endRt
@<Glob...@>=
@!curchr_attrib:unjoinable..joinable;
@!acc_wd,@!acc_ht,@!acc_dp:integer;
@!retain_acc:boolean; { are we have to retain accented character dimensions }
@ \subtitle{Semitic main loop.}
@d adjust_charo(#)==#:=semichrin(locate_code(cur_chr))
@d adjust_char(#)==#:=locate_code(cur_chr); if is_not_dbl_font then 
                   #:=semichrin(#)
@d is_not_dbl_font==(not is_dbl_font(cur_font))
@d adjust_font(#)==fontadj:=false;
    if cat_code(semichrout(c))=letter then if curchr_attrib=joinable then
          if has_twin_font (#) then #:=fontwin[#]
@d adjust_fontn(#)==fontadj:=false;
    if cat_code(semichrout(c))=letter then if curchr_attrib=joinable then
               if is_dbl_font(#) then if c > 128 then c:=c-128
          else if has_twin_font (#) then #:=fontwin[#]
@d chk_font_adjusting(#)==if fontadj then begin #:=cur_font; adjust_font(#); end
@d set_cur_attrib(#)==if join_attrib(#)>ignorable then
     curchr_attrib:=join_attrib(#)
@d mid_rule_ok==((mrule_init >= 0) and is_twin_font(f) and
                 (char_exists(char_info(f)(c)))and (font_params[f]>=14))
@d has_semi_accent_height(#)==((font_params [#] > 7) and 
                              (semi_accent_height(#)<>0))
@d semi_wrapup==
  if ligature_present then
     begin main_p:=new_ligature(f,l,link(q));
        link(q):=main_p; tail:=main_p; set_cur_attrib(l);
     end;
  if c=hyphen_char[f1] then
    if mode=hmode then tail_append(new_disc)

@<handle semitic character such as TeX main loop@>=
 if check_semitic_font then goto big_switch;
  adjust_space_factor;
 f:=cur_font; adjust_char(c); adjust_font(f);
 @<if char |c| in font |f| not exists goto reswitch@>;
 @<look for kern of char befor semiaccent@>;
goto semi_mid_loop;
semi_main_loop+1:  if not fontadj then f:=cur_font;
 @<if char |c| in font |f| not exists goto reswitch@>;
semi_main_loop+2: chk_font_adjusting (f);
semi_mid_loop:
if mid_rule_ok then append_mid_rule (f);
q:=tail; ligature_present:=false; l:=qi(c); f1:=f;
set_cur_attrib(c);
semi_lookahead: i:=char_info(f)(l);
if char_exists(i) then
  begin fast_get_avail(main_p); acc_char:=i; acc_font:=f1;
        font(main_p):=f1; character(main_p):=qi(c);
        link(tail):=main_p; tail:=main_p;
  end
else char_warning(f,qo(l));
@<Look for another semitic character and set |r|=256 if there's none there@>;
semi_lig_loop:
@<If there's relevent ligature/kern to |i| adjust the text@>;
if r=qi(256) then goto reswitch; {|cur_cmd|, |cur_chr|, |cur_tok| are untouched}
c:=qo(r);
goto semi_main_loop+1; {|f| is still valid}

@ @<if char |c| in font |f| not exists goto reswitch@>=
 if (c<font_bc[f])or(c>font_ec[f]) then
    begin char_warning(f,c); goto big_switch;  end

@ @<look for kern of char befor semiaccent@>=
 if (tail<>head) and (type(tail)=kern_node) and (subtype(tail)=acc_kern) and 
   ((acc_font = f) or (acc_font = fontwin[f])) and 
               (char_tag(acc_char) = lig_tag) then 
    begin i := acc_char; f1:=acc_font;
      k:=lig_kern_start(f1)(i); r:=qi(c);
      repeat j:=font_info[k].qqqq; {fetch a lig/kern command}
        if next_char(j)=r then
          if op_byte(j)>=kern_flag then
            begin
              q:=new_kern(char_kern(f1)(j));
              tail_append(new_kern(char_kern(f1)(j)));
              goto semi_mid_loop;
            end;
        incr(k);
      until skip_byte(j)>=stop_flag;
    end

@ @<Look for another semitic character and set |r|=256 if there's none there@>=
get_next; {set only |cur_cmd| and |cur_chr|}
if cur_cmd=letter then goto semi_lookahead+2;
if cur_cmd=other_char then goto semi_lookahead+2;
if cur_cmd=semi_given then goto semi_lookahead+3;
x_token; {set |cur_cmd|, |cur_chr|, |cur_tok|}
if cur_cmd=letter then goto semi_lookahead+2;
if cur_cmd=other_char then goto semi_lookahead+2;
if cur_cmd=semi_given then goto semi_lookahead+3;
if cur_cmd=char_num then
   if cur_chr=Rtlang then
      begin scan_char_num; cur_chr:=cur_val; goto semi_lookahead+3; end;
semi_lookahead+1:
r:=qi(256); goto semi_lig_loop;
semi_lookahead+2:
   if not is_semi_char(cur_chr) then goto semi_lookahead+1;
   adjust_space_factor;
semi_lookahead+3:
   adjust_char(r); fontadj:=true

@ @<If there's relevent ligature/kern to |i| adjust the text@>=
if char_tag(i)=lig_tag then
  if r<>qi(256) then
    begin k:=lig_kern_start(f)(i);
      repeat j:=font_info[k].qqqq; {fetch a lig/kern command}
        if next_char(j)=r then
          if op_byte(j)<kern_flag then
            begin ligature_present:=true; l:=rem_byte(j); c:=qo(r);
              chk_font_adjusting (f1);
              if join_attrib(l)>ignorable then curchr_attrib:=join_attrib(l);
              goto semi_lookahead;
            end
          else
            begin semi_wrapup;
              tail_append(new_kern(char_kern(f)(j)));
              c:=qo(r); goto semi_main_loop+2;
            end;
        incr(k);
      until skip_byte(j)>=stop_flag;
    end;
semi_wrapup

@ \subtitle{New font specifications.}
Farsi fonts are expected to have seven extra parameters:
\hang|param[8]=semi_accent_height| is accents height.

\hang|param[9]=mid_rule_height| is midrule  height.

\hang|param[10]=mid_rule_depth| is midrule  depthe.

\hang|param[11]=mid_rule_width| is midrule  width.

\hang|param[12]=mid_rule_stretch| is midrule  stretch.

\hang|param[13]=mid_rule_shrink|  is midrule  shrink.

\hang|param[14]=mid_rule_stretch_order| is midrule  stretch order.

@d semi_accent_height_code=8
@d mid_rule_height_code=9
@d mid_rule_depth_code=10
@d mid_rule_width_code=11
@d mid_rule_stretch_code=12
@d mid_rule_shrink_code=13
@d mid_rule_stretch_order_code=14
@#
@d semi_accent_height==param(semi_accent_height_code)
@d mid_rule_height==param(mid_rule_height_code)
@d mid_rule_depth==param(mid_rule_depth_code)
@d mid_rule_width==param(mid_rule_width_code)
@d mid_rule_stretch==param(mid_rule_stretch_code)
@d mid_rule_shrink==param(mid_rule_shrink_code)
@d mid_rule_stretch_order==param(mid_rule_stretch_order_code)

@<Check \pTeX{} font dimen@>=
if (n<=mid_rule_stretch_order_code)and
            (n>=mid_rule_height_code)and(font_mid_rule[f]<>null) then
        begin delete_glue_ref(font_mid_rule[f]); font_mid_rule[f]:=null; end;


@ New Constants for \pTeX{} font types.

@<Constants...@>=
@!twin_tag=256; {a constant to deal with |font_twin| must be greater than 
                 |font_max| and must not exceed |max_quarterword| }
@!dbl_tag=257; {same as |twin_tag| }

@
@<Glob...@>=
@!fontwin:array[internal_font_number] of halfword; {the twin font of this font}
@!font_mid_rule:array[internal_font_number] of pointer;
  {glue specification for interletter rule, |null| if not allocated}

@ Befor appending a second |Rtlang| character to horizental list,
  if we have |mrule_init>=0|, we call the  |append_mid_rule| procedure
  to do the job.
 
@<Define |append_mid_rule| procedure@>=
procedure append_mid_rule(@!f:internal_font_number);
var @!p,q:pointer; {for |mid_rule| handling}
@!k:0..font_mem_size; {index into |font_info|}
begin 
  if mid_rule=zero_glue then
    begin p:=font_mid_rule[f];
    if p=null then
      begin p:=new_spec(zero_glue); k:=param_base[f]+mid_rule_width_code;
      width(p):=font_info[k].sc; {that's |mid_rule_width(f)|}
      stretch(p):=font_info[k+1].sc; {and |mid_rule_stretch(f)|}
      shrink(p):=font_info[k+2].sc; {and |mid_rule_shrink(f)|}
      stretch_order(p):=font_info[k+3].sc; {and |mid_rule_stretch_order(f)|}
      font_mid_rule[f]:=p;
      end;
    q:=new_glue(p);
    end
  else  q:=new_param_glue(mid_rule_code);
  leader_ptr(q):=f; {the font of this |mid_rule|}
  if mrule_init>0 then subtype(q):=active_mid_rule
  else subtype(q):=suprsd_mid_rule;
  link(tail):=q; tail:=q;
end;

@
@<Check |mid_rule|s@>=
if is_mrule(p) then {|suprsd_mid_rule| can't go here }
  begin rule_ht:=mid_rule_height(leader_ptr(p));
  rule_dp:=mid_rule_depth(leader_ptr(p));
  rule_ht:=rule_ht+rule_dp; {this is the rule thickness}
  if (rule_ht>0)and(rule_wd>0) then {we don't output empty rules}
    begin synch_h; cur_v:=base_line+rule_dp; synch_v;
    dvi_out(set_rule); dvi_four(rule_ht); dvi_four(rule_wd);
    cur_v:=base_line; dvi_h:=dvi_h+rule_wd;
    end;
  goto move_past;
  end;
@
@<Initialize table entries...@>=
fontwin[null_font]:=null_font; font_mid_rule[null_font]:=null;
@
@d set_rest_end_end(#)==#:=f; hyphen_char [f]:=-1
@d set_rest_end(#)==font_id_text(f):=#; set_rest_end_end
@d set_rest(#)==equiv(#):=f; eqtb[font_id_base+f]:=eqtb[#]; set_rest_end

@<Declare \pTeX{} font procedures for |prefixed_command|@>=
function get_semi_fontext(a:small_number;u:pointer;s:str_number):str_number;
begin
  if u>=hash_base then s:=text(u)
  else if u>=single_base then begin if u<>null_cs then s:=u-single_base end
    else begin old_setting:=selector; selector:=new_string; print(s);
               print(u-active_base); selector:=old_setting; @.FONTx@>
               str_room(1); s:=make_string; end;
  define(u,set_font,null_font); get_semi_fontext:=s;
end;
@#
function get_semi_font(u:pointer):internal_font_number;
label found;
var @!s:scaled; {stated ``at'' size, or negative of scaled magnification}
@!f:internal_font_number; {runs through existing fonts}
begin scan_file_name; @<Scan the font size specification@>;
for f:=font_base+1 to font_ptr do
  if str_eq_str(font_name[f],cur_name)and str_eq_str(font_area[f],cur_area) then
    begin if s>0 then begin if s=font_size[f] then goto found; end
        else if font_size[f]=xn_over_d(font_dsize[f],-s,1000) then goto found;
    end;
f:=read_font_info(u,cur_name,cur_area,s);
found: get_semi_font:=f;
end;
@#
procedure new_semi_font(@!a:small_number);
label common_ending,found1,found2;
var u,uu:pointer; {user's font identifier}
@!f:internal_font_number; {runs through existing fonts}
@!t,tt:str_number; {name for the frozen font identifier}
@!old_setting:0..max_selector; {holds |selector| setting}
@!fu,fuu:internal_font_number; {font numbers for |twin_font| setting}
@!first_null,second_null,single_font:boolean;
begin single_font:=(cur_chr = 0); 
if job_name=0 then open_log_file; {avoid \.{texput} with the font name}
@.texput@>
get_font_token(1); u:=cur_cs; first_null:=cs_null_font;
if single_font then cur_cs:=0
else if not first_null then get_font_token(2);
uu:=cur_cs; second_null:=cs_null_font;
if not first_null then t:=get_semi_fontext(a,u,"SEMIFONT");
if (uu<>0) and (not second_null) then tt:=get_semi_fontext (a,uu,"TWINFONT");
scan_optional_equals;
if not first_null then begin f:=get_semi_font(u); set_rest(u)(t)(fu); end;
if first_null or ((uu<>0) and (not second_null) and (uu<>u)) then
    begin f:=get_semi_font (uu); set_rest(uu)(tt)(fuu); end;
if single_font then fontwin[fu]:=dbl_tag
else if (uu=0)or(u=uu) then fontwin[fu]:=fu
     else if not first_null then
             if not second_null then
                  begin fontwin[fu]:=fuu; fontwin[fuu]:=twin_tag; end
             else fontwin[fu]:=fu
          else fontwin[fuu]:=twin_tag;
end;
@
The |semifont| command may be define with one or two control sequences
and the new |dblfont| command must be defined with one control sequence.
Procedur |get_font_token| is defined
to handel these commands when defining semitic fonts.
It take a |nullify| parameter that may vary as follows:

\yskip\textindent{1)} To get the first control sequence.

\textindent{2)} To get the optional second control sequence.

@d cs_null_font==((cur_chr=null_font)and(cur_cmd=set_font))

@<Declare \pTeX{} subprocedures for |prefixed_command|@>=
procedure get_font_token(nullify:halfword);
label restart;
begin restart: repeat get_token;
until (cur_tok<>space_token) and (cur_tok<>semi_space_token);
if ((cur_cs=0)and(nullify<>2))or(cur_cs>frozen_control_sequence) then
  begin print_err("Missing control sequence inserted");
@.Missing control...@>
  help5("Please don't say `\semifont cs...', say `\semifont\cs...'.")@/
  ("I've inserted an inaccessible control sequence so that your")@/
  ("definition will be completed without mixing me up too badly.")@/
  ("You can recover graciously from this error, if you're")@/
  ("careful; see exercise 27.2 in The TeXbook.");
@:TeXbook}{\sl The \TeX book@>
  if cur_cs=0 then back_input;
  cur_tok:=cs_token_flag+frozen_protection; ins_error; goto restart;
  end;
if (cur_cs=0)and(nullify=2) then back_input;
end;
@
@<Print |p| according to |fontwin[font(p)]|@>=
  if is_semi_font (font(p)) then print_s_ASCII(qo(character(p)))
  else print_ASCII(qo(character(p)))

@
For every printing we should reset directional variable.
@d semitic_mode==(stkLR_cmd=bgn_R_code)
@d latin_mode==(stkLR_cmd=bgn_L_code)
@d cur_eq_other(#)==((cur_tok=other_token+#) or (eq_tok=other_token+#))
@d set_latin_font==begin if cur_font<>cur_latif then 
                            eq_define(cur_font_loc,data,cur_latif); end
@d set_semi_font==begin if cur_font<>cur_semif then
                           eq_define(cur_font_loc,data,cur_semif);  end

@<Bidirectional procedures@>=
procedure set_directed_space;
var @!direction:direction_type;
begin
if ((name<1)or(name=16)) then direction:=cur_direction
else if name>17 then direction:=direction_stack[in_open]
     else if read_open[name-1]=closed then direction:=cur_direction
          else direction:=direction_stack[in_open];
cur_cmd:=spacer;
if semitic_mode then cur_chr:=" " else if latin_mode then cur_chr:=" "
     else if direction=L_to_R then cur_chr:=" " else cur_chr:=" ";
end;
@#
@ For automatic |bi_directional| typesetting we have to check |cur_font| 
  anywhere context may change direction.

@<Declare act...@>=
function insert_LR(which:language_type):boolean;
var p:pointer; {for inserting |auto_LR| commands}
@!n:halfword;
begin x_token; back_input;
  if which=Rtlang then n:=frozen_bgn_R else n:=frozen_bgn_L;
  p:=get_avail; info(p):=cs_token_flag + n; ins_list(p); insert_LR:=true;
end;
@#
function check_semitic_font:boolean;
var @!b:boolean;
begin b:=false;
  if auto_LRdir then if not semitic_mode then b:=insert_LR(Rtlang);
  if auto_LRfont then set_semi_font;
  check_semitic_font:=b;
end;
@#
function check_latin_font:boolean;
var @!b:boolean;
begin b:=false;
  if auto_LRdir then if not latin_mode then b:=insert_LR(Lftlang);
  if auto_LRfont then set_latin_font;
  check_latin_font:=b;
end;
@#
procedure call_app_space;
begin if is_semi_font (cur_font) then
  app_space(semi_xspace_skip_code,semi_space_skip_code)
else app_space(xspace_skip_code,space_skip_code);
end;

@* \[67] New conditional.

@d ifstk_size=128 {maximum nested ifset...}
@d ifstk_val==if_stack [ifstk_ptr]

@<Glob...@>=
@!if_stack: array [0..ifstk_size] of eight_bits; {nested |if_set|...}
@!ifstk_ptr:eight_bits; {top of the |if_stack|}
@ 
@<Set init...@>=ifstk_ptr := 0;
@ 
@d nestLR_cmd(#)==LRcmd(nest[#].LR_aux_field.hh.rh)
@d R_done(#)==begin b:=(#=bgn_R_code); goto done; end
@d L_done(#)==begin b:=(#=bgn_L_code); goto done; end

@<Process semitic conditionlas@>=
if_semiticchar_code: begin get_x_token_or_active_char; b:=issemichr(cur_chr);
   if (cur_cmd>active_char)or(cur_chr>255) then b:=false; end;
if_L_code: begin if stkLR_cmd<>0 then L_done(stkLR_cmd);
  for i:=nest_ptr-1 downto 0 do if nestLR_cmd(i)<>0 then L_done(nestLR_cmd(i));
  b:=false;  end;
if_R_code: begin if stkLR_cmd<>0 then R_done(stkLR_cmd);
  for i:=nest_ptr-1 downto 0 do if nestLR_cmd(i)<>0 then R_done(nestLR_cmd(i));
  b:=false;  end;
if_latin_code: b:=latin_speech;
if_left_vbox_code: b:=L_to_R_vbox;
if_joinable_code: b:=curchr_attrib=joinable;
if_thousands_code: b:=get_rem_or_div (1000000,1000) <> 0;
if_millions_code: b:=get_rem_or_div (1000000000,1000000) <> 0;
if_billions_code: b:=get_rem_or_div (0,1000000000) <> 0;
if_prehundreds_code: b:=get_rem_or_div (100,0) <> 0;
if_prethousands_code: b:=get_rem_or_div (1000,0) <> 0;
if_premillions_code: b:=get_rem_or_div (1000000,0) <> 0;
if_prebillions_code: b:=get_rem_or_div (1000000000,0) <> 0;
if_setlatin_code: begin
     if ifstk_ptr < ifstk_size then begin
         ifstk_val:=(cur_direction mod 4)*4+(cur_speech mod 4);
         incr (ifstk_ptr);
     end;
     cur_speech := Lftlang; cur_direction := L_to_R; b:=true; end;
if_setsemitic_code: begin 
     if ifstk_ptr < ifstk_size then begin
         ifstk_val:=(cur_direction mod 4)*4+(cur_speech mod 4);
         incr (ifstk_ptr);
     end;
     cur_speech := Rtlang; cur_direction := R_to_L; b:=true; end;
if_setrawprinting_code: begin
     if ifstk_ptr < ifstk_size then begin
         if eq_show then ifstk_val:=17 else ifstk_val:=16;
         incr (ifstk_ptr);
     end;
     pushprinteq; eq_show := false;
     b:=true; end;
if_LRdir_code: b:=auto_LRdir;
if_LRfnt_code: b:=auto_LRfont;
if_splited_code: @<Check splited insert@>;
if_ones_code, if_tens_code, if_hundreds_code, {process like |if_case_code|}
@
@<Declare |pop_ifstk|@>=
procedure pop_ifstk;
begin
   if (cur_if >= if_setlatin_code) and (ifstk_ptr > 0) then begin
     decr (ifstk_ptr);
     if ifstk_val < 16 then
       begin
          cur_speech := ifstk_val mod 4;
          cur_direction := ifstk_val div 4;
       end
     else begin popprinteq;
             if ifstk_val > 16 then eq_show := true;
          end;    
   end;
end;
@
@<Test |eqif| q@>=
(eqchring and
    ((cur_chr=eqif(q)) or (eqif(q)=cur_chr)))
@
@<Test |eqif| n@>=
(eqchring and
    ((eqif(n)=cur_chr) or (n=eqif(cur_chr))))
@
@<Check positional numbers@>=
  if this_if = if_ones_code then n:=cur_val mod 10
  else if this_if = if_tens_code then n:=(cur_val mod 100) div 10
  else if this_if = if_hundreds_code then n:=(cur_val mod 1000) div 100
  else {continue with |if_case_code|}


@* \[61] Semitic accents.
@<Initialize table entries...@>=
for k:=0 to 255 do
  begin acc_factor(k):=2056;
  end;
@
@<Check semitic char tables@>=
else if cur_chr=acc_factor_base then n:=16448
@
@<Declare act...@>=
procedure make_semi_accent (@!downacc:boolean);
var s,@!t: real; {amount of slant}
@!p,@!q,@!r:pointer; {character, box, and kern nodes}
@!f:internal_font_number; {relevant font}
@!a,@!h,@!d,@!x,@!y,@!w,@!delta,odelta:scaled; { heights, depths and widths }
@!i:four_quarters; {character information}
@!wf:halfword;
@!qc:pointer; {character of tail}
@!k:0..font_mem_size; {index into |font_info|}
begin scan_char_num; f:=cur_semif; 
if not is_dbl_font(f) then cur_val:=semichrin(cur_val);
p:=new_character(f,cur_val);
if p<>null then
  begin q:=null;
  if tail <> head then begin
  if (is_char_node(tail)) or (type(tail)=ligature_node) then 
    begin s:=slant(f)/float_constant(65536);
      if has_semi_accent_height(f) then x:=semi_accent_height(f)
      else begin x:=x_height(f); end;
      i:=char_info(f)(character(p)); a:=char_width(f)(i);
      if not retain_acc then begin acc_wd:=a;
          if downacc then acc_dp:=char_depth(f)(height_depth(i))
          else acc_ht:=char_height(f)(height_depth(i)); end;
      q:=tail; if type(q)=ligature_node then qc:=lig_char(q) else qc:=q;
      f:=font(qc); t:=slant(f)/float_constant(65536); 
      i:=char_info(f)(character(qc)); w:=char_width(f)(i);
      wf:=acc_factor (character(qc));
      h:=char_height(f)(height_depth(i)); d:=char_depth(f)(height_depth(i)); 
      if downacc then begin wf:=wf div 256; y:=d-x; s:=-d*t+x*s; end
      else begin wf:=wf mod 256; y:=x-h; s:=-h*t+x*s; end;
      if retain_acc then begin acc_wd := -w; acc_ht := h; acc_dp := d; end
      else if downacc then begin acc_ht:=h; acc_dp:=acc_dp+y; end
           else begin acc_dp:=d; acc_ht:=acc_ht-y; end;
      if wf <> 0 then w:=round(w*wf)/float_constant(8);
      delta:=round((w-a)/float_constant(2)+s);
      if y<>0 then begin p:=hpack(p,natural); shift_amount(p):=y; end;
      r:=new_kern(-a-delta); subtype(r):=acc_kern; link(tail):=r; link(r):=p;
      tail:=new_kern(delta); subtype(tail):=acc_kern; link(p):=tail;
    end { |char_node| }
  else if (type(tail)=kern_node) and (subtype(tail)=acc_kern) then 
    begin s:=slant(f)/float_constant(65536);
      if semi_accent_height(f)<>0 then x:=semi_accent_height(f)
      else begin x:=x_height(f); end;
      h:=acc_ht; d:=acc_dp; w:=acc_wd; if downacc then y:=d-x else y:=x-h;
      i:=char_info(f)(character(p)); a:=char_width(f)(i);
      if not retain_acc then begin acc_wd := a;
            if downacc then acc_dp:=char_depth(f)(height_depth(i))+y
            else acc_ht:=char_height(f)(height_depth(i))-y; end;
      if y<>0 then begin p:=hpack(p,natural); shift_amount(p):=y; end;
      delta:=round((w-a)/float_constant(2));
      q:=tail; odelta:=width(q); width(q):=-a - delta; link(q):=p;
      tail:=new_kern(delta+odelta); subtype(tail):=acc_kern; link(p):=tail;
    end;
  end; {if |tail <> head| }
  if q=null then tail_append (p); space_factor:=1000;
  retain_acc:=false;
end;
end;

@* \[62] Equated commands.
@<Initialize table entries...@>=
for k:=0 to 255 do
  begin eqch (k) := 0; eqif (k) := 0;
  end;
eqch("-"):="-"; eqch("+"):="+"; eqch("="):="=";
eqch("-"):="-"; eqch("+"):="+"; eqch("="):="=";
eqif("-"):="-"; eqif("+"):="+"; eqif("="):="=";
eqif("-"):="-"; eqif("+"):="+"; eqif("="):="=";

@
@d LRsw_max = 4 
@d alt_text(#)==alt_str[text(#)]
@d LRswend(#)==#
@d LRsw(#)==LRsw_max * # + LRswend
@<Glob...@>=
@!cur_eq: pointer; {equated control sequence found here, zero if none found}
@!eq_tok: halfword; {packed representative of |cur_cmd| and |eqch(cur_chr)|}
@!eq_show:boolean; {are we in showing equated macro delimiters}

@ @<Cases of |print_cmd_chr|...@>=
let_name: case chr_code of
normal:      print_esc("leteqname");
LftTag:       print_esc("letlatinname");
RtTag:     print_esc("letsemiticname");
LRsw_max:    print_esc("letnoteqname");
LRsw_max+1:  print_esc("letnoteqchar");
LRsw_max+2:  print_esc("letnoteqcharif");
othercases;
endcases;@/
@
@<Assignments@>=
let_name: if cur_chr <= LRsw(1)(0) then do_eq_name (a)
   else if cur_chr > LRsw(1)(1) then
        for p:=eq_charif_base to eq_charif_base+255 do define(p,data,0)
   else for p:=eq_char_base to eq_char_base+255 do define (p,data,0);
@
@<Declare \pTeX{} subprocedures for |prefixed_command|@>=
procedure do_eq_name (@!a:small_number);
label not_found, found;
var p,n,e,swch,j:integer;
h:str_number;
begin n:=cur_chr; swch:=LR_showswch;
{   if eqnaming then |LR_showswch| := swch - 2; }
   LR_showswch := 0; j:=0;
   get_r_token; p:=cur_cs;
{   if |cur_eq|<>0 then p:=|cur_eq| else p:=|cur_cs|; }
   if n <> LRsw(1)(0) then begin
      repeat get_token; until cur_cmd<>spacer;
      if cur_eq_other("=") then
         begin get_token; if cur_cmd=spacer then get_token; end;
   end;
   h:="Command names can be equated only with another command name.";@/
   if (cur_cs < hash_base) or (p < hash_base) or
      (cur_cs >= glue_base) or (p >= glue_base) then goto not_found;
   h:="Diferent command names can be equated.";@/
   if n = LRsw(1)(0) then 
      begin h:="Only equated commands can be \noteqname.";@/
            if eq_type (p) <> eq_name then goto not_found;
            e := abs (alt_text(p)); alt_text(p):=null;
            if (e<>null) and (abs(alt_str[e])=text(p)) then alt_str[e] := null;
            define(p,undefined_cs,null);
            goto found; end
   else if (cur_cs = p) or 
           ((n <> normal) and (alt_text(cur_cs)<>null)) then goto not_found;
   if n=Lftlang then begin alt_text(cur_cs):=-text(p);
                  if alt_text(p)=null then alt_text(p):=text(cur_cs); end
   else if n=Rtlang then begin alt_text(cur_cs):=text(p);
                  if alt_text(p)=null then alt_text(p):=-text(cur_cs); end;
   if ((eq_type (cur_cs) = relax) or (eq_type (cur_cs) = undefined_cs)) and
      ((eq_type (p) <> relax) and (eq_type (p) <> undefined_cs)) then
        begin define(cur_cs,eq_name,p); end
   else define(p,eq_name,cur_cs);
   goto found;
not_found:
  print_err("Bad command name");
  if (n<>normal) and (alt_text(cur_cs)<>null) then
              begin print (" old eqname `");
                    pushprinteq; print_esc(abs(alt_text(cur_cs)));
                    popprinteq; print_char("'");
              end;
  help2(h)("I'm ignoring the command and its parameters");
  error;
found:
   LR_showswch := swch;
end;
@ @<Check |eq_name| command@>=
   if eqnaming then 
       while (eq_type(cur_cs)=eq_name) and (equiv(cur_cs)<>cur_eq) do
           begin if cur_eq=0 then cur_eq:=cur_cs; cur_cs:=equiv(cur_cs); end;

@ @<Set |cur_tok| and |eq_tok|@>=eq_tok:=0;
  if cur_cs=0 then begin cur_tok:=(cur_cmd*@'400)+cur_chr;
  if eqchring and (eqif(cur_chr)<>0) then eq_tok:=(cur_cmd*256)+eqif(cur_chr);
 end
else begin cur_tok:=cs_token_flag+cur_cs;
           if cur_eq <> 0 then eq_tok := cs_token_flag + cur_eq; end


@* \[68] New whatsit.

@<Glob...@>=
@!SPCsp: pointer; {stack of beginspecial nodes}
@!LJsp: pointer; {stack of LR and beginspecial nodes}

@ To appending |beginspecial_node| or |endspecial_node| to
 horizental list we 
 create a |whatsit_node| with subtype |beginspacial_node| or |endspecial_node|.
The |push_SPC| and |pop_SPC| procedures
are used to checking or reinserting these nodes.

For adjusting breaked line |beginspecial_node| and |LR_node| must nest 
properly, so we use |push_LJ| and |pop_LJ| to avoid confusion. 

@<Declare functions needed for special kinds of nodes@>=
procedure push_SPC(p:pointer);
var t:pointer;
begin t:=get_avail; info(t):=p; link(t):=SPCsp; SPCsp:=t;
end;
@#
procedure pop_SPC;
var t:pointer; begin t:=SPCsp;
   if t<>null then begin SPCsp:=link(t); free_avail(t); end;
end;
@#
procedure push_LJ(p:pointer);
var t:pointer;
begin t:=get_avail; info(t):=p; link(t):=LJsp; LJsp:=t;
end;
@#
procedure pop_LJ;
var t:pointer; begin t:=LJsp;
   if t<>null then begin LJsp:=link(t); free_avail(t); end;
end;
@#
function new_LJ(s:pointer;endflg:boolean): pointer;
var p: pointer;
t:small_number;
begin p:=get_node(write_node_size);
 type(p):=whatsit_node;
  if subtype (s) = beginspecial_node then 
     if endflg then t:=endspecial_node else t:=beginspecial_node
  else t:=LR_node;
  subtype(p):=t;
  if t=endspecial_node then begin
      write_tokens (p):=write_stream (s); add_token_ref(write_tokens (p));
      write_stream (p):=null;
    end
  else if t=beginspecial_node then begin
      write_tokens(p):=write_tokens (s);add_token_ref(write_tokens (p));
      write_stream (p):=write_stream (s);add_token_ref(write_stream (p));
    end
  else begin  t:=LR_command(s); if endflg then t:=LRend(t);
              LR_command (p) := t; LR_source (p) := LR_source (s); end;
 new_LJ:=p;
end;

@* \[70] Extra small changes.
@<Glob...@>=
@!direction_stack:array[1..max_in_open] of direction_type;
@!read_file_direction:array[0..15] of direction_type;
@!write_file_direction:array[0..15] of direction_type;

@ \subtitle{زیرنویس شکسته}
@<Check splited insert@>=
begin scan_eight_bit_int;
      b:=splited_ins [cur_val]; 
end
@ \subtitle{جدول راست به چپ}
@<Reverse align columns@>=
   begin u:=hold_head;
      while s<>null do {insert blank boxes for empty columns }
        begin link(u):=new_null_box; u:=link(u); width(u):=width(s);
          s:=link(s); v:=glue_ptr(s); link(u):=new_glue(v); u:=link(u);
          subtype(u):=tab_skip_code+1; s:=link(s);
        end;
      if u<>hold_head then {append blank boxes}
         begin link(u):=link(pr); link(pr):=link(hold_head); end;
      if list_ptr(q)<>null then {reverse columns in row |q|}
         begin s:=list_ptr(q); r:=link(s); link(s):=null;
               while r<>null do begin u:=link(r); link(r):=s; s:=r; r:=u; end;
               list_ptr(q):=s;
         end;
   end
@ \subtitle{اعداد فارسی در فرمول}
@d digvar_code==@'100000 
  {math code meaning ``use the current semitic family''}

@<Declare |report_math_illegal_case|@>=
procedure report_math_illegal_case(bool:boolean);
begin you_cant;
if bool then
begin
help4("Sorry, but I can't handle semitic characters in formulas, YET.")@/
("I'll just use the latin letter `a' instead of your semitic character.")@/
("Or maybe you're in the wrong mode. If so, you might be able to")@/
("return to the right one by typing `I}' or `I$' or `I\par'.");@/
end
else begin
help2("Sorry, but I can't handle semitic characters in formulas, YET.")@/
("I'll just use the latin letter `a' instead of your semitic character.");@/
end;
cur_tok:=letter_token+"a"; ins_error;
end
@
@<Cases of |main_control| that build...@>=
mmode+LR: report_illegal_case;

@
@<Declare |find_last|@>=
function find_last (@!what:halfword):halfword;
label exit,done;
var @!p,@!q,@!t:pointer; {run through the current list}
@!m:quarterword; {the length of a replacement list}
begin find_last:=null;
    if not is_char_node(tail) then
       if ((type(tail)=what) or (ignrautoLR and is_auto_LR(tail))) then
    begin q:=head;
    if type(tail)=what then t:=null
    else begin
           if (link(q)=tail) and (type(q)=what) then
              begin find_last:=q; return; end;
           t:=tail;
         end;
    repeat p:=q;
    if not is_char_node(q) then if type(q)=disc_node then
      begin for m:=1 to replace_count(q) do p:=link(p);
      if p=tail then return;
      end;
    q:=link(p);
    if t<>null then
       if type(q)=what then t:=p
       else if not is_auto_LR(q) then t:=tail;
    until q=tail;
    if (t<>null) and (t<>tail) then 
       begin 
           if not ((type(t)=glue_node) and is_mrule(t)) then find_last := t;
       end
    else find_last:=p;
    end;
exit:end;
@#
procedure scan_nine_bit_int;
begin scan_int;
if (cur_val<0)or(cur_val>511) then
  begin print_err("Bad register code");
@.Bad register code@>
  help2("A dimen or count register number must be between 0 and 512.")@/
    ("I changed this one to zero."); int_error(cur_val); cur_val:=0;
  end;
end;
@#
function chk_sign_and_semitic:boolean;
var negative:boolean; {should the answer be negated?}
@!p,@!q:pointer; {keep head and tail of semietic digits}
begin  p:=null; q:=null; negative:=false;
repeat @<Get the next non-blank non-call token@>;
 if cur_eq_other("-") then
  begin negative:=not negative; cur_tok:=other_token+"+"; eq_tok:=cur_tok; end;
until (not cur_eq_other("+"));
if not ((cur_tok<=other_token+"9") and (cur_tok>=other_token+"0")) then
while ((cur_tok<=other_token+"۹") and (cur_tok>=other_token+"۰")) or
      ((cur_tok<=other_token+"9") and (cur_tok>=other_token+"0")) or
      (cur_tok=semi_point_token) or (cur_tok=semi_octal_token) do
  begin if (cur_tok<=other_token+"۹") and (cur_tok>=other_token+"۰") then
               cur_tok:=cur_tok-"۰"+"0"
        else if (cur_tok<=other_token+"9") and (cur_tok>=other_token+"0") then
               cur_tok:=cur_tok-"0"
        else if cur_tok=semi_point_token then cur_tok:=point_token
        else cur_tok:=octal_token;
    fast_get_avail(p); info(p):=cur_tok; link(p):=q; q:=p; get_x_token;
  end;
if p<>null then
  begin if cur_eq_other("-") then negative := not negative else back_input;
        back_list(p); get_x_token; end;  
  chk_sign_and_semitic:=negative;
end;
@#
function get_rem_or_div (@!m,@!d:integer):integer;
begin scan_int; if m > 0 then cur_val := cur_val mod m;
  if d > 0 then cur_val := cur_val div d; get_rem_or_div := cur_val;
end;
@  
@<Print LR |whatsit|@>=
open_R_node:begin print_write_whatsit("openoutR",p); print_char("=");
  print_file_name(open_name(p),open_area(p),open_ext(p)); end;
LR_node: begin case LR_command(p) of
  bgn_L_code: print_esc("beginL");
  bgn_R_code: print_esc("beginR");
  end_L_code: print_esc("endL");
  end_R_code: print_esc("endR");
  othercases print("!!LR node command!!")
  endcases;
  case LR_source(p) of
  manLR: print("manual");
  autoerr: print("autoerr");
  autodir: print("autodir");
  autopar: print("autopar");
  autocol: print("autocol");
  manrbox: print("manrbox");
  automath: print("automath");
  othercases print("!!LR node source!!")
  endcases; end;
beginspecial_node:begin print_esc("beginspecial");
  print_mark(write_tokens(p));
  print_mark(write_stream(p));
  end;
endspecial_node:print_esc("endspecial");
@
@<LR ext cmdchr@>=
  open_R_node:print_esc("openoutR");
  eqwrite_node:print_esc("eqwrite");
  beginspecial_node:print_esc("beginspecial");
  endspecial_node:print_esc("endspecial");
@
@<Test bidirectionals@>=
else if n<cur_speech_loc then begin print("bi\_directional typesetting");
        print_char("=");
        if equiv(n)=0 then print("manLRset")
        else if equiv(n) = 1 then print ("autoLRdirset")
             else if equiv(n) = 2 then print ("autoLRfontset")
                  else print("autoLRdirfontset");
  end
else if n<cur_direction_loc then begin print("speech language");
        print_char("=");
        if equiv(n)=Rtlang then print("semitic") else print("latin");
  end
else if n<vbox_justify_loc then begin print("speech direction");
        print_char("=");
        if equiv(n)=R_to_L then print("RtoL") else print("LtoR");
  end
else if n<cur_font_loc then
  begin print("current vbox justification"); print("=from ");
  if equiv(n)=L_to_R then print("left") else print("right");
  end
@ @<Cases of |print_cmd_chr|...@>=
LR_setting: begin
t := chr_code div LRsw_max; chr_code := chr_code mod LRsw_max;
case t of
0: if chr_code=joinable then print_esc("lastcharjoinable")
   else print_esc("lastcharunjoinable");
1: if chr_code=manual then print_esc("manLRset") 
   else if chr_code = autoLR then print_esc("autoLRdirset")
   else if chr_code = autofont then print_esc("autoLRfontset")
   else print_esc("autoLRset");
2: if chr_code=Lftlang then print_esc("latin") else print_esc("semitic");
3: if chr_code=L_to_R then print_esc("LtoR") else print_esc("RtoL");
4: if chr_code=L_to_R then print_esc("leftvbox") else print_esc("rightvbox");
1000: print_esc ("leftinput");
endcases; { there are no other cases }
end;@/
LR_getting: if chr_code=cur_direction_loc then print_esc("curdirection")
  else if chr_code=cur_speech_loc then print_esc("curspeech")
       else if chr_code=cur_LRswch_loc then print_esc("curLRswch")
       else print_esc("curboxdir");

@
@<Assignments@>=
LR_setting: if cur_chr = LRsw(1000)(0) then left_input := true
else if cur_chr < LRsw_max then curchr_attrib:=cur_chr
else define(cur_LRswch_loc+(cur_chr div LRsw_max)-1,data,cur_chr mod 
LRsw_max);@/
LR_getting: begin p:=cur_chr; scan_optional_equals;  scan_int;
                  define(p,data,cur_val); end;
@
@<Put each of \TeX's primitives into the hash table@>=
primitive("semispaceskip",assign_glue,glue_base+semi_space_skip_code);@/
@!@:semi_space_skip_}{\.{\\semispaceskip} primitive@>
primitive("semixspaceskip",assign_glue,glue_base+semi_xspace_skip_code);@/
@!@:semi_xspace_skip_}{\.{\\semixspaceskip} primitive@>
primitive("midrulespec",assign_glue,glue_base+mid_rule_code);@/
@!@:mid_rule_}{\.{\\midrule} primitive@>
primitive("beginspecial",extension,beginspecial_node);
@!@:beginspecial_}{\.{\\beginspecial} primitive@>
primitive("endspecial",extension,endspecial_node);
@!@:endspecial_}{\.{\\endspecial} primitive@>
primitive("eqwrite",extension,eqwrite_node);
@!@:eqwrite_}{\.{\\eqwrite} primitive@>
primitive("beginL",LR,bgn_L_code);@/
@!@:bgn_L_}{\.{\\beginL} primitive@>
text(frozen_bgn_L):="beginL"; eqtb[frozen_bgn_L]:=eqtb[cur_val];@/
equiv(frozen_bgn_L):=dir_bgn_L;
primitive("beginR",LR,bgn_R_code);@/
@!@:bgn_R_}{\.{\\beginR} primitive@>
text(frozen_bgn_R):="beginR"; eqtb[frozen_bgn_R]:=eqtb[cur_val];@/
equiv(frozen_bgn_R):=dir_bgn_R;
primitive("endL",LR,end_L_code);@/
@!@:end_L_}{\.{\\endL} primitive@>
text(frozen_end_L):="endL"; eqtb[frozen_end_L]:=eqtb[cur_val];@/
equiv(frozen_end_L):=err_end_L;
primitive("endR",LR,end_R_code);@/
@!@:end_R_}{\.{\\endR} primitive@>
text(frozen_end_R):="endR"; eqtb[frozen_end_R]:=eqtb[cur_val];@/
equiv(frozen_end_R):=err_end_R;
@#
primitive("vboxjustification",assign_int,int_base+vbox_justification_code);@/
@!@:vbox_justification_}{\.{\\vboxjustification} primitive@>
primitive("LRshowswitch",assign_int,int_base+LR_showswch_code);@/
@!@:LR_showswch_}{\.{\\LRshowswitch} primitive@>
primitive("LRmiscswitch",assign_int,int_base+LR_miscswch_code);@/
@!@:LR_miscswch_}{\.{\\LRmiscswitch} primitive@>
primitive("midruleinit",assign_int,int_base+mrule_init_code);@/
@!@:mrule_init_}{\.{\\midruleinit} primitive@>
@#
primitive(" ",ex_space,Lftlang);@/
@!@:Single-character primitives /}{\quad\.{\\\ }@>
primitive(" ",ex_space,Rtlang);@/
@!@:Single-character primitives /}{\quad\.{\\\ }@>
primitive("accent",accent,Lftlang);@/
@!@:accent_}{\.{\\accent} primitive@>
primitive("semiaccent",accent,Rtlang);@/
@!@:accent_}{\.{\\semiaccent} primitive@>
primitive("semiaccentdown",accent,Rtlang+1);@/
@!@:accent_}{\.{\\semiaccentdown} primitive@>
primitive("retainaccentchar",accent,Rtlang+2);@/
@!@:accent_}{\.{\\retainaccentchar} primitive@>
primitive("char",char_num,Lftlang);@/
@!@:char_}{\.{\\char} primitive@>
primitive("semichar",char_num,Rtlang);@/
@!@:semi_char_}{\.{\\semichar} primitive@>
primitive("dblfont",def_font,0);@/
@!@:font_}{\.{\\font} primitive@>
primitive("font",def_font,Lftlang);@/
@!@:font_}{\.{\\font} primitive@>
primitive("fontdimen",assign_font_dimen,0);@/
@!@:font_dimen_}{\.{\\fontdimen} primitive@>
primitive("semifont",def_font,Rtlang);@/
@!@:semifont_}{\.{\\semifont} primitive@>
primitive("activefont",def_font,Rtlang+1);@/ {only for showing}
@!@:active_font_}{\.{\\activefont} primitive@>
primitive("halign",halign,Lftlang);@/
@!@:halign_}{\.{\\halign} primitive@>
primitive("semihalign",halign,Rtlang);@/
@!@:semihalign_}{\.{\\semihalign} primitive@>
@#
primitive("endinput",input,0);@/
@!@:end_input_}{\.{\\endinput} primitive@>
primitive("input",input,L_to_R);@/
@!@:input_}{\.{\\input} primitive@>
primitive("inputR",input,R_to_L);@/
@!@:input_}{\.{\\inputR} primitive@>
@#
@#
primitive("openoutR",extension,open_R_node);@/
@!@:open_out_R_}{\.{\\openoutR} primitive@>
primitive("leteqname",let_name,normal);@/
@!@:let_eq_name_}{\.{\\leteqname} primitive@>
primitive("letlatinname",let_name,Lftlang);@/
@!@:let_latin_name_}{\.{\\letlatinname} primitive@>
primitive("letsemiticname",let_name,Rtlang);@/
@!@:let_semitic_name_}{\.{\\letsemiticname} primitive@>
primitive("letnoteqname",let_name,LRsw(1)(0));@/
@!@:let_noteq_name_}{\.{\\letnoteqname} primitive@>
primitive("letnoteqchar",let_name,LRsw(1)(1));@/
@!@:let_noteq_char_}{\.{\\letnoteqchar} primitive@>
primitive("letnoteqcharif",let_name,LRsw(1)(2));@/
@!@:let_noteq_charsif_}{\.{\\letnoteqcharif} primitive@>
@#
primitive("lastcharjoinable",LR_setting,LRsw(0)(joinable));@/
@!@:joinable_}{\.{\\lastcharjoinable} primitive@>
primitive("lastcharunjoinable",LR_setting,LRsw(0)(unjoinable));@/
@!@:unjoinable_}{\.{\\lastcharunjoinable} primitive@>
primitive("manLRset",LR_setting,LRsw(1)(manual));@/
@!@:cur_LRswch_loc_}{\.{\\manLRset} primitive@>
primitive("autoLRdirset",LR_setting,LRsw(1)(autoLR));@/
@!@:cur_LRswch_loc_}{\.{\\autoLRdirset} primitive@>
primitive("autofontset",LR_setting,LRsw(1)(autofont));@/
@!@:cur_LRswch_loc_}{\.{\\autofont} primitive@>
primitive("autoLRset",LR_setting,LRsw(1)(automatic));@/
@!@:cur_LRswch_loc_}{\.{\\autoLRset} primitive@>
primitive("latin",LR_setting,LRsw(2)(Lftlang));@/
@!@:latin_}{\.{\\latin} primitive@>
primitive("semitic",LR_setting,LRsw(2)(Rtlang));@/
@!@:semitic_}{\.{\\semitic} primitive@>
primitive("LtoR",LR_setting,LRsw(3)(L_to_R));@/
@!@:L_to_R_}{\.{\\LtoR} primitive@>
primitive("RtoL",LR_setting,LRsw(3)(R_to_L));@/
@!@:R_to_L_}{\.{\\RtoL} primitive@>
primitive("leftvbox",LR_setting,LRsw(4)(L_to_R));@/
@!@:vbox_justify_loc_}{\.{\\leftvbox} primitive@>
primitive("rightvbox",LR_setting,LRsw(4)(R_to_L));@/
@!@:vbox_justify_loc_}{\.{\\rightvbox} primitive@>
primitive("leftinput",LR_setting,LRsw(1000)(0));@/
@!@:left_input_}{\.{\\leftinput} primitive@>
@#
primitive("curLRswch",LR_getting,cur_LRswch_loc);@/
@!@:LR_getting_}{\.{\\curLRswch} primitive@>
primitive("curspeech",LR_getting,cur_speech_loc);@/
@!@:LR_getting_}{\.{\\curspeech} primitive@>
primitive("curdirection",LR_getting,cur_direction_loc);@/
@!@:LR_getting_}{\.{\\curdirection} primitive@>
primitive("curboxdir",LR_getting,vbox_justify_loc);@/
@!@:LR_getting_}{\.{\\curboxdir} primitive@>
primitive("semiday",assign_int,int_base+semi_day_code);@/
primitive("semimonth",assign_int,int_base+semi_month_code);@/
primitive("semiyear",assign_int,int_base+semi_year_code);@/
primitive("fonttwin",switch_font,1);@/
primitive("basefont",switch_font,0);@/
primitive("semifam",assign_int,int_base+dig_fam_code);@/
primitive("hboxR",make_box,vtop_code+hmode+1);@/
@!@:hboxR_}{\.{\\hboxR} primitive@>
@
@<Cases of |print_cmd_chr|...@>=
accent: if chr_code=Lftlang then print_esc("accent")
   else if chr_code=Rtlang then print_esc("semiaccent")
   else if chr_code=Rtlang+1 then print_esc("semiaccentdown")
   else print_esc("retainaccentchar");
char_num: if chr_code=Lftlang then print_esc("char") else print_esc("semichar");
def_font: case chr_code of
   0: print_esc("dblfont");
   LftTag: print_esc("font");
   RtTag: print_esc("semifont");
   RtTag+1: print_esc("activefont");
   end;
ex_space: if chr_code=Lftlang then print_esc(" ") else print_esc(" ");
halign: if chr_code=Lftlang then print_esc("halign") else 
                                 print_esc("semihalign");

@* \[65] Implementing command line options |+commands| and |+strings|.
@d print_cmd_name(#)==pushprinteq; sprint_cs(#); popprinteq
@d print_nlcnt==print_nl(""); incr (cnt)
@d print_name_ln==print_nlcnt; print_cmd_name
@d print_name_lnh==print_nlcnt; was_used [h-hash_base]:=true; print_cmd_name
@d print_cmd_toks==print_char("="); print_cmd_chr(eq_type(h), equiv(h))
@d good_cmd==(not was_used [h-hash_base])
@d tok_prim==((eq_type(h) = assign_toks) and (equiv(h) >= toks_base))
@d int_prim==((eq_type(h) = assign_int) and (equiv(h) >= count_base))
@d dim_prim==((eq_type(h) = assign_dimen) and (equiv(h) >= scaled_base))
@d skp_prim==((eq_type(h) = assign_glue) and (equiv(h) >= skip_base))
@d mus_prim==((eq_type(h) = assign_mu_glue) and (equiv(h) >= mu_skip_base))
@d font_prim==(((eq_type(h) = set_font) and (equiv(h) <> null_font)) or
                  ((eq_type(h) = switch_font)))
@d printcnt==totalcnt := totalcnt + cnt;  print_int(cnt); cnt:=0

@p @!stat function str_to_hash(@!s:str_number) : pointer;
var k:pool_pointer; {index into |str_pool|}
@!j:small_number; {index into |buffer|}
@!l:small_number; {length of the string}
begin 
  k:=str_start[s]; l:=str_start[s+1]-k;@/
  for j:=0 to l-1 do buffer[j]:=so(str_pool[k+j]);@/
  no_new_control_sequence:=true;@/
  str_to_hash:=id_lookup(0,l) - hash_base;@/
  no_new_control_sequence:=false;@/
end;
@#
procedure print_commands;
var h:pointer;
s,e:str_number;
svs,svd,svl:integer;
totalcnt,cnt:integer;
last_hash:integer;
was_used: array [0..hash_size+1] of boolean;
begin svs:=selector; svd:=cur_direction; svl:=cur_speech;
  selector:=log_only; cur_direction:=R_to_L; cur_speech:=Rtlang;
  for h:=0 to hash_size do was_used [h]:=false;
  last_hash:=hash_base+hash_size;
  for h:=hash_base to last_hash do 
      if eq_type(h) = undefined_cs then was_used [h - hash_base] := true;
  for h:=hash_base to last_hash do 
      if length(text(h)) > 60 then was_used [h - hash_base] := true; 
  print_nl("فرمانهایی که تعریف شده به شرح زیر است:");
  print_nl("نویسه‌های فعال عبارتند از:");
  totalcnt:=0; cnt:=0;
  for h:=active_base to single_base-1 do
      if eq_type(h) <> undefined_cs then
         begin print_name_ln(h); print_cmd_toks; end;
  print_nl("تعداد نویسه‌های فعال عبارتند از: "); printcnt;
  print_nl("فرمانهای یک نویسه‌ای عبارتند از:");
  for h:=single_base to hash_base-1 do
      if eq_type(h) <> undefined_cs then
         begin print_name_ln(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای یک نویسه‌ای عبارتند از:"); printcnt;
  print_nl("فرمانهای بدوی عبارتند از:");
  cnt := printprims (was_used,"");
  print_nl("تعداد فرمانهای بدوی عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین بدوی عبارتند از:");
  cnt := printeqprims (was_used,"");
  print_nl("تعداد فرمانهای جانشین بدوی عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین نویسه‌لاتین عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (eq_type(h) = char_given) then
         begin print_name_lnh(h); print_cmd_toks; end; 
  print_nl("تعداد فرمانهای نویسه‌لاتین عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین نویسه عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (eq_type(h) = semi_given) then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای نویسه عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین نویسه‌ریاضی عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (eq_type(h) = math_given) then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای نویسه‌ریاضی عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین جزء عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and tok_prim then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای جانشین جزء عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین شمار عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and int_prim then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای جانشین شمار عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین بعد عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and dim_prim then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای جانشین بعد عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین ملات عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and skp_prim then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای جانشین ملات عبارتند از:"); printcnt;
  print_nl("فرمانهای جانشین ملات‌ریاضی عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and mus_prim then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای جانشین ملات‌ریاضی عبارتند از:"); printcnt;
  print_nl("فرمانهای قلم عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and font_prim then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای قلم عبارتند از:"); printcnt;
  print_nl("فرمانهای شبه بدوی عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (eq_type(h) < call) then
         begin print_name_lnh(h); print_cmd_toks;
               print(" ("); print_int(eq_type(h)); print(") "); end;
  print_nl("تعداد فرمانهای شبه بدوی عبارتند از:"); printcnt;
  print_nl("فرمانهای چند نویسه‌ای عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (eq_type(h) <> eq_name) and (eq_type(h) >= call) then
         begin print_name_lnh(h); print_cmd_toks; end;
  print_nl("تعداد فرمانهای چند نویسه‌ای عبارتند از:"); printcnt;
  print_nl("فرمانهای همنام عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (eq_type(h) = eq_name) then
         begin print_name_lnh(h); print_char("="); print_cmd_name(equiv(h));
         end;
  print_nl("تعداد فرمانهای همنام عبارتند از:"); printcnt;
  print_nl("فرمانهای متفرقه عبارتند از:");
  for h:=hash_base to last_hash do 
      if good_cmd and (text(h) <> null) then
         begin print_name_lnh(h); print_char("="); print_cmd_name(equiv(h));
         end;
  print_nl("تعداد فرمانهای متفرقه عبارتند از:"); printcnt;
  print_nl("تعداد کل فرمانهای تعریف شده عبارتند از:"); print_int(totalcnt); 
  print_nl("فرمانهای تعریف‌نشده عبارتند از:");
  for h:=hash_base to last_hash do 
      if (eq_type(h)=undefined_cs) and (text(h)<>null) then
         begin print_name_lnh(h);
         end;
  print_nl("تعداد فرمانهای تعریف‌نشده عبارتند از:"); printcnt;
  print_nl("تعداد کل فرمانهای نوشته شده عبارتند از:"); print_int(totalcnt); 
  selector:=svs; cur_direction:=svd; cur_speech:=svl;
  print_nl("");
end;

procedure print_strings;
var s:str_number;
svs,f,l:integer;
begin pushprinteq; print_nl("آغاز خروجی رشته‌ها:");
  svs:=selector; selector:=log_only;
  for s:=0 to str_ptr - 1 do
   begin
     f := str_start [s]; l := str_start [s+1];
     print_nl("رشته["); print_int(s); print("]("); print_int(f);
     print_char("-"); print_int(l); print(")=>");
     if (l - f) > 40 then l := f + 40;
     while f < l do begin print_char(str_pool[f]); incr (f); end;
     if l < str_start [s+1] then print("...");
     print_char("<");
  end;
  print_nl("همنویسه‌ها:");
  for f:=0 to 255 do if eqch(f)<>0 then
   begin print_nl("همنویسه«"); print_char (f); print("»=");
         print_char(eqch(f)); print("       "); print_int(f);
         print_char("="); print_int(eqch(f));
   end;
  print_nl("همنویسه‌گرها:");
  for f:=0 to 255 do if eqif(f)<>0 then
   begin print_nl("همنویسه‌گر«"); print_char (f); print("»=");
         print_char(eqif(f)); print("       "); print_int(f);
         print_char("="); print_int(eqif(f));
   end;
   print_nl(""); popprinteq; selector:=svs;
end;
tats
   
@
@<Declare act...@>=
@!init procedure eqprimitive(@!s1,@!s2:str_number);
var k:pool_pointer; {index into |str_pool|}
@!j:small_number; {index into |buffer|}
@!l:small_number; {length of the string}
@!h1,@!h2:integer; {hash address of s1 and s2}
begin 
if s1<256 then h1:=s1+single_base
else  begin k:=str_start[s1]; l:=str_start[s1+1]-k;
  for j:=0 to l-1 do buffer[j]:=so(str_pool[k+j]);
  no_new_control_sequence:=true;
  h1:=id_lookup(0,l);
  no_new_control_sequence:=false;
  if h1 = undefined_control_sequence then 
       fatal_error("Undefined latin primitive");
  end;
if s2<256 then h2:=s2+single_base
else  begin k:=str_start[s2]; l:=str_start[s2+1]-k;
  for j:=0 to l-1 do buffer[j]:=so(str_pool[k+j]);
  h2:=id_lookup(0,l); {|no_new_control_sequence| is |false|}
  flush_string; {we don't want to have the string twice}
  if text(h2) = s2 then begin
    print_err("semitic primitive already defined!"); print(s2); error;
    end;
  text(h2):=s2;
  end;
  geq_define(h2,eq_name,h1);
  alt_str [s1] := s2; alt_str [s2] := -s1;
end;
tini
@ 
@<Put each of \TeX's primitives into the hash table@>=
begineqprimitives(selector);@/
eqprimitive("LtoR","چپ‌براست");@/
eqprimitive("RtoL","راست‌بچپ");@/
eqprimitive("abovedisplayshortskip","فاصله‌کوتاه‌بالای‌نمایش");@/
eqprimitive("abovedisplayskip","فاصله‌بالای‌نمایش");@/
eqprimitive("accent","اکسنت");@/
eqprimitive("accfactor","ضریب‌اعراب");@/
eqprimitive("activefont","قلم‌فعال");@/
eqprimitive("adjdemerits","تنظیم‌بدنمایی");@/
eqprimitive("advance","بیفزابر");@/
eqprimitive("afterassignment","بعدازانتساب");@/
eqprimitive("aftereverydisplay","بعدازهرنمایش");@/
eqprimitive("aftergroup","بعدازگروه");@/
eqprimitive("autoLRdirset","جهت‌یابی‌خودکار");@/
eqprimitive("autofontset","قلم‌یابی‌خودکار");@/
eqprimitive("autoLRset","چپ‌راست‌خودکار");@/
eqprimitive("basefont","قلم‌اصلی");@/
eqprimitive("baselineskip","فاصله‌کرسی");@/
eqprimitive("batchmode","پردازش‌دسته‌ای");@/
eqprimitive("beginL","شروع‌چپ");@/
eqprimitive("beginR","شروع‌راست");@/
eqprimitive("begingroup","شروع‌گروه");@/
eqprimitive("belowdisplayshortskip","فاصله‌کوتاه‌پایین‌نمایش");@/
eqprimitive("belowdisplayskip","فاصله‌پایین‌نمایش");@/
eqprimitive("billions","بیلیونگان");@/
eqprimitive("botmark","علامت‌پایین");@/
eqprimitive("box","کادر");@/
eqprimitive("boxmaxdepth","حداکثرعمق‌کادر");@/
eqprimitive("catcode","کدرده");@/
eqprimitive("char","نویسه‌لاتین");@/
eqprimitive("chardef","تعریف‌نویسه‌لاتین");@/
eqprimitive("cleaders","نشانگرمرکزی");@/
eqprimitive("closein","ببندورودی");@/
eqprimitive("closeout","ببندخروجی");@/
eqprimitive("clubpenalty","جریمه‌سربند");@/
eqprimitive("copy","کپی");@/
eqprimitive("count","شمار");@/
eqprimitive("countdef","تعریف‌شمار");@/
eqprimitive("cr","سخ");@/
eqprimitive("crcr","سخ‌سخ");@/
eqprimitive("csname","نام‌فرمان");@/
eqprimitive("day","روزلاتین");@/
eqprimitive("deadcycles","دوربسته");@/
eqprimitive("def","تر");@/
eqprimitive("delcode","کدجداساز");@/
eqprimitive("delimiter","جداساز");@/
eqprimitive("delimiterfactor","ضریب‌جداساز");@/
eqprimitive("dimen","بعد");@/
eqprimitive("dimendef","تعریف‌بعد");@/
eqprimitive("discretionary","تیره‌گذاری");@/
eqprimitive("displayindent","تورفتگی‌نمایش");@/
eqprimitive("displaywidth","عرض‌نمایش");@/
eqprimitive("divide","تقسیم");@/
eqprimitive("dp","عمق");@/
eqprimitive("dump","تخلیه");@/
eqprimitive("edef","ترگ");@/
eqprimitive("else","گرنه");@/
eqprimitive("end","پایان");@/
eqprimitive("endL","پایان‌چپ");@/
eqprimitive("endR","پایان‌راست");@/
eqprimitive("endcsname","پایان‌نام‌فرمان");@/
eqprimitive("endgroup","پایان‌گروه");@/
eqprimitive("endinput","پایان‌ورودی");@/
eqprimitive("endlinechar","نویسه‌ته‌سطر");@/
eqprimitive("errhelp","کمک‌خطا");@/
eqprimitive("errmessage","پیام‌خطا");@/
eqprimitive("errorcontextlines","سطرمتن‌خطا");@/
eqprimitive("errorstopmode","پردازش‌توقف‌خطا");@/
eqprimitive("escapechar","نویسه‌ویژه");@/
eqprimitive("everycr","هرسخ");@/
eqprimitive("everydisplay","هرنمایش‌لاتین");@/
eqprimitive("everyhbox","هرکادرا");@/
eqprimitive("everyjob","هرکار");@/
eqprimitive("everymath","هرریاضی‌لاتین");@/
eqprimitive("everypar","هربندلاتین");@/
eqprimitive("everysemidisplay","هرنمایش");@/
eqprimitive("everysemimath","هرریاضی");@/
eqprimitive("everysemipar","هربند");@/
eqprimitive("everyvbox","هرکادرو");@/
eqprimitive("exhyphenpenalty","جریمه‌اضافی‌تیره‌بندی");@/
eqprimitive("expandafter","بگسترپس‌از");@/
eqprimitive("fam","خانواده‌لاتین");@/
eqprimitive("fi","رگ");@/
eqprimitive("firstmark","علامت‌اول");@/
eqprimitive("floatingpenalty","جریمه‌شناور");@/
eqprimitive("font","قلم‌لاتین");@/
eqprimitive("fontdimen","بعدقلم");@/
eqprimitive("fontname","نام‌قلم");@/
eqprimitive("fonttwin","همزادقلم");@/
eqprimitive("futurelet","بعدبگذار");@/
eqprimitive("gdef","ترع");@/
eqprimitive("global","عام");@/
eqprimitive("globaldefs","تعاریف‌عام");@/
eqprimitive("halign","ردیف‌الاتین");@/
eqprimitive("hangafter","بعدازسطر");@/
eqprimitive("hangindent","تورفتگی‌ثابت");@/
eqprimitive("hbadness","بدنمایی‌ا");@/
eqprimitive("hbox","کادرا");@/
eqprimitive("hboxR","کادراست");@/
eqprimitive("hfil","پرا");@/
eqprimitive("hfill","پررا");@/
eqprimitive("hfilneg","رفع‌پرا");@/
eqprimitive("hoffset","حاشیه‌ا");@/
eqprimitive("holdinginserts","حفظ‌درج");@/
eqprimitive("hrule","خط‌ا");@/
eqprimitive("hsize","طول‌سطر");@/
eqprimitive("hskip","فاصله‌ا");@/
eqprimitive("hss","هردوا");@/
eqprimitive("ht","ارتفاع");@/
eqprimitive("hyphenation","تیره‌بندی");@/
eqprimitive("hyphenchar","نویسه‌تیره");@/
eqprimitive("hyphenpenalty","جریمه‌تیره‌بندی");@/
eqprimitive("if","گر");@/
eqprimitive("ifLtoR","گرچپ‌براست");@/
eqprimitive("ifRtoL","گرراست‌بچپ");@/
eqprimitive("ifautoLRdir","گرجهت‌یابی‌خودکار");@/
eqprimitive("ifautofont","گرقلم‌یابی‌خودکار");@/
eqprimitive("ifcat","گررده");@/
eqprimitive("ifdim","گربعد");@/
eqprimitive("ifeof","گرته‌پرونده");@/
eqprimitive("iffalse","گرنادرست");@/
eqprimitive("ifhbox","گرکادرا");@/
eqprimitive("ifhmode","گرحالت‌ا");@/
eqprimitive("ifinner","گردرونی");@/
eqprimitive("ifjoinable","گرپیوندپذیر");@/
eqprimitive("iflatin","گرلاتین");@/
eqprimitive("ifleftvbox","گرکادروازچپ");@/
eqprimitive("ifmmode","گرحالت‌ریاضی");@/
eqprimitive("ifnum","گرعدد");@/
eqprimitive("ifodd","گرفرد");@/
eqprimitive("ifcase","گرانواع");@/
eqprimitive("ifonesof","گرانواع‌یکان");@/
eqprimitive("iftensof","گرانواع‌دهگان");@/
eqprimitive("ifhundredsof","گرانواع‌صدگان");@/
eqprimitive("ifthousands","گرهزارگان");@/
eqprimitive("ifmillions","گرمیلیونگان");@/
eqprimitive("ifbillions","گربیلیونگان");@/
eqprimitive("ifprehundreds","گرزیرصدگان");@/
eqprimitive("ifprethousands","گرزیرهزارگان");@/
eqprimitive("ifpremillions","گرزیرمیلیونگان");@/
eqprimitive("ifprebillions","گرزیربیلیونگان");@/
eqprimitive("ifsetlatin","گربگذارلاتین");@/
eqprimitive("ifsetsemitic","گربگذارسمیتیک");@/
eqprimitive("ifsetrawprinting","گربگذارنمایش‌خام");@/
eqprimitive("ifsemiticchar","گرنویسه‌سمیتیک");@/
eqprimitive("ifsplited","گرشکسته");@/
eqprimitive("iftrue","گردرست");@/
eqprimitive("ifvbox","گرکادرو");@/
eqprimitive("ifvmode","گرحالت‌و");@/
eqprimitive("ifvoid","گرتهی");@/
eqprimitive("ifx","گرتام");@/
eqprimitive("ignorespaces","فاصله‌خالی‌راندیده‌بگیر");@/
eqprimitive("immediate","فوری");@/
eqprimitive("indent","تورفتگی");@/
eqprimitive("input","ورودی‌ازچپ");@/
eqprimitive("inputR","ورودی");@/
eqprimitive("insert","درج");@/
eqprimitive("insertpenalties","جریمه‌درج");@/
eqprimitive("interlinepenalty","جریمه‌بین‌سطرها");@/
eqprimitive("jattrib","پیوندپذیری");@/
eqprimitive("jobname","نام‌کار");@/
eqprimitive("kern","دوری");@/
eqprimitive("language","زبان");@/
eqprimitive("lastbox","آخرین‌کادر");@/
eqprimitive("lastcharjoinable","قبلی‌پیوندپذیر");@/
eqprimitive("lastcharunjoinable","قبلی‌پیوندناپذیر");@/
eqprimitive("lastkern","آخرین‌دوری");@/
eqprimitive("lastpenalty","آخرین‌جریمه");@/
eqprimitive("lastskip","آخرین‌فاصله");@/
eqprimitive("inputlineno","شماره‌سطرورودی");@/
eqprimitive("badness","بدنمایی");@/
eqprimitive("latin","لاتین");@/
eqprimitive("lccode","کدکوچک");@/
eqprimitive("lcode","کدمکان");@/
eqprimitive("leaders","نشانگر");@/
eqprimitive("leftvbox","کادروازچپ");@/
eqprimitive("curboxdir","جهت‌کادرجاری");@/
eqprimitive("curdirection","جهت‌نمایش‌جاری");@/
eqprimitive("curLRswch","چپ‌راست‌جاری");@/
eqprimitive("curspeech","زبان‌جاری");@/
eqprimitive("let","بگذار");@/
eqprimitive("linepenalty","جریمه‌سطر");@/
eqprimitive("lineskip","فاصله‌سطرها");@/
eqprimitive("lineskiplimit","حدفاصله‌سطر");@/
eqprimitive("long","بلند");@/
eqprimitive("looseness","گسیختگی");@/
eqprimitive("lower","انتقال‌بپایین");@/
eqprimitive("mag","بزرگ‌نمایی");@/
eqprimitive("maketwin","همزاد");@/
eqprimitive("manLRset","چپ‌راست‌دستی");@/
eqprimitive("mark","علامت");@/
eqprimitive("mathaccent","اعراب‌ریاضی");@/
eqprimitive("mathchar","نویسه‌ریاضی");@/
eqprimitive("mathchardef","تعریف‌نویسه‌ریاضی");@/
eqprimitive("mathcode","کدریاضی");@/
eqprimitive("maxdeadcycles","حداکثرتکرار");@/
eqprimitive("maxdepth","حداکثرعمق‌صفحه");@/
eqprimitive("meaning","معنا");@/
eqprimitive("medmuskip","فاصله‌متوسط‌ریاضی");@/
eqprimitive("message","پیام");@/
eqprimitive("midruleinit","میانخط‌گذاری");@/
eqprimitive("midrulespec","ابعادمیانخط");@/
eqprimitive("millions","میلیونگان");@/
eqprimitive("mkern","دوری‌ریاضی");@/
eqprimitive("month","ماه‌لاتین");@/
eqprimitive("moveleft","انتقال‌بچپ");@/
eqprimitive("moveright","انتقال‌براست");@/
eqprimitive("mskip","فاصله‌ریاضی");@/
eqprimitive("multiply","ضرب");@/
eqprimitive("muskip","میوفاصله");@/
eqprimitive("muskipdef","تعریف‌میوفاصله");@/
eqprimitive("newlinechar","نویسه‌سطرجدید");@/
eqprimitive("noalign","بی‌ردیف");@/
eqprimitive("noexpand","نگستر");@/
eqprimitive("noindent","بدون‌تورفتگی");@/
eqprimitive("nonstopmode","پردازش‌بدون‌توقف");@/
eqprimitive("nullfont","قلم‌تهی");@/
eqprimitive("number","عدد");@/
eqprimitive("omit","حذف");@/
eqprimitive("openin","بازکن‌ورودی‌ازچپ");@/
eqprimitive("openinR","بازکن‌ورودی");@/
eqprimitive("openout","بازکن‌خروجی‌ازچپ");@/
eqprimitive("openoutR","بازکن‌خروجی");@/
eqprimitive("or","یا");@/
eqprimitive("outer","برونی");@/
eqprimitive("output","صفحه‌بندی");@/
eqprimitive("outputpenalty","جریمه‌صفحه‌بندی");@/
eqprimitive("overfullrule","علامت‌سرریز");@/
eqprimitive("pagedepth","عمق‌صفحه");@/
eqprimitive("pagefilllstretch","کشش‌پرررصفحه");@/
eqprimitive("pagefillstretch","کشش‌پررصفحه");@/
eqprimitive("pagefilstretch","کشش‌پرصفحه");@/
eqprimitive("pagegoal","غایت‌صفحه");@/
eqprimitive("pageshrink","فشردگی‌صفحه");@/
eqprimitive("pagestretch","کشش‌صفحه");@/
eqprimitive("pagetotal","جمع‌صفحه");@/
eqprimitive("par","بند");@/
eqprimitive("parfillskip","فاصله‌ته‌بند");@/
eqprimitive("parindent","تورفتگی‌سربند");@/
eqprimitive("parshape","شکل‌بند");@/
eqprimitive("parskip","فاصله‌بند");@/
eqprimitive("patterns","الگوها");@/
eqprimitive("pausing","مکث");@/
eqprimitive("penalty","جریمه");@/
eqprimitive("postdisplaypenalty","جریمه‌پس‌نمایش");@/
eqprimitive("predisplaypenalty","جریمه‌پیش‌نمایش");@/
eqprimitive("predisplaysize","اندازه‌پیش‌نمایش");@/
eqprimitive("pretolerance","پیش‌حدبدنمایی");@/
eqprimitive("prevdepth","عمق‌قبلی");@/
eqprimitive("prevgraf","بندقبلی");@/
eqprimitive("radical","رادیکال");@/
{eqprimitive("rawprinting","نمایش‌خام");}
{eqprimitive("eqprinting","نمایش‌جانشین");}
eqprimitive("raise","انتقال‌ببالا");@/
eqprimitive("read","بخوان");@/
eqprimitive("relax","راحت");@/
eqprimitive("leftskip","فاصله‌ابتدای‌سطر");@/
eqprimitive("rightskip","فاصله‌انتهای‌سطر");@/
eqprimitive("rightvbox","کادروازراست");@/
eqprimitive("leftinput","خواندن‌ازچپ");@/
eqprimitive("romannumeral","عددرومی");@/
eqprimitive("scriptfont","قلم‌توان");@/
eqprimitive("scriptscriptfont","قلم‌توان‌توان");@/
eqprimitive("scrollmode","پردازش‌گذری");@/
eqprimitive("semiaccent","اعراب");@/
eqprimitive("semiaccentdown","اعراب‌زیر");@/
eqprimitive("retainaccentchar","حفظ‌پایه‌اعراب");@/
eqprimitive("semichar","نویسه");@/
eqprimitive("semichardef","تعریف‌نویسه");@/
eqprimitive("semiday","روز");@/
eqprimitive("semifam","خانواده");@/
eqprimitive("dblfont","قلم‌دوبل");@/
eqprimitive("semifont","قلم");@/
eqprimitive("semihalign","ردیف‌ا");@/
eqprimitive("semimonth","ماه");@/
eqprimitive("semispaceskip","فاصله‌کلمات");@/
eqprimitive("semitic","سمیتیک");@/
eqprimitive("semixspaceskip","فاصله‌اضافی‌کلمات");@/
eqprimitive("semiyear","سال");@/
eqprimitive("setbox","درکادر");@/
eqprimitive("sfcode","کدضریب‌فاصله");@/
eqprimitive("shipout","بفرست");@/
eqprimitive("show","نمایش‌بده");@/
eqprimitive("showbox","نمایش‌بده‌کادر");@/
eqprimitive("showboxbreadth","میزان‌نمایش‌کادر");@/
eqprimitive("showboxdepth","عمق‌نمایش‌کادر");@/
eqprimitive("showlists","نمایش‌بده‌لیستها");@/
eqprimitive("showthe","نمایش‌بده‌محتوای");@/
eqprimitive("skewchar","نویسه‌اریب");@/
eqprimitive("skip","فاصله");@/
eqprimitive("skipdef","تعریف‌فاصله");@/
eqprimitive("spacefactor","ضریب‌فاصله");@/
eqprimitive("spaceskip","فاصله‌کلمات‌لاتین");@/
eqprimitive("span","ادغام");@/
eqprimitive("special","ویژه");@/
eqprimitive("splitmaxdepth","حداکثرعمق‌ستون");@/
eqprimitive("splittopskip","فاصله‌بالای‌ستون");@/
eqprimitive("string","رشته");@/
eqprimitive("tabskip","فاصله‌ستونها");@/
eqprimitive("textfont","قلم‌متن");@/
eqprimitive("the","محتوای");@/
eqprimitive("thickmuskip","فاصله‌زیادریاضی");@/
eqprimitive("thinmuskip","فاصله‌کم‌ریاضی");@/
eqprimitive("thousands","هزارگان");@/
eqprimitive("time","زمان");@/
eqprimitive("toks","جزء");@/
eqprimitive("toksdef","تعریف‌جزء");@/
eqprimitive("tolerance","حدبدنمایی");@/
eqprimitive("topmark","علامت‌بالا");@/
eqprimitive("topskip","فاصله‌بالا");@/
eqprimitive("tracingcommands","ردگیری‌فرامین");@/
eqprimitive("tracinglostchars","ردگیری‌حروف");@/
eqprimitive("tracingmacros","ردگیری‌ماکروها");@/
eqprimitive("tracingonline","ردگیری‌نمایشی");@/
eqprimitive("tracingoutput","ردگیری‌صفحه‌بندی");@/
eqprimitive("tracingpages","ردگیری‌صفحات");@/
eqprimitive("tracingparagraphs","ردگیری‌بندها");@/
eqprimitive("tracingrestores","ردگیری‌بازگردانی");@/
eqprimitive("tracingstats","ردگیری‌آمارها");@/
eqprimitive("twinfont","قلم‌همزاد");@/
eqprimitive("uccode","کدبزرگ");@/
eqprimitive("uchyph","تیره‌بندی‌بزرگ");@/
eqprimitive("unhbox","بی‌کادرا");@/
eqprimitive("unhcopy","بی‌کپی‌ا");@/
eqprimitive("unkern","برگشت‌دوری");@/
eqprimitive("unpenalty","برگشت‌جریمه");@/
eqprimitive("unskip","برگشت‌فاصله");@/
eqprimitive("unvbox","بی‌کادرو");@/
eqprimitive("unvcopy","بی‌کپی‌و");@/
eqprimitive("vadjust","تنظیم‌و");@/
eqprimitive("valign","ردیف‌و");@/
eqprimitive("vbadness","بدنمایی‌و");@/
eqprimitive("vbox","کادرو");@/
eqprimitive("vboxjustification","تنظیم‌جهت‌کادرو");@/
eqprimitive("LRshowswitch","تنظیمهای‌نمایشی");@/
eqprimitive("LRmiscswitch","تنظیمهای‌متفرقه");@/
eqprimitive("vcenter","کادروسط");@/
eqprimitive("vfil","پرو");@/
eqprimitive("vfill","پررو");@/
eqprimitive("vfilneg","رفع‌پرو");@/
eqprimitive("voffset","حاشیه‌و");@/
eqprimitive("vrule","خط‌و");@/
eqprimitive("vsize","طول‌صفحه");@/
eqprimitive("vskip","فاصله‌و");@/
eqprimitive("vsplit","شکست‌و");@/
eqprimitive("vss","هردوو");@/
eqprimitive("vtop","کادرگود");@/
eqprimitive("wd","عرض");@/
eqprimitive("widowpenalty","جریمه‌ته‌بند");@/
eqprimitive("write","بنویس");@/
eqprimitive("eqwrite","بنویس‌همنویس");@/
eqprimitive("xdef","ترگع");@/
eqprimitive("xleaders","نشانگرگسترشی");@/
eqprimitive("xspaceskip","فاصله‌اضافی‌کلمات‌لاتین");@/
eqprimitive("year","سال‌لاتین");@/
eqprimitive("letlatinname","بگذاربه‌لاتین");@/
eqprimitive("letsemiticname","بگذاربه‌سمیتیک");@/
eqprimitive("leteqname","بگذارهمنام");@/
eqprimitive("eqchar","همنویسه");@/
eqprimitive("eqcharif","همنویسه‌گر");@/
eqprimitive("letnoteqname","بگذارناهمنام");@/
eqprimitive("letnoteqchar","بگذارناهمنویسگان");@/
eqprimitive("letnoteqcharif","بگذارناهمنویسگان‌گر");@/
eqprimitive("emergencystretch","کشش‌لاجرم");@/
eqprimitive("hfuzz","پرزافقی");@/
eqprimitive("vfuzz","پرزعمودی");@/
eqprimitive("endspecial","پایان‌ویژه");@/
eqprimitive("beginspecial","شروع‌ویژه");@/
make_eqstr;

@ Putting non-command equivalent strings are made with procedure |make_eqstr|
by initex program.

@d end_eqs(#)==#
@d eqs(#)==alt_str[#]:=end_eqs

@p @!init procedure make_eqstr;
begin
eqs("-")("-");@/
eqs("+")("+");@/
eqs("=")("=");@/
eqs(" ")(" ");@/
eqs("*")("*");@/
eqs("{")("{");@/
eqs("\")("\");@/
eqs("}")("}");@/
eqs("&")("&");@/
eqs("#")("#");@/
eqs("%")("٪");@/
eqs(".")(".");@/
eqs(",")("،");@/
eqs(";")("؛");@/
eqs(":")(":");@/
eqs("?")("؟");@/
eqs("!")("!");@/
eqs(">")("<");@/
eqs("(")("(");@/
eqs(")")(")");@/
eqs("[")("[");@/
eqs("]")("]");@/
eqs("|")("|");@/
eqs("0")("۰");@/
eqs("1")("۱");@/
eqs("2")("۲");@/
eqs("3")("۳");@/
eqs("4")("۴");@/
eqs("5")("۵");@/
eqs("6")("۶");@/
eqs("7")("۷");@/
eqs("8")("۸");@/
eqs("9")("۹");@/
eqs("'")("»");@/
eqs("l")("ر");@/
eqs("at")("دراندازه");@/
eqs("bp")("بزرگ‌پونت");@/
eqs("cc")("سیسرو");@/
eqs("cm")("سانت");@/
eqs("dd")("دیدو");@/
eqs("depth")("عمق");@/
eqs("em")("ام");@/
eqs("ex")("اکس");@/
eqs("height")("ارتفاع");@/
eqs("in")("اینچ");@/
eqs("minus")("منهای");@/
eqs("mm")("میلی‌متر");@/
eqs("pc")("پیکا");@/
eqs("plus")("باضافه");@/
eqs("scaled")("باضریب");@/
eqs("sp")("اس‌پی");@/
eqs("spread")("بعلاوه");@/
eqs("to")("به");@/
eqs("true")("درست");@/
eqs("width")("عرض");@/
eqs("  ")("  ");@/
eqs(" (")(" (");@/
eqs(" (\output routine)")(" (روال \صفحه‌بندی)");@/
eqs(" (for accent)")(" (برای اعراب)");@/
eqs(" (held over for next output)")("میشود) (برای خروجی بعدی نگه‌داشته ");@/
eqs(" (language")("زبان) ");@/
eqs(" (ligature ")(" (لیگاتور ");@/
eqs(" (see the transcript file)")(" (پرونده کارنامه را ببینید)");@/
eqs(" )")(" )");@/
eqs(" -> @@@@")("ـ‍< @@@@");@/
eqs(" []")(" []");@/
eqs(" \hbox (badness ")(" (بدنمایی ");@/
eqs(" \vbox (badness ")(" (بدنمایی ");@/
eqs(" adds ")(" اضافات ");@/
eqs(" after: ")(" بعد از عمل: ");@/
eqs(" at ")(" دراندازه ");@/
eqs(" b=")(" ب=");@/
eqs(" bytes).")(" بایت).");@/
eqs(" c=")(" ه‍=");@/
eqs(" columns)")(" ستون)");@/
eqs(" command, corrected")(" نامتوازن، اصلاح گردید");@/
eqs(" command, ignored")(" اضافی، نادیده گرفته میشود");@/
eqs(" d=")(" ک=");@/
eqs(" doesn't match its definition")(" با تعریف آن مطابقت ندارد");@/
eqs(" extra")(" اضافی");@/
eqs(" for language ")(" برای زبان ");@/
eqs(" g=")(" ا=");@/
eqs(" goal height ")(" ارتفاع مورد نظر ");@/
eqs(" has ")(" دارای ");@/
eqs(" has an extra }")(" دارای } اضافی است");@/
eqs(" in font ")(" در قلم ");@/
eqs(" line")(" سطر");@/
eqs(" memory locations dumped; current usage is ")@/
(" خانه از حافظه تخلیه شد؛ مورد استفاده فعلی عبارتست از ");@/
eqs(" might split")(" ممکن است شکسته شود");@/
eqs(" minus ")(" منهای ");@/
eqs(" multiletter control sequences")(" واژه کنترلی چندحرفی");@/
eqs("! ")("! ");@/
eqs(" on line ")(" در سطر ");@/
eqs(" op")(" برنامه است");@/
eqs(" out of ")(" از ");@/
eqs(" p=")(" ج=");@/
eqs(" page")(" صفحه");@/
eqs(" plus ")(" باضافه ");@/
eqs(" preloaded font")(" قلم وارد شده");@/
eqs(" replacing ")(" جایگزین ");@/
eqs(" strings of total length ")(" رشته به طول کلی ");@/
eqs(" t=")(" م=");@/
eqs(" the previous value will be retained")(" مقدار قبلی حفظ خواهد شد");@/
eqs(" via @@@@")("ازطریق @@@@");@/
eqs(" was complete")(" تمام شود پاراگراف به پایان رسید");@/
eqs(" was incomplete)")(" هنوز کامل نشده بود)");@/
eqs(" words of font info for ")(" خانه از اطلاعات قلمها برای ");@/
eqs("### ")("### ");@/
eqs("### current page:")("### صفحه جاری:");@/
eqs("### recent contributions:")("### ملحقات اخیر:");@/
eqs("%% goal height=")("٪٪ ارتفاع مورد نظر=");@/
eqs("' after ")("» را پس از ");@/
eqs("' in ")("» را در ");@/
eqs("' or `")("» یا «");@/
eqs("' with `")("» با «");@/
eqs("(Please type a command or say `\end')")@/
("(یا دستوری وارد کنید یا بنویسید «\پایان»)");@/
eqs("(\dump is performed only by INITEX)")@/
("(\تخلیه فقط بوسیله تک خام میتواند اجرا شود)");@/
eqs("(see the transcript file for additional information)")@/
("(برای اطلاعات بیشتر به پرونده کارنامه مراجعه کنید)");@/
eqs("(That makes 100 errors; please try again.)")@/
("(این شد ۱۰۰ اشتباه؛ دوباره سعی کنید.)");@/
eqs("(interwoven alignment preambles are not allowed)")@/
("(الگوهای متداخل بهنگام تعریف ردیف مجاز نیستند)");@/
eqs(") ")(") ");@/
eqs(") detected at line ")(") در سطر ");@/
eqs(") has occurred while \output is active")@/
(") وقتیکه \صفحه‌بندی در حال عمل بود، بوقوع پیوست");@/
eqs(") in alignment at lines ")(") در ردیف‌بندی سطرهای ");@/
eqs(") in paragraph at lines ")(") در پاراگراف سطرهای ");@/
eqs("), should be at most ")(")، میبایست حداکثر ");@/
eqs("), should be in the range 0..")(")، میبایست در فاصله ۰ الا ");@/
eqs(");")(")؛");@/
eqs(")x")(")×");@/
eqs("**")("**");@/
eqs("*** (cannot \read from terminal in nonstop modes)")@/
("*** (در حالت بدون توقف نمیتوان از پایانه چیزی خواند)");@/
eqs("*** (job aborted, file error in nonstop mode)")@/
("*** (کار قطع شد، اشکال مربوط به پرونده در حالت بدون توقف)");@/
eqs("*** (job aborted, no legal \end found)")@/
("*** (کار قطع میشود، هیچ \پایان معتبری یافته نشد)");@/
eqs(", ")("، ");@/
eqs(", #")("، #");@/
eqs(", current language ")("، زبان جاری ");@/
eqs(", glue set ")("، مقدار ملات ");@/
eqs(", left justified")("، از چپ");@/
eqs(", max depth=")("، حداکثر عمق=");@/
eqs(", natural size ")("، اندازه طبیعی ");@/
eqs(", prevgraf ")("، بندقبلی ");@/
eqs(", right justified")("، از راست");@/
eqs(", shifted ")("، شیفت‌یافته ");@/
eqs(", shrink ")("، فشردگی ");@/
eqs(", stretch ")("، کشیدگی ");@/
eqs(", surrounded ")("، احاطه‌شده ");@/
eqs("- ")("- ");@/
eqs("--")("--");@/
eqs("->")("-<");@/
eqs("...")("...");@/
eqs(": ")(": ");@/
eqs(": line ")(": سطر ");@/
eqs(":hyphenmin")(":حداقل");@/
eqs("; all text was ignored after line ")(" ناقص؛ تمامی متن پس از سطر ");@/
eqs("; split(")("؛ شکست(");@/
eqs("; still untouched: ")("؛ دست نخورده: ");@/
eqs("; all text was ignored after line ")(" ناقص؛ تمامی متن پس از سطر ");@/
eqs("< -")("> -");@/
eqs("<*>")(">*<");@/
eqs("<-")(">ـ‍");@/
eqs("=>")("=<");@/
eqs("<aftereverydisplay> ")(">بعدازهرنمایش< ");@/
eqs("<argument> ")(">آرگومان< ");@/
eqs("<everycr> ")(">هرسخ< ");@/
eqs("<everydisplay> ")(">هرنمایش‌لاتین< ");@/
eqs("<everyhbox> ")(">هرکادرا< ");@/
eqs("<everyjob> ")(">هرکار< ");@/
eqs("<everymath> ")(">هرریاضی‌لاتین< ");@/
eqs("<everypar> ")(">هربندلاتین< ");@/
eqs("<everysemidisplay> ")(">هرنمایش< ");@/
eqs("<everysemimath> ")(">هرریاضی< ");@/
eqs("<everysemipar> ")(">هربند< ");@/
eqs("<everyvbox> ")(">هرکادرو< ");@/
eqs("<insert> ")(">درج< ");@/
eqs("<inserted text> ")(">متن درج‌شده< ");@/
eqs("<mark> ")(">علامت< ");@/
eqs("<output> ")(">صفحه‌بندی< ");@/
eqs("<read ")(">بخوان ");@/
eqs("<recently read> ")(">اخیراً خوانده‌شده< ");@/
eqs("<template> ")(">الگوی‌نمونه< ");@/
eqs("<to be read again> ")(">بناست دوباره خوانده‌شود< ");@/
eqs("<write> ")(">بنویس< ");@/
eqs("=from ")("=از ");@/
eqs("? ")("؟ ");@/
eqs("?.?")("؟.؟");@/
eqs("@@")("@@");@/
eqs("@@@@")("@@@@");@/
eqs("@@firstpass")("@@گذراول");@/
eqs("@@secondpass")("@@گذردوم");@/
eqs("AVAIL list clobbered at ")("لیست موجودی در خانه ");@/
eqs("Argument of ")("آرگومان ");@/
eqs("Arithmetic overflow")("سرریز ریاضی");@/
eqs("BAD.")("بد.");@/
eqs("Bad character code")("کد نویسه نامناسب");@/
eqs("Bad command name")("نام فرمان نامناسب");@/
eqs("Bad delimiter code")("کد جداساز نامناسب");@/
eqs("Bad flag at ")("علامت نامناسب در خانه ");@/
eqs("Bad link, display aborted.")("اتصال نامناسب، نمایش قطع میشود.");@/
eqs("Bad mathchar")("نویسهٔ ریاضی نامناسب");@/
eqs("Bad number")("عدد نامناسب");@/
eqs("Bad register code")("کد ثبات نامناسب");@/
eqs("Bad space factor")("ضریب فاصله نامناسب");@/
eqs("Beginning to dump on file ")("آغاز تخلیه بر روی پرونده ");@/
eqs("CLOBBERED.")("درهم‌ریخته.");@/
eqs("Completed box being shipped out")("کادر کامل‌شده بیرون فرستاده میشود");@/
eqs("DVI output file")("پرونده دی‌وی‌آی خروجی");@/
eqs("Dimension too large")("بعد بسیار بزرگ");@/
eqs("Double-AVAIL list clobbered at ")("لیست موجودی-دوبل در خانه ");@/
eqs("Doubly free location at ")("خانه آزاد مکرر در شماره ");@/
eqs("EQUIV(")("معادل(");@/
eqs("ETC.")("وغیره.");@/
eqs("Emergency stop")("توقف اضطراری");@/
eqs("End of file on the terminal!")("پایان پرونده روی پایانه!");@/
eqs("Extra ")("اضافی ");@/
eqs("I'm ignoring this; it doesn't match any \if.")@/
   ("این به هیچ \گر ی منطبق نیست؛ آنرا نادیده می‌گیرم.");@/
eqs("Extra alignment tab has been changed to ")("علامت & اضافی به ");@/
eqs("FONT")("ق‌ل‌م‌لاتین");@/
eqs("Hyphenation trie of length ")("درخت تیره‌بندی بطول ");@/
eqs("I can't find file `")("نمیتوانم پرونده «");@/
eqs("I can't go on meeting you like this")@/
("من دیگر نمیتوانم اینگونه به کار با شما ادامه دهم");@/
eqs("I can't write on file `")("نمیتوانم بر روی پرونده «");@/
eqs("I've inserted something that you may have forgotten.")@/
("چیزی که ممکن است فراموش کرده باشید اضافه کرده‌ام");
eqs("(See the <inserted text> above.)")
("(>متن درج‌شده< در فوق را ببینید.)");@/
eqs("With luck, this will get me unwedged. But if you")@/
("این احتمالاً می‌تواند باعث ادامهٔ کار شود. ولی اگر واقعاً");@/
eqs("really didn't forget anything, try typing `2' now; then")@/
("چیزی را فراموش نکرده‌اید هم‌اکنون «۲» را بزنید تا");@/
eqs("my insertion and my current dilemma will both disappear.")@/
("متن اضافه شده و عنصر ناهنجار نادیده گرفته شود.");@/
eqs("IMPOSSIBLE.")("غیرممکن.");@/
eqs("INFO(")("اطلاع(");@/
eqs("Illegal magnification has been changed to 1000")@/
("بزرگنمایی غیرقانونی، به ۱۰۰۰ تغییر داده‌شد");@/
eqs("Illegal unit of measure (")("واحد اندازه‌گیری نامناسب(");@/
eqs("Illegal parameter number in definition of ")@/
("شمارهٔ پارامتر در تعریف «");@/
eqs("Improper use of `\activefont', ignored")@/
("استفاده نادرست از «\قلم‌فعال»، نادیده گرفته میشود.");@/
eqs("Invalid font identifier, ignored.")@/
("اسم پرونده نادرست، نادیده گرفته میشود");@/
eqs("Improper `at' size (")("«دراندازه» نامناسب (");@/
eqs("Improper alphabetic constant")("ثابت الفبایی نامناسب");@/
eqs("Incompatible list can't be unboxed")@/
("نمیتوان کادر ناسازگار را باز نمود");@/
eqs("Incompatible magnification (")("بزرگنمایی ناسازگار (");@/
eqs("Interruption")("وقفــــــــه");@/
eqs("Invalid code (")("کد نامناسب (");@/
eqs("LINK(")("اتصال(");@/
eqs("Leaders not followed by proper glue")@/
("نشانگری که ملات مناسب در پی ندارد");@/
eqs("Memory usage before: ")("کارکرد با حافظه قبل از عمل: ");@/
eqs("Missing ")(" «");
eqs(" inserted")("» مفقود اضافه شد");
eqs("Missing # inserted in alignment preamble")@/
("«#» مفقود در الگوی ردیف‌بندی درج گردید");@/
eqs("Missing = inserted for ")("= مفقود برای ");@/
eqs("Missing `to' inserted")("«به» مفقود درج گردید");@/
eqs("Missing character: There is no ")("نویسه ناموجود: نویسه ");@/
eqs("Missing control sequence inserted")("واژه کنترلی مفقود درج گردید");@/
eqs("Missing font identifier")("شناسهٔ قلم مفقود");
eqs("Missing number, treated as zero")("عدد مفقود، به مثابه صفر عمل گردید");@/
eqs("Missing { inserted")("«{»ی مفقود اضافه شد");
eqs("Missing } inserted")("«}»ی مفقود اضافه شد");
eqs("NONEXISTENT.")("ناموجود.");@/
eqs("New busy locs:")("خانه‌هایی که جدیداً اشغال شده‌اند عبارتند از:");@/
eqs("No pages of output.")("بدون هیچ صفحه خروجی.");@/
eqs("Number too big")("عدد بسیار بزرگ");@/
eqs("OK")("بسیار خوب");@/
eqs("OK, entering ")("بسیار خوب، وارد حالت ");@/
eqs("Only one # is allowed per tab")("بازای هر & تنها یک # مجاز است");@/
eqs("Output written on ")("خروجی بر روی پرونده ");@/
eqs("Overfull \hbox (")("\کادرا ی سرپر (");@/
eqs("Overfull \vbox (")("\کادرو ی سرپر (");@/
eqs("Paragraph ended before ")("قبل از اینکه ");@/
eqs("Parameters must be numbered consecutively")@/
("پارامترها بایستی به ترتیب شماره‌گذاری شوند");@/
eqs("Patterns can be loaded only by INITEX")@/
("الگوها تنها بوسیله تک خام میتوانند وارد شوند.");@/
eqs("Please type another ")("لطفاً نام دیگری را بعنوان پرونده ");@/
eqs("Please type the name of your input file.")@/
("لطفا نام پرونده‌ای را وارد کنید.");@/
eqs("SAVE(")("SAVE(");@/
eqs("SEMIFONT")("ق‌ل‌م");@/
eqs("TWINFONT")("ق‌ل‌م‌همزاد");@/
eqs("Text line contains an invalid character")@/
("متن حاوی یک نویسه غیرمعتبر است");@/
eqs("Transcript written on ")("کارنامه بر روی پرونده ");@/
eqs("The following box has been deleted:")("کادر ذیل حذف شده‌است:");@/
eqs("This can't happen (")("این نمیتواند اتفاق افتاده باشد (");@/
eqs("Tight \hbox (badness ")("\کادرا ی فشرده (بدنمایی ");@/
eqs("Tight \vbox (badness ")("\کادرو ی فشرده (بدنمایی ");@/
eqs("Too many }'s")("«}»ی اضافی");@/
eqs("You've closed more groups than you opened.")@/
("تعداد گروههای بسته شده بیش از گروههای باز شده است.");@/
eqs("Such booboos are generally harmless, so keep going.")@/
("در حالت معمولی این مساله مشکلی ایجاد نمی‌کند، بنابراین ادامه دهید.");@/
eqs("Transcript written on ")("کارنامه بر روی پرونده ");@/
eqs("Unbalanced ")("فرمان ");@/
eqs("Unbalanced write command")("فرمان بنویس نامتوازن");@/
eqs("Unbalanced output routine")("روال صفحه‌بندی نامتوازن");@/
eqs("Your sneaky output routine has problematic {'s and/or }'s.")@/
("آکولادهای باز و یا بسته روال صفحه‌بندی مشکل دارد");@/
eqs("I can't handle that very well; good luck.")@/
("نمی‌توانم این مشکل را بخوبی برطرف کنم؛ خوش باشید. ");@/
eqs("Undefined control sequence")("واژه کنترلی تعریف‌نشده");@/
eqs("Unknown node type!")("نوع گره ناشناخته!");@/
eqs("Unmatched ")("فرمان ");@/
eqs("Use of ")("استفاده از ");@/
eqs("You already have nine parameters")@/
("تا کنون تعداد ۹ پارامتر تعریف کرده‌اید");@/
eqs("You can't dump inside a group")@/
("شما نمیتوانید درون یک گروه مبادرت به تخلیه نمایید");@/
eqs("You can't use a prefix with `")("شما یک پیشوند را نمیبایست با «");@/
eqs("You can't use `")("شما نمیتوانید «");@/
eqs("[]")("[]");@/
eqs("[unknown command code!]")("[کد فرمان ناشناخته!]");@/
eqs("[unknown dimen parameter!]")("[پارامتر بعد ناشناخته!]");@/
eqs("[unknown extension!]")("[گسترش ناشناخته!]");@/
eqs("[unknown integer parameter!]")("[پارامتر رقمی ناشناس!]");@/
eqs("\endL or \endR problem (")("اشکالات مربوط به \پایان‌چپ یا \پایان‌راست (");@/
eqs("\font")("\قلم");@/
eqs("active ")(" فعال ");@/
eqs("alignment tab character ")("نویسه فاصله ردیف‌بندی ");@/
eqs("argument")("آرگومان");@/
eqs("begin-group character ")("نویسه شروع گروه ");@/
eqs("bi_directional typesetting")("حروفچینی دوجهته");@/
eqs("buffer size")("اندازه میانگیر");@/
eqs("current active font")("قلم فعال جاری");@/
eqs("current latin font")("قلم لاتین جاری");@/
eqs("current semitic font")("قلم سمیتیک جاری");@/
eqs("current vbox justification")("جهت استقرار کادرو");@/
eqs("definition")("تعریف");@/
eqs("display math")("نمایش ریاضی");@/
eqs("end occurred ")("پایان ");@/
eqs("end of alignment template")("پایان الگوی ردیف‌بندی");@/
eqs("end-group character ")("نویسه پایان گروه ");@/
eqs("etc.")("وغیره.");@/
eqs("fil")("پر");@/
eqs("fill")("پرر");@/
eqs("filll")("پررر");@/
eqs("foul")("خطا");@/
eqs("glue")("ملات");@/
eqs("grouping levels")("رده‌های گروه‌بندی");@/
eqs("hash size")("اندازه hash");@/
eqs("horizontal")("افقی");@/
eqs("ignored")("چشم پوشی‌شد");@/
eqs("input stack size")("اندازه پشته ورودی");@/
eqs("insert>")("درج<");@/
eqs("inside a group at level ")(" درون یک گروه در رده ");@/
eqs("internal vertical")("عمودی داخلی");@/
eqs("l.")("سطر:");@/
eqs("latin blank space ")("فاصله خالی لاتین ");@/
eqs("left")("چپ");@/
eqs("macro parameter character ")("نویسه پارامتر ");@/
eqs("macro")("ماکرو");@/
eqs("main memory size")("اندازهٔ حافظهٔ اصلی");@/
eqs("manual")("دستی");@/
eqs("autoerr")("خظایابی");
eqs("autodir")("جهت‌یابی");
eqs("autopar")("سربند");
eqs("autocol")("ستون‌جدول");
eqs("manrbox")("کادراست");
eqs("automath")("فرمول");
eqs("math shift character ")("نویسه حالت ریاضی ");@/
eqs("math")("ریاضی");@/
eqs("missing, ")(" کم، ");@/
eqs("mu inserted)")("میو درج گردید)");@/
eqs("mu")("میو");@/
eqs("no")("هیچ");@/
eqs("normal")("عادی");@/
eqs("number of strings")("تعداد رشته‌ها");@/
eqs("off")(" انتهای");@/
eqs("on")(" ابتدای");@/
eqs("penalty ")("جریمه ");@/
eqs("pool size")("اندازه مخزن");@/
eqs("preamble")("الگوی");@/
eqs("prevdepth ")("عمق‌قبلی ");@/
eqs("pt inserted)")("پونت درج گردید)");@/
eqs("pt too high")("پونت بلندتر");@/
eqs("pt too wide")("پونت عریض‌تر");@/
eqs("pt")("پونت");@/
eqs("pt), replaced by 10pt")("پونت)، به ۱۰پونت تغییر داده شد");@/
eqs("replaced by filll)")("با پررر جایگزین گردید)");@/
eqs("restricted horizontal")("افقی محدود");@/
eqs("right")("راست");@/
eqs("rule(")("خط(");@/
eqs("save size")("اندازه save");@/
eqs("select main semitic font ")("گزینش قلم اصلی سمیتیک ");@/
eqs("select latin font ")("گزینش قلم لاتین ");@/
eqs("select twin semitic font ")("گزینش قلم همزاد سمیتیک ");@/
eqs("semantic nest size")("اندازه لایه‌های معنایی");@/
eqs("semitic blank space ")("فاصله خالی سمیتیک ");@/
eqs("spacefactor ")("ضریب‌فاصله ");@/
eqs("subscript character ")("نویسه اندیس پایین ");@/
eqs("superscript character ")("نویسه توان بالا ");@/
eqs("supressed ")(" غیرفعال ");@/
eqs("switch base font ")("جایگزینی قلم اصلی ");@/
eqs("switch twin font ")("جایگزینی قلم همزاد ");@/
eqs("text input levels")("رده‌های ورود متن");@/
eqs("text")("متن");@/
eqs("the latin character ")("نویسه لاتین ");@/
eqs("the latin letter ")("حرف‍ لاتین ");@/
eqs("the semitic character ")("نویسه سمیتیک ");@/
eqs("the semitic letter ")("حرف سمیتیک ");@/
eqs("this will be denominator of:")("این عبارتست از مخرج:");@/
eqs("total height ")("ارتفاع کل ");@/
eqs("undefined")("تعریف‌نشده");@/
eqs("use")("بکارگیری");@/
eqs("vertical")("عمودی");@/
eqs("void")("تهی");@/
eqs("whatsit?")("چی‌چی؟");@/
eqs("when ")(" وقتی بوقوع پیوست که ");@/
eqs("{}")("{}");@/
eqs("{case ")("{نوع ");@/
eqs("{false}")("{نادرست}");@/
eqs("{true}")("{درست}");@/
eqs(banner)("TeX-پارسی گونه ۳٫۰۱۹؛ محصول شرکت داده‌کاوی ایران");@/
eqs(initex)(" (تک خام)");@/
eqs(noformat)(" (بدون شکلبندی قبلی)");@/
eqs("I have just deleted some text, as you asked.")@/
("من هم‌اکنون، بنابر درخواست شما قسمتی از متن را حذف نمودم.");@/
eqs("You can now delete more, or insert, or whatever.")@/
("اکنون می‌توانید مقدار بیشتری حذف یا درج یا هر کار دیگری بنمائید.");@/
eqs("Sorry, I don't know how to help in this situation.")@/
      ("متأسفم، در این وضعیت کمکی از من ساخته نیست.");@/
eqs("Sorry, I already gave what help I could...")@/
     ("متأسفم، من قبلاً کمکی را که از دستم بر میامد ارائه نمودم.");@/
eqs("Maybe you should try asking a human?")@/
     ("شاید بهتر باشد از یک انسان کمک بخواهید؟");@/
eqs("An error might have occurred before I noticed any problems.")@/
     ("ممکن است پیش از آنکه من متوجه اشکالی شوم، اشتباهی رخ داده باشد.");@/
eqs("``If all else fails, read the instructions.''")@/
     ("«اگر باز هم مشکل حل نشد، دستورالعملها را مطالعه نمائید.»");@/
eqs("If you really absolutely need more capacity,")@/
     ("اگر جداً به ظرفیت بیشتری نیاز دارید،");@/
eqs("you can ask a wizard to enlarge me.")@/
     ("میتوانید از یک متخصص درخواست کنید ظرفیتهای مرا افزایش دهد.");@/
eqs("I'm broken. Please show this to someone who can fix can fix")@/
     ("من معیوب شده‌ام. این اشکال را به کسی نشان دهید تا آنرا رفع کند.");@/
eqs("One of your faux pas seems to have wounded me deeply...")@/
     ("بنظر میرسد یکی از عملیات شما آسیب شدیدی به من وارد نموده‌باشد...");@/
eqs("in fact, I'm barely conscious. Please fix it and try again.")@/
   ("من کاملاً هشیار هستم، لطفاً پس از رفع اشکالات خود دوباره سعی کنید.");@/
eqs("You rang?")@/
     ("کاری داشتید؟");@/
eqs("Try to insert some instructions for me (e.g.,`I\showlists'),")@/
     ("سعی کنید دستوری وارد نمائید (مثلاً:«د\نمایش‌بده‌لیستها»)،");@/
eqs("unless you just want to quit by typing `X'.")@/
     ("مگراینکه بخواهید با وارد نمودن «خ» بکار پایان دهید.");@/
eqs("I can handle only one magnification ratio per job. So I've")@/
     ("من در هر کار فقط با یک کسر بزرگنمایی میتوانم کار کنم. لذا من");@/
eqs("reverted to the magnification you used earlier on this run.")@/
     ("از همان بزرگنمایی که شما قبلاً گفته بودید، استفاده میکنم.");@/
eqs("The magnification ratio must be between 1 and 32768.")@/
     ("کسر بزرگنمایی میبایست مابین ۱ و ۳۲۷۶۸ باشد.");@/
eqs("A forbidden control sequence occurred in skipped text.")@/
     ("در متن نادیده گرفته‌شده یک واژه کنترلی ممنوع وجود داشت.");@/
eqs("This kind of error happens when you say `\if...' and forget")@/
     ("این اشکال وقتی واقع میشود که شما بگویید «\گر...» و«\رگ» مربوطه را");@/
eqs("the matching `\fi'. I've inserted a `\fi'; this might work.")@/
("فراموش کنید. در اینجا «\رگ» اضافه نمودم؛ ممکن است مؤثر واقع شود.");@/
eqs("A funny symbol that I can't read has just been input.")@/
     ("هم‌اکنون نشانه مضحکی که من قادر به خواندن آن نیستم وارد شد.");@/
eqs("Continue, and I'll forget that it ever happened.")@/
     ("ادامه دهید، من کلاً وقوع این مطلب را فراموش میکنم.");@/
eqs("If you say, e.g., `\def\a1{...}', then you must always")@/
     ("اگر مثلاً بگویید «\تر\آ۱{...}»، آنگاه میبایست همواره بعد از «\آ»،");@/
eqs("put `1' after `\a', since control sequence names are")@/
("«۱» را نیز بنویسید، زیرا اسامی واژگان کنترلی منحصراً از حروف تشکیل");@/
eqs("made up of letters only. The macro here has not been")@/
("میشوند. این ماکرو در اینجا نویسه‌های مربوطه را بدنبال خود ندارد،");@/
eqs("followed by the required stuff, so I'm ignoring it.")@/
     ("لذا من آنرا نادیده میگیرم.");@/
eqs("A number should have been here; I inserted `0'.")@/
     ("یک عدد میبایست در اینجا میبود؛ من «۰» درج کردم.");@/
eqs("(If you can't figure out why I needed to see a number,")@/
  ("(اگر سردرنمی‌آورید که چرا من در اینجا بدنبال یک عدد بودم، ");@/
eqs("look up `weird error' in the index to The TeXbook.)")@/
("به عنوان `weired error' در نمایهٔ کتاب The TeXbook مراجعه نمایید.");@/
eqs("I'm forgetting what you said and using zero instead.")@/
     ("من آنچه را شما گفتید فراموش میکنم و در عوض از صفر استفاده میکنم.");@/
eqs("A register number must be between 0 and 255.")@/
     ("عدد کد مربوط به یک ثبات میبایست مابین ۰ و ۲۵۵ باشد.");@/
eqs("A dimen or count register number must be between 0 and 512.")@/
     ("عدد کد مربوط به یک شمار یا بعد میبایست مابین ۰ و ۵۱۲ باشد.");@/
eqs("A character number must be between 0 and 255.")@/
     ("عدد کد مربوط به یک نویسه میبایست مابین ۰ و ۲۵۵ باشد.");@/
eqs("Since I expected to read a number between 0 and 15,")@/
     ("از آنجا که من بدنبال عددی مابین ۰ و ۱۵ بودم،");@/
eqs("A mathchar number must be between 0 and 36864, except 32768.")@/
     ("یک کد ریاضی عددی میبایست مابین ۰ و ۳۶۸۶۴، بجز ۳۲۷۶۸ باشد.");@/
eqs("I changed this one to zero.")@/
     ("من این یکی را به صفر تغییر دادم.");@/
eqs("A numeric delimiter code must be between 0 and 2^{27}-1.")@/
     ("یک کد جداساز عددی میبایست مابین ۰ و {۲۴}ْ۲*۹، بجز {۲۷}ْ۲ باشد.");@/
eqs("A one-character control sequence belongs after a ` mark.")@/
     ("پس از علامت ` میبایست یک واژه کنترلی یک-حرفی نوشته شود.");@/
eqs("So I'm essentially inserting \0 here.")@/
     ("لذا من در اینجا اساساً \۰ درج میکنم.");@/
eqs("I can only go up to 2147483647='17777777777=""7FFFFFFF,")@/
     ("من فقط تا عدد ۲۱۴۷۴۸۳۶۴۷=ُ۱۷۷۷۷۷۷۷۷۷۷ را میتوانم پردازش کنم،");@/
eqs("so I'm using that number instead of yours.")@/
      ("لذا بجای عدد شما این عدد را بکار میبرم.");@/
eqs("I dddon't go any higher than filll.")@/
     ("من نننمیتوانم از پررر فراتر بروم.");@/
eqs("The unit of measurement in math glue must be mu.")@/
     ("واحد اندازه‌گیری در ملات ریاضی بایست میو باشد.");@/
eqs("To recover gracefully from this error, it's best to")@/
     ("برای اصلاح مطلوب این خطا، بهتر است واحدهای غلط را حذف کنید؛");@/
eqs("delete the erroneous units; e.g., type `2' to delete")@/
     ("مثلاً برای حذف ۴ حرف، وارد کنید «۴».");@/
eqs("I can't work with sizes bigger than about 19 feet.")@/
     ("من نمیتوانم ابعاد بزرگتر از ۵ متر را پردازش کنم.");@/
eqs("Continue and I'll use the largest value I can.")@/
     ("ادامه دهید و من بزرگترین مقدار ممکن را بکار خواهم برد.");@/
eqs("I'm going to ignore the # sign you just used.")@/
     ("در نظر دارم علامت # جاری را نادیده بگیرم.");@/
eqs("I've inserted the digit you should have used after the #.")@/
      ("شماره مناسب بعد از # را افزوده‌ام.");@/
eqs("Type `1' to delete what you did use.")@/
      ("برای حذف عدد خود «۱» وارد کنید.");@/
eqs("You meant to type ## instead of #, right?")@/
     ("شاید می‌خواسته‌اید ## را بجای # بزنید؟");@/
eqs("Or maybe a } was forgotten somewhere earlier, and things")@/
     ("یا ممکن است } را در سطرهای قبل فراموش کرده باشید");@/
eqs("are all screwed up? I'm going to assume that you meant ##.")@/
     ("درنظر دارم فرض کنم منظور شما ## بوده است.");@/
eqs("I was expecting to see `<', `=', or `>'. Didn't.")@/
     ("من بدنبال «>»، «=»، یا «<» بودم، ولی آنرا نیافتم.");@/
eqs("There should be exactly one # between &'s, when an")@/
     ("وقتی یک \ردیف‌ا یا \ردیف‌و در حال تشکیل است،");@/
eqs("none, so I've put one in; maybe that will work.")@/
     ("آنرا جاانداخته بودید، لذا من یکی درج نمودم؛ شاید مؤثر واقع شود.");@/
eqs("\halign or \valign is being set up. In this case you had")@/
     ("مابین &ها فقط وفقط یک # میبایست نوشته شود. در این مورد شما");@/
eqs("more than one, so I'm ignoring all but the first.")@/
     ("بیش از یکی داشتید، لذا من همه آنها بجز اولی را نادیده میگیرم.");@/
eqs("You have given more \span or & marks than there were")@/
     ("تعداد \ادغام یا &هایی که شما بکار برده‌اید. بیش از تعدادیست که");@/
eqs("in the preamble to the \halign or \valign now in progress.")@/
     ("در الگوی \ردیف‌ا یا \ردیف‌و درحال‌تشکیل قیدشده.");@/
eqs("So I'll assume that you meant to type \cr instead.")@/
     ("لذا من فرض میکنم که شما قصد نوشتن \سخ داشته‌اید.");@/
eqs("Sorry, but I'm not programmed to handle this case;")@/
     ("متأسفم، ولی من برای پردازش این مورد برنامه‌ریزی نشده‌ام؛");@/
eqs("I'll just pretend that you didn't ask for it.")@/
     ("من چنین وانمود میکنم که شما اصلاً چنین چیزی نمی‌خواستید.");@/
eqs("If you're in the wrong mode, you might be able to")@/
     ("اگر در حالت اشتباه هستید، ممکن است با وارد کردن");@/
eqs("Sorry, but I can't handle semitic characters in formulas, YET.")@/
     ("متأسفم، ولی من هنوز نمیتوانم نویسه‌های فارسی را در فرمول‌های ریاضی");@/
eqs("I'll just use the latin letter `a' instead of your semitic character.")@/
("پردازش کنم. من بجای نویسه فارسی شما موقتاً حرف لاتین `a' را قرار می‌دهم.");@/
eqs("Or maybe you're in the wrong mode. If so, you might be able to")@/
     ("یا شاید در حالت اشتباه هستید، دراینصورت ممکن است با وارد کردن");@/
eqs("return to the right one by typing `I}' or `I$' or `I\par'.")@/
     ("«د}» یا «د$» یا «د\بند»، بتوانید به حالت درست بازگردید. ");@/
eqs("Sorry, Pandora. (You sneaky devil.)")@/
     ("متأسفم، دوست عزیز. (ای شیطون!)");@/
eqs("I refuse to unbox an \hbox in vertical mode or vice versa.")@/
     ("من از بازکردن \کادرا در حالت عمودی و بالعکس خودداری میکنم.");@/
eqs("And I can't open any boxes in math mode.")@/
     ("و ضمناً نمیتوانم در حالت ریاضی هیچ کادری را باز کنم.");@/
eqs("I'll pretend you didn't say \long or \outer or \global.")@/
     ("من وانمود میکنم که شما نگفتید \بلند یا \برونی یا \عام.");@/
eqs("I'll pretend you didn't say \long or \outer here.")@/
     ("من وانمود میکنم که شما در اینجا نگفتید \بلند یا \برونی.");@/
eqs("Please don't say `\semifont cs...', say `\semifont\cs...'.")@/
     ("لطفاً نگویید «\قلم اسم...»، بگویید «\قلم\اسم...».");@/
eqs("I've inserted an inaccessible control sequence so that your")@/
     ("من یک واژه کنترلی غیر قابل دسترسی در اینجا درج کردم تا تعریف شما");@/
eqs("You can recover graciously from this error, if you're")@/
     ("اگر با دقت عمل کنید میتوانید بنحو مطلوبی این خطا را اصلاح کنید؛");@/
eqs("careful; see exercise 27.2 in The TeXbook.")@/
     ("به تمرین ۲.۲۷ در کتاب  The TeXbook مراجعه کنید.");@/
eqs("Please don't say `\def cs{...}', say `\def\cs{...}'.")@/
     ("لطفاً نگویید «\تر اسم{...}»، بگویید «\تر\اسم{...}».");@/
eqs("definition will be completed without mixing me up too badly.")@/
     ("بدون اینکه اوضاع مرا کلاً بهم بریزد، تکمیل شود.");@/
eqs("Please use ")("لطفاً «");@/
eqs(" for accents in math mode")("» را برای اعراب در حالت ریاضی بکار ببرید");@/
eqs("I'm changing \accent to \mathaccent here; wish me luck.")@/
    ("من فرمان اعراب شما را به \اعراب‌ریاضی تبدیل می‌کنم؛ شاید درست بشود.");@/
eqs("(Accents are not the same in formulas as they are in text.)")@/
   ("(اعراب در فرمولها همانند اعراب در متن نیستند.)");@/
eqs("You should have said `\read<number> to \cs'.")@/
     ("شما میبایست میگفتید «\بخوان>عدد< به \فرمان».");@/
eqs("I'm going to look for the \cs now.")@/
     ("حالا من بدنبال \فرمان هستم.");@/
eqs("I'm going to use 0 instead of that illegal code value.")@/
     ("من قصد دارم بجای آن کد نادرست، از ۰ استفاده کنم.");@/
eqs("I can't carry out that multiplication or division,")@/
     ("من نمیتوانم این ضرب یا تقسیم را اجرا کنم،");@/
eqs("since the result is out of range.")@/
     ("زیرا حاصل آن خارج از محدوده است.");@/
eqs("I'm forgetting what you said and not changing anything.")@/
     ("من گفته‌های شما را نادیده گرفته و عجالتاً چیزی را تغییر نمیدهم.");@/
eqs("I allow only values in the range 1..32767 here.")@/
     ("من در اینجا فقط مقادیر از ۱ الا ۳۲۷۶۷ را مجاز میدانم.");@/
eqs("I allow only nonnegative values here.")@/
     ("من در اینجا فقط مقادیر غیر منفی را مجاز میدارم.");@/
eqs("Latin fonts can't be converted to twin fonts.")@/
     ("یک قلم‌لاتین را نمیتوان به یک قلم‌همزاد تبدیل نمود.");@/
eqs("Latin fonts can't have twin fonts.")@/
     ("یک قلم‌لاتین نمیتواند قلم‌همزاد داشته باشد.");@/
eqs("Latin fonts can't be twin fonts.")@/
     ("یک قلم‌لاتین نمیتواند قلم‌همزاد باشد.");@/
eqs("Control sequence `\activefont' is only for inspection,")@/
     ("واژه کنترلی «\قلم‌فعال» فقط برای بازبینی قابل استفاده است،");@/
eqs("not for font defining. I deleted your command.")@/
     ("نه برای تعریف قلم. من فرمان شما را حذف کردم.");@/
eqs
("If you really want to define a font, just type `I\font' or `I\semifont'.")@/
("اگر واقعاً میخواهید قلم تعریف کنید، درج کنید «د\قلم» یا «د\قلم‌لاتین».");@/
eqs("I can only handle fonts at positive sizes that are")@/
     ("من تنها با قلم‌هایی دراندازه‌های مثبت کمتر از ۲۰۴۸پونت میتوانم");@/
eqs("less than 2048pt, so I've changed what you said to 10pt.")@/
     ("کار کنم، لذا من آنچه شما گفته بودید را به ۱۰پونت تغییر دادم.");@/
eqs("(That was another \errmessage.)")@/
     ("(این یک \پیام‌خطا ی دیگر بود.)");@/
eqs("This error message was generated by an \errmessage")@/
     ("این پیام خطا بوسیله یک فرمان \پیام‌خطا صادر شده است،");@/
eqs("command, so I can't give any explicit help.")@/
  ("و لذا کمک خاصی از من ساخته نیست.");@/
eqs("Pretend that you're Hercule Poirot: Examine all clues,")@/
  ("وانمود کنید هرکول پوارو هستید: همه مدارک و نشانه‌ها را بررسی کنید،");@/
eqs("and deduce the truth by order and method.")@/
     ("و با استفاده از نظم و قاعده به حقیقت دست یابید.");@/
eqs("This isn't an error message; I'm just \showing something.")@/
     ("این یک پیام خطا نیست، من فقط دارم چیزی را \نمایش میدهم.");@/
eqs("Type `I\show...' to show more (e.g., \show\cs,")@/
     ("برای نمایش بیشتر درج کنید «د\نمایش‌بده...» (مثلاً، \نمایش‌بده\فرمان،");@/
eqs("\showthe\count10, \showbox255, \showlists).")@/
     ("\نمایش‌بده‌محتوای\شمار۱۰، \نمایش‌بده‌کادر۲۵۵، \نمایش‌بده‌لیستها).");@/
eqs("And type `I\tracingonline=1\show...' to show boxes and")@/
     ("و یا درج کنید «د\ردگیری‌نمایشی=۱\نمایش‌بده...» تا کادرها و لیستها را");@/
eqs("lists on your terminal as well as in the transcript file.")@/
     ("هم بر روی پایانه‌تان و هم در پرونده کارنامه نمایش دهم.");@/
eqs("`{...\dump}' is a no-no.")@/
     ("«{...\تخلیه}» کلاً ممنوع است.");@/
eqs("On this page there's a \write with fewer real {'s than }'s.")@/
     ("در این صفحه یک \بنویس وجود دارد که {های واقعی کمتری از }ها دارد.");@/
eqs("I can't handle that very well; good luck.")@/
     ("من نمیتوانم چنین حالتی را درست پردازش کنم؛ موفق باشید.");@/
eqs("Go ahead. I am going to ignore it.")@/
     ("ادامه دهید. من این فرمان را نادیده میگیرم.");@/
eqs("Your `\endL' command doesn't match any previous `\beginL' command.")@/
     ("فرمان «\پایان‌چپ» شما با فرمان «\شروع» قبلی جفت نمیشود.");@/
eqs("I have replaced your errorenous `\endL' by a correct `\endR' command,")@/
     ("من «\پایان‌چپ» نادرست شما را با یک «\پایان‌راست» درست جایگزین نمودم،");@/
eqs("assuming that you meant to end your previous `\beginR'.")@/
     ("با این فرض که شما قصد داشتید «\شروع‌راست» قبلی خود را پایان دهید.");@/
eqs("If you don't need it, just type `1' and my insertion will be deleted.")@/
     ("اگر واقعاً به آن نیازی ندارید، وارد کنید «۱» و عمل من خنثی میشود.");@/
eqs("But make sure that your previous `\beginR' would be endded correctly.")@/
     ("ولی حواستان باشد که «\شروع‌راست» قبلی‌تان بدرستی پایان داده شود.");@/
eqs("Your `\endR' command doesn't match any previous `\beginR' command.")@/
     ("فرمان «\پایان‌راست» شما با فرمان «\شروع» قبلی جفت نمیشود.");@/
eqs("I have replaced your errorenous `\endR' by a correct `\endL' command,")@/
     ("من «\پایان‌راست» نادرست شما را با یک «\پایان‌چپ» درست جایگزین نمودم،");@/
eqs("assuming that you meant to end your previous `\beginL'.")@/
     ("با این فرض که شما قصد داشتید «\شروع‌چپ» قبلی خود را پایان دهید.");@/
eqs("But make sure that your previous `\beginL' would be endded correctly.")@/
     ("ولی حواستان باشد که «\شروع‌چپ» قبلی‌تان بدرستی پایان داده شود.");@/
eqs("The control sequence at the end of the top line")@/
("واژه کنترلی انتهای سطر بالای پیام خطای شما هرگز تعریف نشده است.");@/
eqs("of your error message was never \def'ed. If you have")@/
("اگر در املای آن اشتباهی رخ‌داده (مثلاً، «\کاردا»)،");@/
eqs("misspelled it (e.g., `\hobx'), type `I' and the correct")@/
("پس از وارد نمودن «د» املای آنرا اصلاح کنید (مثلاً «د\کادرا»).");@/
eqs("spelling (e.g., `I\hbox'). Otherwise just continue,")@/
("در غیر اینصورت بکار خود ادامه دهید،");@/
eqs("and I'll forget about whatever was undefined.")@/
(" و من هر آنچه را که تعریف نشده است فراموش خواهم کرد.");@/
eqs("I suspect you've forgotten a `}', causing me to apply this")@/
("تصور می‌کنم «}» جا افتاده باشد، و این موجب شده است من این همه");@/
eqs("control sequence to too much text. How can we recover?")@/
 ("متن را به عنوان پارامتر این دستور بخوانم.");@/
eqs("My plan is to forget the whole thing and hope for the best.")@/
("در نظر دارم همه چیز را فراموش کنم و امید به بهبود داشته باشم.");@/
eqs("I suspect you have forgotten a `}', causing me")@/
("تصور می‌کنم «}» جا افتاده باشد، و این موجب شده است ");@/
eqs("to read past where you wanted me to stop.")@/
 ("از محدودهٔ مورد نظر شما بیشتر بخوانم.");@/
eqs("I'll try to recover; but if the error is serious,")@/
("من سعی می‌کنم خطا را مرتفع کنم ولی اگر این خطا جدی است،");@/
eqs("you'd better type `E' or `X' now and fix your file.")@/
("بهتر است با زدن «و» یا «خ» خودتان آنرا اصلاح کنید.");@/
eqs("Dimensions can be in units of em, ex, in, pt, pc,")@/
("ابعاد میتوانند به واحدهای ام، اکس، اینچ، پونت، پیکا ،");@/
eqs("cm, mm, dd, cc, bp, or sp; but yours is a new one!")@/
("سانت، میلی‌متر، پونت‌دیدو، سیسرو، پونت‌بزرگ، یا اس‌پی داده شوند؛");@/
eqs("I'll assume that you meant to say pt, for printer's points.")@/
("ولی گفتهٔ شما نوع جدیدیست! فرض میکنم منظور شما پونت بوده است.");@/
eqs("two letters. (See Chapter 27 of The TeXbook.)")@/
("(به فصل ۲۷ کتاب The TeXbook مراجعه کنید.)");@/
eqs("You should say `\leaders <box or rule><hskip or vskip>'.")@/
  ("شما میبایست بگوئید «\نشانگر>کادر یا خط<>فاصله‌ا یا فاصله‌و<.»");@/
eqs("I found the <box or rule>, but there's no suitable")@/
  ("من >کادر یا خط< را دیدم، ولی >فاصله‌ا یا فاصله‌و< مناسبی نیافتم،");@/
eqs("<hskip or vskip>, so I'm ignoring these leaders.")@/
  ("لذا من این نشانگرها را نادیده می‌گیرم.");@/
eqs("Type <return> to proceed, S to scroll future error messages,")@/
("برای ادامه کار <return>، برای نادیده گرفتن اشکالات بعدی «ن»،");@/
eqs("R to run without stopping, Q to run quietly,")@/
("برای ادامه کار بدون توقف «ت»، برای ادامه کار بدون سروصدا «س»،");@/
eqs("I to insert something, ")("برای درج مطلب جدید «د»، ");@/
eqs("E to edit your file,")("«و»، برای ویرایش پرونده");@/
eqs("1 or ... or 9 to ignore the next 1 to 9 tokens of input,")@/
("برای نادیده گرفتن ۱ الا ۹ جزء بعدی ورودی ۰ یا ... یا ۹،");@/
eqs("H for help, X to quit.")@/
("برای کمک «ک»، و برای خروج از برنامه «خ» را بزنید.");@/
eqs("The file ended while I was skipping conditional text.")@/
("وقتی من در حال خواندن یک متن شرطی بودم، پرونده به پایان رسید.");@/
eqs("I've run across a `}' that doesn't seem to match anything.")@/
("من به یک «}» برخورده‌ام که به نظر می‌رسد با چیزی جفت نمی‌شود.");@/
eqs("For example, `\def\a#1{...}' and `\a}' would produce")@/
("مثلاً، «\تر\آ#۱{...}» و \آ} باعث بروز این پیام خطا می‌شود.");@/
eqs("this error. If you simply proceed now, the `\par' that")@/
("اگر به سادگی از آن بگذرید «\بند»ی که من هم اکنون درج کرده‌ام");@/
eqs("I've just inserted will cause me to report a runaway")@/
("ممکن است باعث ایجاد خطای آرگومان بی‌انتها شود.");@/
eqs("argument that might be the root of the problem. But if")@/
("که احتمالاً علت اصلی همان است. ولی اگر «}»  اضافی بوده است،");@/
eqs("your `}' was spurious, just type `2' and it will go away.")@/
("فقط «۲» بزنید تا کار ادامه پیدا کند.");@/
eqs("Command names can be equated only with another command name.")@/
   ("نام هر فرمان تنها می‌تواند با نام فرمان دیگری جانشین شود.");@/
eqs("Only equated commands can be \noteqname.")@/
   ("تنها فرمانهایی که قبلاً جانشین شده‌اند می‌توانند \ناهمنام شوند.");@/
eqs("Diferent command names can be equated.")@/
   ("تنها فرمانهایی با نامهای مختلف می‌توانند همنام شوند.");@/
eqs("I'm ignoring the command and its parameters")@/
   ("من فرمان شما را به همراه پارامترهایش نادیده خواهم گرفت.");@/
eqs("File ended")("پرونده به پایان رسید.");@/
eqs("Forbidden control sequence found")("واژه کنترلی ممنوع دیده شد");@/
eqs(" while scanning ")("هنگامی که در حال ");@/
eqs("retaining")("نگه‌میداریم");@/
eqs("restoring")("بازیابی‌میکنیم");@/
eqs("input file name")("ورودی");@/
eqs("file name for output")("خروجی نهایی");@/
eqs("transcript file name")("کارنامه");@/
eqs("format file name")("قالب");@/
eqs("output file name")("خروجی متن");@/
eqs(" of ")(" واژهٔ «");@/
eqs(" old eqname `")(" فرمان همنام قبلی «");@/
eqs("Font ")("پروندهٔ (TFM) قلم ");@/
eqs(" scaled ")(" باضریب ");@/
eqs(" not loadable: Bad metric (TFM) file")(" درست نیست");@/
eqs(" not loadable: Metric (TFM) file not found")(" موجود نیست");@/
eqs(" not loaded: Not enough room left")@/
   (" نمی‌تواند باز شود چون جایی باقی نمانده است")@/;
eqs("speech language")("زبان محاوره");@/
eqs("speech direction")("جهت محاوره");@/
eqs("> \box")("< \کادر");@/
eqs("Extra \endspecial, ignored")("\پایان‌ویژه اضافی، نادیده گرفته می‌شود");@/
eqs("\endspecial must be match with \beginspecial.")@/
   ("فرمان \پایان‌ویژه ب‍‌ایستی پس از \شروع‌ویژه بیاید.");
end;
tini
@z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [55.1380] Change Index section number
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@* \[55] Index.
@y
@* \[65] Index.
@z
